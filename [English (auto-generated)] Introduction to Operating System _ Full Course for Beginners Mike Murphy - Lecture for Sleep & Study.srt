1
00:00:01,260 --> 00:00:03,720
sleep and study don't forget to

2
00:00:03,720 --> 00:00:04,860
subscribe

3
00:00:04,860 --> 00:00:07,140
in this lecture I'm going to introduce

4
00:00:07,140 --> 00:00:09,599
the fundamentals of operating systems

5
00:00:09,599 --> 00:00:13,200
what they are what they do and why

6
00:00:13,200 --> 00:00:15,059
they're important now what's an

7
00:00:15,059 --> 00:00:16,560
operating system

8
00:00:16,560 --> 00:00:19,380
well it's a layer of software that

9
00:00:19,380 --> 00:00:22,859
provides two important services to a

10
00:00:22,859 --> 00:00:24,359
computer system

11
00:00:24,359 --> 00:00:28,160
it provides abstraction and arbitration

12
00:00:28,160 --> 00:00:31,140
abstraction means hiding the details of

13
00:00:31,140 --> 00:00:33,540
different Hardware configurations so

14
00:00:33,540 --> 00:00:35,700
that each application doesn't have to be

15
00:00:35,700 --> 00:00:37,980
tailored for each possible device that

16
00:00:37,980 --> 00:00:40,379
might be present on a system arbitration

17
00:00:40,379 --> 00:00:43,200
means that the operating system manages

18
00:00:43,200 --> 00:00:46,320
access to shared hardware resources so

19
00:00:46,320 --> 00:00:48,480
that multiple applications can run on

20
00:00:48,480 --> 00:00:50,219
the same Hardware at the same time

21
00:00:50,219 --> 00:00:52,620
without interfering with one another at

22
00:00:52,620 --> 00:00:54,420
least Hardware resources that need to be

23
00:00:54,420 --> 00:00:57,140
managed include the CPU

24
00:00:57,140 --> 00:01:00,539
hierarchy of memory all the input output

25
00:01:00,539 --> 00:01:03,600
devices on the system and to some degree

26
00:01:03,600 --> 00:01:05,820
the power and system management features

27
00:01:05,820 --> 00:01:07,159
in the system

28
00:01:07,159 --> 00:01:09,360
many of these features are handled

29
00:01:09,360 --> 00:01:10,979
directly by the hardware but the

30
00:01:10,979 --> 00:01:12,540
operating system is involved

31
00:01:12,540 --> 00:01:15,479
particularly in energy conservation now

32
00:01:15,479 --> 00:01:17,460
the abstraction features of the

33
00:01:17,460 --> 00:01:20,159
operating system allow Hardware devices

34
00:01:20,159 --> 00:01:23,520
manufactured by different manufacturers

35
00:01:23,520 --> 00:01:25,380
to have

36
00:01:25,380 --> 00:01:27,720
the same interface

37
00:01:27,720 --> 00:01:31,439
within software for applications to use

38
00:01:31,439 --> 00:01:33,659
these Hardware devices all have

39
00:01:33,659 --> 00:01:35,640
different low-level instruction sets

40
00:01:35,640 --> 00:01:38,340
they all have particularly particular

41
00:01:38,340 --> 00:01:42,900
capabilities features and details that

42
00:01:42,900 --> 00:01:45,659
are unique to each Hardware device

43
00:01:45,659 --> 00:01:47,640
if we didn't have a common interface

44
00:01:47,640 --> 00:01:50,759
into these Hardware devices first of all

45
00:01:50,759 --> 00:01:52,799
our variety of Hardware might be limited

46
00:01:52,799 --> 00:01:55,439
but worse every application on the

47
00:01:55,439 --> 00:01:57,299
system would have to be programmed to

48
00:01:57,299 --> 00:02:00,479
use every single device on the system

49
00:02:00,479 --> 00:02:04,020
an example back in the 1990s computer

50
00:02:04,020 --> 00:02:06,600
games often required internal

51
00:02:06,600 --> 00:02:09,479
programming for specific video cards and

52
00:02:09,479 --> 00:02:11,940
specific sound cards it was often

53
00:02:11,940 --> 00:02:13,920
necessary to go into the settings for

54
00:02:13,920 --> 00:02:16,739
each game and tell the game what type of

55
00:02:16,739 --> 00:02:18,900
video card you had what type of sound

56
00:02:18,900 --> 00:02:21,120
card you had for the purpose of

57
00:02:21,120 --> 00:02:23,040
configuring the game to use that

58
00:02:23,040 --> 00:02:24,360
particular Hardware

59
00:02:24,360 --> 00:02:26,640
imagine if that had to be done for every

60
00:02:26,640 --> 00:02:28,620
single application on the system

61
00:02:28,620 --> 00:02:30,959
including say a calculator or a web

62
00:02:30,959 --> 00:02:34,080
browser that would be very untenable

63
00:02:34,080 --> 00:02:36,900
situation in terms of being able to make

64
00:02:36,900 --> 00:02:38,879
use of computers the way we use them

65
00:02:38,879 --> 00:02:40,319
today

66
00:02:40,319 --> 00:02:43,379
also what if we could only run one

67
00:02:43,379 --> 00:02:46,140
program at a time on a computer system

68
00:02:46,140 --> 00:02:48,200
years and years ago that was the case

69
00:02:48,200 --> 00:02:50,700
however a modern system is running

70
00:02:50,700 --> 00:02:53,519
multiple applications simultaneously

71
00:02:53,519 --> 00:02:55,800
and it's up to the operating system to

72
00:02:55,800 --> 00:02:57,720
ensure that all these applications can

73
00:02:57,720 --> 00:03:01,739
access resources so each CPU is divided

74
00:03:01,739 --> 00:03:03,900
among the different programs each

75
00:03:03,900 --> 00:03:07,019
program gets access to memory

76
00:03:07,019 --> 00:03:11,700
input output as well as disk and in an

77
00:03:11,700 --> 00:03:14,220
Ideal World the operating system also

78
00:03:14,220 --> 00:03:16,680
enforces policies that isolate

79
00:03:16,680 --> 00:03:19,019
applications from each other so that a

80
00:03:19,019 --> 00:03:21,360
crash in one application doesn't take

81
00:03:21,360 --> 00:03:23,459
down the entire system or other

82
00:03:23,459 --> 00:03:24,720
applications

83
00:03:24,720 --> 00:03:26,340
now

84
00:03:26,340 --> 00:03:29,159
of these examples do we have a situation

85
00:03:29,159 --> 00:03:32,640
where we have abstraction or arbitration

86
00:03:32,640 --> 00:03:35,280
well first example supporting both Intel

87
00:03:35,280 --> 00:03:37,379
and AMD processors

88
00:03:37,379 --> 00:03:40,560
this is an example of abstraction

89
00:03:40,560 --> 00:03:42,900
we don't have to write separate software

90
00:03:42,900 --> 00:03:45,959
for an Intel processor

91
00:03:45,959 --> 00:03:48,840
relative to an AMD processor at least

92
00:03:48,840 --> 00:03:52,260
for 99.99 of applications

93
00:03:52,260 --> 00:03:54,780
simply write the application once it

94
00:03:54,780 --> 00:03:57,720
will run on either process

95
00:03:57,720 --> 00:04:00,540
switching between applications is an

96
00:04:00,540 --> 00:04:02,459
example of arbitrating Hardware

97
00:04:02,459 --> 00:04:04,739
resources among the different

98
00:04:04,739 --> 00:04:07,560
applications on the system

99
00:04:07,560 --> 00:04:10,019
separating memory allocated to different

100
00:04:10,019 --> 00:04:12,900
applications is also an arbitration

101
00:04:12,900 --> 00:04:16,738
activity it keeps one application when

102
00:04:16,738 --> 00:04:18,779
overwriting the contents of memory that

103
00:04:18,779 --> 00:04:21,380
being used by another application

104
00:04:21,380 --> 00:04:24,300
enabling video conferencing software to

105
00:04:24,300 --> 00:04:26,340
use different camera devices

106
00:04:26,340 --> 00:04:28,860
this would be an example of abstraction

107
00:04:28,860 --> 00:04:31,020
the video conferencing program just has

108
00:04:31,020 --> 00:04:33,600
to know how to use a camera interface

109
00:04:33,600 --> 00:04:36,120
that the operating system provides and

110
00:04:36,120 --> 00:04:37,440
then different cameras from different

111
00:04:37,440 --> 00:04:39,840
manufacturers can be used

112
00:04:39,840 --> 00:04:41,940
without having to write the application

113
00:04:41,940 --> 00:04:44,880
the video conferencing program to be

114
00:04:44,880 --> 00:04:48,380
able to talk to each individual camera

115
00:04:48,380 --> 00:04:51,000
similarly accessing two different hard

116
00:04:51,000 --> 00:04:53,240
disks from two different manufacturers

117
00:04:53,240 --> 00:04:55,919
any underlying detail differences

118
00:04:55,919 --> 00:04:58,500
between those drives can be handled by

119
00:04:58,500 --> 00:05:00,540
using the operating system to abstract

120
00:05:00,540 --> 00:05:02,759
away the details

121
00:05:02,759 --> 00:05:05,040
sending and receiving messages over a

122
00:05:05,040 --> 00:05:07,139
network is both abstraction and

123
00:05:07,139 --> 00:05:09,960
arbitration on the one hand we're

124
00:05:09,960 --> 00:05:11,820
abstracting away the details of each

125
00:05:11,820 --> 00:05:13,740
particular network card to be able to

126
00:05:13,740 --> 00:05:15,900
send and receive the message on the

127
00:05:15,900 --> 00:05:17,520
other hand we're sharing that network

128
00:05:17,520 --> 00:05:19,139
card among all the different

129
00:05:19,139 --> 00:05:22,340
applications on the system

130
00:05:22,680 --> 00:05:25,440
now we can think of the system in terms

131
00:05:25,440 --> 00:05:26,759
of layers

132
00:05:26,759 --> 00:05:29,039
at the bottom of the layer cake we have

133
00:05:29,039 --> 00:05:30,060
the hardware

134
00:05:30,060 --> 00:05:33,479
this is what executes the software the

135
00:05:33,479 --> 00:05:35,100
top three layers

136
00:05:35,100 --> 00:05:38,400
the operating system is the middleman so

137
00:05:38,400 --> 00:05:41,039
to speak between the applications and

138
00:05:41,039 --> 00:05:42,840
the libraries and utilities upon which

139
00:05:42,840 --> 00:05:44,940
the applications Depend and the

140
00:05:44,940 --> 00:05:47,660
underlying Hardware

141
00:05:47,759 --> 00:05:51,240
specifically the core of the operating

142
00:05:51,240 --> 00:05:54,840
system or the kernel so named after say

143
00:05:54,840 --> 00:05:56,940
a kernel of corn

144
00:05:56,940 --> 00:06:00,660
is the minimum piece of software that's

145
00:06:00,660 --> 00:06:04,199
needed to share the hardware between the

146
00:06:04,199 --> 00:06:06,180
different applications

147
00:06:06,180 --> 00:06:09,180
whatever lives outside the kernel that

148
00:06:09,180 --> 00:06:12,199
is software is said to be in user space

149
00:06:12,199 --> 00:06:16,380
that means it's application code or

150
00:06:16,380 --> 00:06:18,120
sometimes even parts of the operating

151
00:06:18,120 --> 00:06:21,199
system that are not strictly necessary

152
00:06:21,199 --> 00:06:25,319
to share the hardware or abstract away

153
00:06:25,319 --> 00:06:28,259
its details

154
00:06:28,259 --> 00:06:32,220
now operating systems Implement a common

155
00:06:32,220 --> 00:06:34,319
mechanism for allowing applications to

156
00:06:34,319 --> 00:06:37,319
access the hardware which is abstraction

157
00:06:37,319 --> 00:06:40,440
and the applications make requests from

158
00:06:40,440 --> 00:06:42,720
the operating system to go and access

159
00:06:42,720 --> 00:06:45,360
the hardware or other features by making

160
00:06:45,360 --> 00:06:47,759
system calls down into the operating

161
00:06:47,759 --> 00:06:50,039
system this is called entering the

162
00:06:50,039 --> 00:06:52,080
operating system or iterating entering

163
00:06:52,080 --> 00:06:55,440
the kernel from the top path

164
00:06:55,440 --> 00:06:59,039
operating systems are also able to alert

165
00:06:59,039 --> 00:07:01,979
applications that Hardware has changed

166
00:07:01,979 --> 00:07:04,020
perhaps a network packet has come in

167
00:07:04,020 --> 00:07:06,360
perhaps the user has pressed a key on

168
00:07:06,360 --> 00:07:07,620
the keyboard

169
00:07:07,620 --> 00:07:09,720
these alerts

170
00:07:09,720 --> 00:07:11,940
are delivered via system called

171
00:07:11,940 --> 00:07:15,060
interrupts and refer to entering the

172
00:07:15,060 --> 00:07:17,160
kernel from the bottom half from the

173
00:07:17,160 --> 00:07:20,099
hardware side of the operating system

174
00:07:20,099 --> 00:07:21,660
we should also note that operating

175
00:07:21,660 --> 00:07:23,819
systems can manage and terminate

176
00:07:23,819 --> 00:07:26,880
applications by sending signals to those

177
00:07:26,880 --> 00:07:29,400
applications

178
00:07:29,400 --> 00:07:31,020
now there are a wide variety of

179
00:07:31,020 --> 00:07:33,300
operating systems out there they

180
00:07:33,300 --> 00:07:35,300
basically fall into two categories

181
00:07:35,300 --> 00:07:38,759
Microsoft Windows which is not Unix and

182
00:07:38,759 --> 00:07:41,539
everything else which is UNIX

183
00:07:41,539 --> 00:07:44,580
Microsoft Windows systems non-unic

184
00:07:44,580 --> 00:07:47,280
systems are the most popular desktop

185
00:07:47,280 --> 00:07:49,560
operating systems at the moment

186
00:07:49,560 --> 00:07:51,840
however they're rapidly being eclipsed

187
00:07:51,840 --> 00:07:54,720
by tablet devices most of which are

188
00:07:54,720 --> 00:07:58,440
running Unix style systems Windows is

189
00:07:58,440 --> 00:08:00,060
typically pre-installed by PC

190
00:08:00,060 --> 00:08:03,180
manufacturers which accounts for a good

191
00:08:03,180 --> 00:08:06,060
portion of its present popularity

192
00:08:06,060 --> 00:08:09,180
Unix systems on the other hand are

193
00:08:09,180 --> 00:08:12,300
installed by the end user except for

194
00:08:12,300 --> 00:08:15,479
commercial Unix systems and Mac OS 10.

195
00:08:15,479 --> 00:08:18,120
Mac OS 10 is probably the best selling

196
00:08:18,120 --> 00:08:22,740
Unix system of date and Linux which

197
00:08:22,740 --> 00:08:24,919
includes the Android platform

198
00:08:24,919 --> 00:08:27,360
is probably second

199
00:08:27,360 --> 00:08:29,940
now there are some Mainframe systems out

200
00:08:29,940 --> 00:08:32,039
there also some of which are Unix like

201
00:08:32,039 --> 00:08:35,760
some use custom operating systems there

202
00:08:35,760 --> 00:08:38,399
are a variety of players in the embedded

203
00:08:38,399 --> 00:08:40,919
systems Market however that's presently

204
00:08:40,919 --> 00:08:44,700
dominated by Android with Apple's IOS

205
00:08:44,700 --> 00:08:48,000
which is based on Mac OS 10 in close

206
00:08:48,000 --> 00:08:49,200
second

207
00:08:49,200 --> 00:08:50,760
others

208
00:08:50,760 --> 00:08:54,300
Symbian Blackberry OS tiny os are

209
00:08:54,300 --> 00:08:56,519
confined to smaller markets

210
00:08:56,519 --> 00:08:59,700
now the idea behind the Unix systems

211
00:08:59,700 --> 00:09:03,360
began with a time sharing system started

212
00:09:03,360 --> 00:09:06,480
in 1964 called multix and the idea

213
00:09:06,480 --> 00:09:08,339
behind maltics was to make Computing

214
00:09:08,339 --> 00:09:10,680
into a remote service that could be

215
00:09:10,680 --> 00:09:13,019
accessed by terminals using telephone

216
00:09:13,019 --> 00:09:15,720
lines it wasn't terribly successful

217
00:09:15,720 --> 00:09:17,940
because dial-up connections of the time

218
00:09:17,940 --> 00:09:20,899
at about 9 600 baud were rather slow

219
00:09:20,899 --> 00:09:23,760
however Canada actually did have a

220
00:09:23,760 --> 00:09:26,100
multic system deployed and used to this

221
00:09:26,100 --> 00:09:27,480
part of their National Defense Network

222
00:09:27,480 --> 00:09:29,640
until the year 2000.

223
00:09:29,640 --> 00:09:32,459
maltix has remembered however primarily

224
00:09:32,459 --> 00:09:35,820
for its influence as a multi-user shared

225
00:09:35,820 --> 00:09:36,779
system

226
00:09:36,779 --> 00:09:39,720
and today with cloud computing there's

227
00:09:39,720 --> 00:09:42,360
some significant parallels between some

228
00:09:42,360 --> 00:09:44,339
of the cloud computing models that we

229
00:09:44,339 --> 00:09:46,620
used and some of the ideas that were

230
00:09:46,620 --> 00:09:48,899
pioneered back in the multic system

231
00:09:48,899 --> 00:09:52,620
now Unix was actually a play on the term

232
00:09:52,620 --> 00:09:53,940
multix

233
00:09:53,940 --> 00:09:57,360
it was developed by Bell labs in 1969

234
00:09:57,360 --> 00:10:00,420
it's actually a trademark term so some

235
00:10:00,420 --> 00:10:03,300
authors use starnics to refer to the

236
00:10:03,300 --> 00:10:05,940
family of systems and use the word Unix

237
00:10:05,940 --> 00:10:08,459
only for the commercial distributions

238
00:10:08,459 --> 00:10:10,800
the original Unix systems were

239
00:10:10,800 --> 00:10:13,440
commercial distributions with free

240
00:10:13,440 --> 00:10:17,100
variance BSD and Linux coming along late

241
00:10:17,100 --> 00:10:20,100
80s and early 90s

242
00:10:20,100 --> 00:10:23,519
now Unix systems are time sharing

243
00:10:23,519 --> 00:10:25,680
systems in that they support multiple

244
00:10:25,680 --> 00:10:27,959
users at the same time but they're

245
00:10:27,959 --> 00:10:29,940
designed to be run on local Computer

246
00:10:29,940 --> 00:10:33,180
Resources instead of remote resources

247
00:10:33,180 --> 00:10:35,279
the Berkeley system distribution which

248
00:10:35,279 --> 00:10:36,839
is based on at T's commercial

249
00:10:36,839 --> 00:10:39,600
distribution was one of the first open

250
00:10:39,600 --> 00:10:41,940
source BS one of the first open source

251
00:10:41,940 --> 00:10:45,060
unit systems to emerge it was based on

252
00:10:45,060 --> 00:10:47,940
the commercial distribution so at T sued

253
00:10:47,940 --> 00:10:50,579
UC Berkeley but an eventual settlement

254
00:10:50,579 --> 00:10:52,620
allowed Berkeley to distribute BSD

255
00:10:52,620 --> 00:10:55,079
freely in both source and binary form

256
00:10:55,079 --> 00:10:57,660
today's descendants of BSD include

257
00:10:57,660 --> 00:11:01,320
FreeBSD openbsd and Mac OS 10 which is

258
00:11:01,320 --> 00:11:05,760
based on the Unix vsd system

259
00:11:05,760 --> 00:11:08,519
Linux however was an alternate approach

260
00:11:08,519 --> 00:11:10,860
to getting a Unix light kernel running

261
00:11:10,860 --> 00:11:13,320
on computer system this was started by

262
00:11:13,320 --> 00:11:15,300
Linus torvales as an undergrad at the

263
00:11:15,300 --> 00:11:17,579
University of Helsinki released in

264
00:11:17,579 --> 00:11:21,120
source code forum in 1991 and often

265
00:11:21,120 --> 00:11:22,680
combined with a set of user space

266
00:11:22,680 --> 00:11:24,779
utilities and libraries created by the

267
00:11:24,779 --> 00:11:27,000
gnu project thus the resulting

268
00:11:27,000 --> 00:11:29,399
combination is sometimes called the news

269
00:11:29,399 --> 00:11:30,839
Linux

270
00:11:30,839 --> 00:11:33,240
it has been commercially successful for

271
00:11:33,240 --> 00:11:35,519
many device classes including web

272
00:11:35,519 --> 00:11:38,339
servers Network and embedded devices and

273
00:11:38,339 --> 00:11:39,779
mobile phones

274
00:11:39,779 --> 00:11:42,360
some people including myself use Linux

275
00:11:42,360 --> 00:11:45,480
as a desktop platform and it does have

276
00:11:45,480 --> 00:11:48,000
benefit of having the one kernel that's

277
00:11:48,000 --> 00:11:50,519
scalable from embedded devices all the

278
00:11:50,519 --> 00:11:52,620
way up to supercomputers

279
00:11:52,620 --> 00:11:54,959
now it's convenient to think of a system

280
00:11:54,959 --> 00:12:00,300
computer system as a set of layers

281
00:12:00,300 --> 00:12:02,579
where the top layer we have a group of

282
00:12:02,579 --> 00:12:04,620
applications these are the programs that

283
00:12:04,620 --> 00:12:07,380
we run and with which we interact on a

284
00:12:07,380 --> 00:12:09,839
day-to-day basis to accomplish various

285
00:12:09,839 --> 00:12:11,399
tasks

286
00:12:11,399 --> 00:12:13,860
these applications are built on top of

287
00:12:13,860 --> 00:12:16,320
libraries and utilities some of which

288
00:12:16,320 --> 00:12:17,880
are included with the operating system

289
00:12:17,880 --> 00:12:19,320
and some of which are installed

290
00:12:19,320 --> 00:12:20,880
separately

291
00:12:20,880 --> 00:12:23,279
the operating system acts as an

292
00:12:23,279 --> 00:12:26,100
intermediary layer between the

293
00:12:26,100 --> 00:12:29,040
application layer and the utilities and

294
00:12:29,040 --> 00:12:31,560
the underlying Hardware the underlying

295
00:12:31,560 --> 00:12:33,540
Hardware consists of several important

296
00:12:33,540 --> 00:12:36,300
pieces I'll talk more in detail about

297
00:12:36,300 --> 00:12:37,980
these in a moment

298
00:12:37,980 --> 00:12:41,279
two primary pieces that come to mind are

299
00:12:41,279 --> 00:12:43,500
the central processing unit which

300
00:12:43,500 --> 00:12:44,839
actually executes the program

301
00:12:44,839 --> 00:12:48,600
instructions and the memory hierarchy

302
00:12:48,600 --> 00:12:51,079
which provides a place to store

303
00:12:51,079 --> 00:12:54,180
instructions and data for use in

304
00:12:54,180 --> 00:12:55,560
computation

305
00:12:55,560 --> 00:12:58,139
now the memory hierarchy is critical to

306
00:12:58,139 --> 00:13:01,260
understand because the speeds of each

307
00:13:01,260 --> 00:13:03,540
level of memory within the hierarchy

308
00:13:03,540 --> 00:13:05,339
vary

309
00:13:05,339 --> 00:13:08,279
the fastest memory consists of CPU

310
00:13:08,279 --> 00:13:11,639
registers and then the cache attached to

311
00:13:11,639 --> 00:13:13,380
the CPU itself

312
00:13:13,380 --> 00:13:16,079
whereas the slowest memory consists of

313
00:13:16,079 --> 00:13:19,019
persistent memory typically disk the

314
00:13:19,019 --> 00:13:21,180
hardware also includes a bunch of input

315
00:13:21,180 --> 00:13:23,880
output devices you have a keyboard mouse

316
00:13:23,880 --> 00:13:27,000
network interface card screen printer

317
00:13:27,000 --> 00:13:30,480
plenty of others webcam different types

318
00:13:30,480 --> 00:13:32,100
of devices

319
00:13:32,100 --> 00:13:33,720
one of the other things that the

320
00:13:33,720 --> 00:13:37,139
hardware does is supplies power to the

321
00:13:37,139 --> 00:13:40,260
system via power supply and removes heat

322
00:13:40,260 --> 00:13:42,660
generated by the system through cooling

323
00:13:42,660 --> 00:13:44,160
this is typically done through fans

324
00:13:44,160 --> 00:13:47,339
built into the computer's case now when

325
00:13:47,339 --> 00:13:49,079
we look at a computer system from the

326
00:13:49,079 --> 00:13:52,079
outside we see something called a form

327
00:13:52,079 --> 00:13:54,839
factor now form factor is simply a set

328
00:13:54,839 --> 00:13:57,420
of specifications for standard sizes of

329
00:13:57,420 --> 00:13:59,459
equipment to allow different computer

330
00:13:59,459 --> 00:14:01,500
components developed by different people

331
00:14:01,500 --> 00:14:04,320
be interchanged with one another in

332
00:14:04,320 --> 00:14:06,959
standard form factors include ATX which

333
00:14:06,959 --> 00:14:09,720
is a typical workstation size form

334
00:14:09,720 --> 00:14:13,800
factor Micro ATX and Mini ITX which are

335
00:14:13,800 --> 00:14:16,680
used in small form factor systems such

336
00:14:16,680 --> 00:14:18,839
as bookshelf systems and home theater

337
00:14:18,839 --> 00:14:21,839
PCS and rack mount systems which are

338
00:14:21,839 --> 00:14:24,060
typical servers in the data center

339
00:14:24,060 --> 00:14:27,139
now laptop systems are a special case

340
00:14:27,139 --> 00:14:29,820
these types of systems typically are

341
00:14:29,820 --> 00:14:32,519
proprietary in nature the extent it's

342
00:14:32,519 --> 00:14:34,680
not easy to take components out of one

343
00:14:34,680 --> 00:14:36,980
laptop and put it in another laptop

344
00:14:36,980 --> 00:14:39,480
workstation systems however do allow

345
00:14:39,480 --> 00:14:41,459
easy component interchange

346
00:14:41,459 --> 00:14:43,860
and these are the simplest of systems

347
00:14:43,860 --> 00:14:46,260
they typically support multiple users

348
00:14:46,260 --> 00:14:49,380
but normally only one user at a time

349
00:14:49,380 --> 00:14:51,300
when a workstation is shared between

350
00:14:51,300 --> 00:14:54,720
different users it often involves a user

351
00:14:54,720 --> 00:14:56,220
getting up from the keyboard and another

352
00:14:56,220 --> 00:14:58,199
user sitting down of course it's not

353
00:14:58,199 --> 00:15:00,660
always the case but generally that's the

354
00:15:00,660 --> 00:15:01,500
case

355
00:15:01,500 --> 00:15:04,079
workstation systems are also frequently

356
00:15:04,079 --> 00:15:08,100
either ATX or microatx form factors and

357
00:15:08,100 --> 00:15:10,019
each workstation typically has its own

358
00:15:10,019 --> 00:15:12,600
power supply which can be an issue of

359
00:15:12,600 --> 00:15:13,980
efficiency considering the power

360
00:15:13,980 --> 00:15:16,800
supplies are only about 65 to 85 percent

361
00:15:16,800 --> 00:15:19,560
efficient workstations can be used to

362
00:15:19,560 --> 00:15:21,360
host server applications this is

363
00:15:21,360 --> 00:15:23,100
particularly true in smaller settings

364
00:15:23,100 --> 00:15:26,100
such as small businesses non-profit

365
00:15:26,100 --> 00:15:27,300
organizations

366
00:15:27,300 --> 00:15:30,360
server applications in larger scale

367
00:15:30,360 --> 00:15:32,040
environments such as Enterprise

368
00:15:32,040 --> 00:15:34,440
environments are typically hosted in

369
00:15:34,440 --> 00:15:37,139
rack mount systems and racknon systems

370
00:15:37,139 --> 00:15:38,880
are simply a space efficient way to put

371
00:15:38,880 --> 00:15:40,800
a whole lot of servers into one data

372
00:15:40,800 --> 00:15:43,260
center rack mount systems are measured

373
00:15:43,260 --> 00:15:45,600
or rack sizes are measured in terms of

374
00:15:45,600 --> 00:15:49,740
units or u in a typical racks 42 Utah so

375
00:15:49,740 --> 00:15:52,199
the most space efficient of servers a

376
00:15:52,199 --> 00:15:55,139
one-use system with 12 cores in each

377
00:15:55,139 --> 00:15:59,820
machine could enable up to 480 cores 480

378
00:15:59,820 --> 00:16:02,220
CPU cores to be supported by a single

379
00:16:02,220 --> 00:16:04,500
rack however there won't be much room

380
00:16:04,500 --> 00:16:06,360
for expansion there won't be much room

381
00:16:06,360 --> 00:16:09,000
for extra devices or extra hard drives

382
00:16:09,000 --> 00:16:13,380
for that setup we use 2u and 4u systems

383
00:16:13,380 --> 00:16:15,839
which are less space efficient but do

384
00:16:15,839 --> 00:16:18,720
allow for more expansion more discs to

385
00:16:18,720 --> 00:16:21,540
be included and more add-in guards now

386
00:16:21,540 --> 00:16:23,639
if we take a computer system and we open

387
00:16:23,639 --> 00:16:26,279
up the case inside we're going to find a

388
00:16:26,279 --> 00:16:27,360
power supply

389
00:16:27,360 --> 00:16:29,220
we're going to find a motherboard or

390
00:16:29,220 --> 00:16:31,620
what Apple calls a logic board and

391
00:16:31,620 --> 00:16:33,060
attached to that motherboard we're going

392
00:16:33,060 --> 00:16:34,920
to find the CPU we're going to find

393
00:16:34,920 --> 00:16:37,380
Random Access Memory we're going to find

394
00:16:37,380 --> 00:16:40,139
expansion slots for add-in devices some

395
00:16:40,139 --> 00:16:42,300
of which may be populated and we're

396
00:16:42,300 --> 00:16:43,380
going to find that the motherboard

397
00:16:43,380 --> 00:16:45,839
contains its own on-board devices such

398
00:16:45,839 --> 00:16:47,759
as Network controllers or video

399
00:16:47,759 --> 00:16:50,759
controllers inside the case we're also

400
00:16:50,759 --> 00:16:52,740
going to find persistent storage devices

401
00:16:52,740 --> 00:16:55,560
such as hard disks solid state drives

402
00:16:55,560 --> 00:16:57,959
and Optical drives and here's a

403
00:16:57,959 --> 00:17:00,779
conceptual view of what the inside of

404
00:17:00,779 --> 00:17:02,519
the computer system looks like here we

405
00:17:02,519 --> 00:17:03,899
have the motherboard which has some

406
00:17:03,899 --> 00:17:06,540
expansion slots these are normally used

407
00:17:06,540 --> 00:17:09,900
for add-in cards to be plugged in to add

408
00:17:09,900 --> 00:17:12,000
functionality to the system onboard

409
00:17:12,000 --> 00:17:14,280
devices which are soldered onto the

410
00:17:14,280 --> 00:17:16,140
motherboard and are not removed one or

411
00:17:16,140 --> 00:17:18,480
more CPUs which are typically removable

412
00:17:18,480 --> 00:17:20,880
these are typically separate chips and

413
00:17:20,880 --> 00:17:23,520
each of these chips inside you can't see

414
00:17:23,520 --> 00:17:27,299
them but inside are typically multiple

415
00:17:27,299 --> 00:17:31,320
CPU cores and some kind of cache memory

416
00:17:31,320 --> 00:17:34,320
random access memory is another type of

417
00:17:34,320 --> 00:17:35,880
memory that's attached directly to the

418
00:17:35,880 --> 00:17:38,280
motherboard and it's typically in the

419
00:17:38,280 --> 00:17:40,740
form of removable modules connected to

420
00:17:40,740 --> 00:17:42,900
the motherboard via cables we find a

421
00:17:42,900 --> 00:17:46,260
hard disk optical drive perhaps a solid

422
00:17:46,260 --> 00:17:48,480
state drive the central processing unit

423
00:17:48,480 --> 00:17:50,280
is the part of the computer that

424
00:17:50,280 --> 00:17:52,919
actually executes instructions has one

425
00:17:52,919 --> 00:17:55,980
or more execution cores most modern CPUs

426
00:17:55,980 --> 00:17:58,980
have at least two cores CPU registers

427
00:17:58,980 --> 00:18:01,940
are used for direct computation direct

428
00:18:01,940 --> 00:18:04,500
operations that are occurring right now

429
00:18:04,500 --> 00:18:07,080
the cache is used to store program

430
00:18:07,080 --> 00:18:09,179
instructions and data that will be used

431
00:18:09,179 --> 00:18:11,700
immediately the next few instructions

432
00:18:11,700 --> 00:18:14,400
that are going to be executed this cache

433
00:18:14,400 --> 00:18:15,960
is divided into levels of different

434
00:18:15,960 --> 00:18:18,840
speeds it's also volatile it loses

435
00:18:18,840 --> 00:18:21,660
contents whenever power is disconnected

436
00:18:21,660 --> 00:18:24,720
and it's expensive this type of fast

437
00:18:24,720 --> 00:18:27,960
memory is quite expensive random access

438
00:18:27,960 --> 00:18:31,380
memory is separate from the CPU this is

439
00:18:31,380 --> 00:18:33,720
used to store programs and data

440
00:18:33,720 --> 00:18:36,000
while the program is in a state of

441
00:18:36,000 --> 00:18:37,799
execution

442
00:18:37,799 --> 00:18:40,100
this memory is order of magnitude

443
00:18:40,100 --> 00:18:43,080
several orders of magnitude faster than

444
00:18:43,080 --> 00:18:45,419
hard disks or even solid state drives

445
00:18:45,419 --> 00:18:47,880
which is why programs are loaded into

446
00:18:47,880 --> 00:18:49,799
random access memory by the loader

447
00:18:49,799 --> 00:18:52,799
before they start executing most

448
00:18:52,799 --> 00:18:55,200
programs also buffer their data in RAM

449
00:18:55,200 --> 00:18:56,940
for Speed

450
00:18:56,940 --> 00:18:59,039
however the memory and RAM is still

451
00:18:59,039 --> 00:19:01,020
volatile and it contents are lost

452
00:19:01,020 --> 00:19:03,960
whenever power is disconnected and it is

453
00:19:03,960 --> 00:19:05,880
more expensive per unit storage than

454
00:19:05,880 --> 00:19:07,980
disk space or even solid state drive

455
00:19:07,980 --> 00:19:11,280
space persistent storage is the slowest

456
00:19:11,280 --> 00:19:13,260
of all types of memory in the system

457
00:19:13,260 --> 00:19:16,799
this is non-volatile storage for data to

458
00:19:16,799 --> 00:19:19,020
be saved whenever the system is powered

459
00:19:19,020 --> 00:19:20,460
off

460
00:19:20,460 --> 00:19:22,679
now this is the least expensive type of

461
00:19:22,679 --> 00:19:25,080
storage per unit of capacity

462
00:19:25,080 --> 00:19:28,860
but it is slow it's not fast enough to

463
00:19:28,860 --> 00:19:31,260
execute programs directly largely

464
00:19:31,260 --> 00:19:33,539
because the CPU would constantly be

465
00:19:33,539 --> 00:19:36,059
waiting on the drive to give it the next

466
00:19:36,059 --> 00:19:38,400
instruction and that would slow down the

467
00:19:38,400 --> 00:19:41,039
CPU hard disk drives are what we

468
00:19:41,039 --> 00:19:43,020
typically think of when we think of slow

469
00:19:43,020 --> 00:19:45,660
persistent storage these are mechanical

470
00:19:45,660 --> 00:19:48,080
devices that use magnetic storage

471
00:19:48,080 --> 00:19:51,360
basically a magnetic medium on top of

472
00:19:51,360 --> 00:19:54,059
either a glass or metal disc called a

473
00:19:54,059 --> 00:19:55,200
platter

474
00:19:55,200 --> 00:19:58,320
and multiple platters that are stacked

475
00:19:58,320 --> 00:20:01,380
spin at high speed with the heads moving

476
00:20:01,380 --> 00:20:03,600
back and forth between tracks on the

477
00:20:03,600 --> 00:20:05,100
platters

478
00:20:05,100 --> 00:20:07,860
accessing data on a hard drive is thus

479
00:20:07,860 --> 00:20:10,559
subject to two types of delay

480
00:20:10,559 --> 00:20:12,960
seek time which is the time required to

481
00:20:12,960 --> 00:20:15,059
move the heads back and forth and

482
00:20:15,059 --> 00:20:16,799
rotational delay which is the time

483
00:20:16,799 --> 00:20:19,020
required for the platter to rotate

484
00:20:19,020 --> 00:20:21,480
around to the location the desired data

485
00:20:21,480 --> 00:20:22,799
is stored

486
00:20:22,799 --> 00:20:24,600
now hard drives are relatively

487
00:20:24,600 --> 00:20:26,700
inexpensive per unit of storage space

488
00:20:26,700 --> 00:20:29,100
but they are mechanical which means

489
00:20:29,100 --> 00:20:31,200
they're guaranteed to fail sooner or

490
00:20:31,200 --> 00:20:32,400
later

491
00:20:32,400 --> 00:20:35,760
here's a diagram of a hard disk and here

492
00:20:35,760 --> 00:20:37,380
we can see the platters which are

493
00:20:37,380 --> 00:20:39,660
stacked on top of each other and spun

494
00:20:39,660 --> 00:20:42,059
around by a motor motor spins us around

495
00:20:42,059 --> 00:20:43,980
at high speeds

496
00:20:43,980 --> 00:20:46,740
the head moves back and forth now

497
00:20:46,740 --> 00:20:49,200
there's typically one head first side of

498
00:20:49,200 --> 00:20:51,539
each bladder so the heads are actually

499
00:20:51,539 --> 00:20:52,919
stacked up

500
00:20:52,919 --> 00:20:55,320
and a Servo motor moves the heads back

501
00:20:55,320 --> 00:20:56,580
and forth

502
00:20:56,580 --> 00:20:59,580
the time it takes to move the head from

503
00:20:59,580 --> 00:21:03,000
the inside of the platter to the outside

504
00:21:03,000 --> 00:21:05,880
of the platter or from the outside back

505
00:21:05,880 --> 00:21:07,860
to the inside to get the appropriate

506
00:21:07,860 --> 00:21:09,720
track on the platter where data is

507
00:21:09,720 --> 00:21:12,480
located is called the seek time

508
00:21:12,480 --> 00:21:15,299
the time it takes for the spot where the

509
00:21:15,299 --> 00:21:18,120
data is located to rotate around under

510
00:21:18,120 --> 00:21:21,600
the head is called the rotational delay

511
00:21:21,600 --> 00:21:24,780
so if I have a piece of data right here

512
00:21:24,780 --> 00:21:26,940
about where the mouse pointer is

513
00:21:26,940 --> 00:21:31,220
my drive is rotating clockwise

514
00:21:31,320 --> 00:21:34,020
the head has to seek to the track where

515
00:21:34,020 --> 00:21:36,059
that data is going to be located

516
00:21:36,059 --> 00:21:39,120
and I have to wait for that data

517
00:21:39,120 --> 00:21:41,700
come all the way around

518
00:21:41,700 --> 00:21:44,520
and wind up under the head so that it

519
00:21:44,520 --> 00:21:45,840
can be red

520
00:21:45,840 --> 00:21:49,380
this adds to delay in accessing reading

521
00:21:49,380 --> 00:21:52,740
or writing data from the hard drive so

522
00:21:52,740 --> 00:21:54,600
in performance critical situations we'll

523
00:21:54,600 --> 00:21:57,659
typically use solid state drives these

524
00:21:57,659 --> 00:22:00,000
drives have no moving Parts they instead

525
00:22:00,000 --> 00:22:02,960
use solid state chips to store data

526
00:22:02,960 --> 00:22:05,520
consequently they have no seek time no

527
00:22:05,520 --> 00:22:08,100
rotational delay and faster burst

528
00:22:08,100 --> 00:22:09,240
transfers

529
00:22:09,240 --> 00:22:12,419
much higher performance than hard drives

530
00:22:12,419 --> 00:22:16,020
however this performance comes at a cost

531
00:22:16,020 --> 00:22:18,900
and solid state drives themselves will

532
00:22:18,900 --> 00:22:22,380
eventually fail each block of an SSD can

533
00:22:22,380 --> 00:22:24,000
only be written the finite number of

534
00:22:24,000 --> 00:22:26,039
times before it wears out

535
00:22:26,039 --> 00:22:28,860
the drive itself extends its own

536
00:22:28,860 --> 00:22:31,860
Lifetime by reallocating blocks

537
00:22:31,860 --> 00:22:33,179
dynamically

538
00:22:33,179 --> 00:22:37,140
so that each block is written in average

539
00:22:37,140 --> 00:22:39,360
number of times instead of a large

540
00:22:39,360 --> 00:22:41,700
number of times this process is called

541
00:22:41,700 --> 00:22:44,520
where lovely it extends the life the

542
00:22:44,520 --> 00:22:46,799
device significantly given that our

543
00:22:46,799 --> 00:22:48,539
persistent storage devices are

544
00:22:48,539 --> 00:22:51,059
guaranteed to fail in time it is

545
00:22:51,059 --> 00:22:52,980
critical system administrators keep

546
00:22:52,980 --> 00:22:55,740
backup copies of programs and data so

547
00:22:55,740 --> 00:22:57,659
that the system can be restored after a

548
00:22:57,659 --> 00:22:58,799
failure

549
00:22:58,799 --> 00:23:01,080
now the backup media should be stored

550
00:23:01,080 --> 00:23:02,400
separately from the computer center

551
00:23:02,400 --> 00:23:05,700
itself best practice is on-site at least

552
00:23:05,700 --> 00:23:08,400
10 miles away in a location that can be

553
00:23:08,400 --> 00:23:10,740
protected from damage as well as theft

554
00:23:10,740 --> 00:23:13,559
or loss of data backup media include

555
00:23:13,559 --> 00:23:15,900
Optical disks such as reportable CDs

556
00:23:15,900 --> 00:23:18,419
DVDs or Blu-ray

557
00:23:18,419 --> 00:23:20,820
these Optical discs are nice because

558
00:23:20,820 --> 00:23:22,740
they're inexpensive however they do

559
00:23:22,740 --> 00:23:25,559
degrade over time scientists are still

560
00:23:25,559 --> 00:23:27,480
working on the details of exactly how

561
00:23:27,480 --> 00:23:29,820
long but it is known that data will

562
00:23:29,820 --> 00:23:32,760
become unreadable eventually

563
00:23:32,760 --> 00:23:35,760
flash drives such as USB sticks are also

564
00:23:35,760 --> 00:23:37,260
inexpensive although a bit more

565
00:23:37,260 --> 00:23:40,140
expensive than DVD media

566
00:23:40,140 --> 00:23:43,080
they're slow sometimes slower than DVD

567
00:23:43,080 --> 00:23:45,960
media and they themselves will lose data

568
00:23:45,960 --> 00:23:47,820
eventually due to electrical properties

569
00:23:47,820 --> 00:23:51,299
inside the flash memory tape drives are

570
00:23:51,299 --> 00:23:53,340
considered best Enterprise level

571
00:23:53,340 --> 00:23:55,559
solution which of course means they have

572
00:23:55,559 --> 00:23:58,320
the highest costs but they have the best

573
00:23:58,320 --> 00:24:00,419
reliability on average despite being

574
00:24:00,419 --> 00:24:02,940
somewhat slow to access for reading and

575
00:24:02,940 --> 00:24:06,179
writing cloud storage is another option

576
00:24:06,179 --> 00:24:09,900
for many users and in this model

577
00:24:09,900 --> 00:24:12,360
backups are simply uploaded to a remote

578
00:24:12,360 --> 00:24:14,280
server that someone else maintains

579
00:24:14,280 --> 00:24:17,280
typically a backup service provider

580
00:24:17,280 --> 00:24:19,860
cloud storage is relatively low cost and

581
00:24:19,860 --> 00:24:22,860
convenient however its speed does depend

582
00:24:22,860 --> 00:24:25,200
upon the internet connection that you're

583
00:24:25,200 --> 00:24:27,539
using to send data to or retrieve data

584
00:24:27,539 --> 00:24:30,000
from the backup service and theft of

585
00:24:30,000 --> 00:24:32,159
data can be a concern the operating

586
00:24:32,159 --> 00:24:35,460
system implements a common mechanism for

587
00:24:35,460 --> 00:24:37,440
allowing applications to access and

588
00:24:37,440 --> 00:24:39,720
share Hardware the applications can make

589
00:24:39,720 --> 00:24:41,700
requests from the operating system via

590
00:24:41,700 --> 00:24:44,039
system calls the operating system can

591
00:24:44,039 --> 00:24:45,900
deliver Hardware events to applications

592
00:24:45,900 --> 00:24:48,659
and this is how we allow our

593
00:24:48,659 --> 00:24:51,480
applications to make use of the

594
00:24:51,480 --> 00:24:53,580
underlying Hardware of the computer

595
00:24:53,580 --> 00:24:55,980
system I'll be discussing disk input

596
00:24:55,980 --> 00:24:57,360
output

597
00:24:57,360 --> 00:24:59,100
And discussing many of the physical

598
00:24:59,100 --> 00:25:02,159
properties that come into play when

599
00:25:02,159 --> 00:25:04,380
attempting to schedule a hard disk drive

600
00:25:04,380 --> 00:25:07,080
for Access by multiple programs in

601
00:25:07,080 --> 00:25:08,520
particular I'll talk about disk

602
00:25:08,520 --> 00:25:09,419
attachment

603
00:25:09,419 --> 00:25:11,039
talk about some of the properties of

604
00:25:11,039 --> 00:25:14,700
magnetic disks discuss disk addressing

605
00:25:14,700 --> 00:25:17,220
discuss partitioning and introduce

606
00:25:17,220 --> 00:25:19,919
solid-state drives but begin with disk

607
00:25:19,919 --> 00:25:21,360
attachment

608
00:25:21,360 --> 00:25:23,760
disks are attached to the motherboard

609
00:25:23,760 --> 00:25:26,580
via some kind of cable and the exact

610
00:25:26,580 --> 00:25:29,159
type of cable depends upon the bus in

611
00:25:29,159 --> 00:25:31,380
use on the system

612
00:25:31,380 --> 00:25:33,779
there are several different types of bus

613
00:25:33,779 --> 00:25:36,360
which are implemented by different chips

614
00:25:36,360 --> 00:25:38,460
attached to the motherboard on the

615
00:25:38,460 --> 00:25:40,500
different computer systems one common

616
00:25:40,500 --> 00:25:42,720
bus that was widely in use until the

617
00:25:42,720 --> 00:25:45,299
early 2000s on consumer grade Hardware

618
00:25:45,299 --> 00:25:47,880
was the integrated Drive Electronics or

619
00:25:47,880 --> 00:25:51,679
IDE bus this has been since acronymed

620
00:25:51,679 --> 00:25:54,659
parallel ATA or Pata

621
00:25:54,659 --> 00:25:57,539
it consisted of 40 to 80 ribbon cable

622
00:25:57,539 --> 00:26:00,659
connecting to a 40-pin connector to

623
00:26:00,659 --> 00:26:02,940
provide 40 simultaneous parallel

624
00:26:02,940 --> 00:26:05,340
channels of communication between the

625
00:26:05,340 --> 00:26:06,360
motherboard and the hard drive

626
00:26:06,360 --> 00:26:09,179
Enterprise level systems of that time

627
00:26:09,179 --> 00:26:11,760
period typically used scuzzy or small

628
00:26:11,760 --> 00:26:15,000
computer system interface buses which

629
00:26:15,000 --> 00:26:18,179
consisted of the cabling of 50 to 80 pin

630
00:26:18,179 --> 00:26:20,760
connectors between the hard disk and the

631
00:26:20,760 --> 00:26:23,159
motherboard scuzzy also defined a

632
00:26:23,159 --> 00:26:25,559
standard set of commands a standard

633
00:26:25,559 --> 00:26:28,860
protocol for interfacing with disks CDs

634
00:26:28,860 --> 00:26:31,440
and other types of storage devices this

635
00:26:31,440 --> 00:26:33,900
protocol was useful for recordable CD

636
00:26:33,900 --> 00:26:36,299
media and dvd-rom media

637
00:26:36,299 --> 00:26:40,500
and was implemented on the ATA bus using

638
00:26:40,500 --> 00:26:42,360
the scuzzy protocol

639
00:26:42,360 --> 00:26:45,539
in a system known as a tapi or ATA

640
00:26:45,539 --> 00:26:48,620
packet interface now in minor times

641
00:26:48,620 --> 00:26:50,880
serial interfaces between the

642
00:26:50,880 --> 00:26:52,740
motherboard and the disk have replaced

643
00:26:52,740 --> 00:26:54,659
for the most part the parallel

644
00:26:54,659 --> 00:26:55,980
interfaces

645
00:26:55,980 --> 00:26:59,100
for ath style disks we have Serial ATA

646
00:26:59,100 --> 00:27:01,860
or SATA which replaces the 40-pin

647
00:27:01,860 --> 00:27:04,200
connector with a seven pin connector

648
00:27:04,200 --> 00:27:06,600
still uses the same protocol either ATA

649
00:27:06,600 --> 00:27:08,419
or a chappy protocol

650
00:27:08,419 --> 00:27:12,539
and serial attached scuzzy or SAS which

651
00:27:12,539 --> 00:27:15,059
uses the scuzzy protocol over a narrower

652
00:27:15,059 --> 00:27:18,659
Channel consisting of 26 to 32 pins

653
00:27:18,659 --> 00:27:20,880
both of these new serial attachment

654
00:27:20,880 --> 00:27:24,360
mechanisms support higher bus transfer

655
00:27:24,360 --> 00:27:27,299
speeds enabling theoretically faster

656
00:27:27,299 --> 00:27:28,860
devices to be attached to the

657
00:27:28,860 --> 00:27:31,080
motherboard it does not necessarily mean

658
00:27:31,080 --> 00:27:33,000
however the disks have gotten that much

659
00:27:33,000 --> 00:27:36,059
faster we still store large amounts of

660
00:27:36,059 --> 00:27:39,240
information using magnetic disks these

661
00:27:39,240 --> 00:27:41,159
are metallic or glass platters that are

662
00:27:41,159 --> 00:27:43,200
coated in a magnetic surface

663
00:27:43,200 --> 00:27:45,720
and a stack of these platters is rotated

664
00:27:45,720 --> 00:27:49,080
at high speed by an electric motor a

665
00:27:49,080 --> 00:27:50,640
stack of heads moves back and forth

666
00:27:50,640 --> 00:27:52,919
across the platters altering the

667
00:27:52,919 --> 00:27:54,720
magnetic fields in order to read and

668
00:27:54,720 --> 00:27:56,220
write data

669
00:27:56,220 --> 00:27:58,500
moving the heads back and forth results

670
00:27:58,500 --> 00:28:01,080
in seek time and waiting for the platter

671
00:28:01,080 --> 00:28:02,520
to rotate around to the correct position

672
00:28:02,520 --> 00:28:05,400
results in rotational delay historically

673
00:28:05,400 --> 00:28:07,679
magnetic media were addressed by

674
00:28:07,679 --> 00:28:10,440
geometry the smallest addressable unit

675
00:28:10,440 --> 00:28:13,140
of space on a hard disk is called a

676
00:28:13,140 --> 00:28:16,380
sector this is typically 512 bytes at

677
00:28:16,380 --> 00:28:19,080
least on older disks though other sizes

678
00:28:19,080 --> 00:28:21,480
have been used and newer drives go up to

679
00:28:21,480 --> 00:28:23,779
four kilobytes

680
00:28:23,779 --> 00:28:27,539
tracks are circular paths in a constant

681
00:28:27,539 --> 00:28:30,059
radius from the center of the disc and

682
00:28:30,059 --> 00:28:32,820
each track is divided into sectors one

683
00:28:32,820 --> 00:28:35,640
head reads from a single track on a

684
00:28:35,640 --> 00:28:37,500
single side of each platter when you

685
00:28:37,500 --> 00:28:40,260
stack multiple heads up while using

686
00:28:40,260 --> 00:28:42,539
multiple tracks on the various sides of

687
00:28:42,539 --> 00:28:45,059
several different platters the result is

688
00:28:45,059 --> 00:28:46,559
what's called a cylinder and

689
00:28:46,559 --> 00:28:49,380
historically accessing disks required

690
00:28:49,380 --> 00:28:53,100
accessing the particular data locations

691
00:28:53,100 --> 00:28:56,340
using cylinder head sector or CHS

692
00:28:56,340 --> 00:28:59,700
geometry address as disks grew larger

693
00:28:59,700 --> 00:29:01,620
and faster however this type of

694
00:29:01,620 --> 00:29:04,140
addressing scheme became Limited

695
00:29:04,140 --> 00:29:07,020
and so logical block addressing was put

696
00:29:07,020 --> 00:29:09,659
into use and it's now the standard today

697
00:29:09,659 --> 00:29:12,299
logical block addressing or LBA gives

698
00:29:12,299 --> 00:29:14,340
each block on a disk its own logical

699
00:29:14,340 --> 00:29:16,620
address and leaves it up to the disk

700
00:29:16,620 --> 00:29:18,600
firmware to convert The Logical

701
00:29:18,600 --> 00:29:21,480
addresses into physical locations on the

702
00:29:21,480 --> 00:29:23,159
disk

703
00:29:23,159 --> 00:29:25,380
current standards with logical block

704
00:29:25,380 --> 00:29:27,899
addressing on ATA will allow enough

705
00:29:27,899 --> 00:29:32,039
space for disks up to 128 heavy bytes

706
00:29:32,039 --> 00:29:34,380
operating systems normally Implement

707
00:29:34,380 --> 00:29:38,700
these 48-bit addresses using 64-bit data

708
00:29:38,700 --> 00:29:39,919
structures

709
00:29:39,919 --> 00:29:42,659
thus operating systems that support

710
00:29:42,659 --> 00:29:45,240
64-bit disk addressing can generally

711
00:29:45,240 --> 00:29:47,399
support hard disks up to eight zebi

712
00:29:47,399 --> 00:29:50,940
bytes of data assuming we're using 512

713
00:29:50,940 --> 00:29:53,340
byte sector sizes now regardless of the

714
00:29:53,340 --> 00:29:55,500
size of the disk it is convenient to

715
00:29:55,500 --> 00:29:57,559
partition the disk into multiple

716
00:29:57,559 --> 00:30:00,720
sections so that we can isolate data

717
00:30:00,720 --> 00:30:04,140
from each other we can isolate the main

718
00:30:04,140 --> 00:30:06,539
partition of the operating system from a

719
00:30:06,539 --> 00:30:08,220
partition we would use for swapping out

720
00:30:08,220 --> 00:30:10,559
pages of virtual memory for example and

721
00:30:10,559 --> 00:30:13,380
we can isolate that from user data

722
00:30:13,380 --> 00:30:16,320
also with early hard drives it was

723
00:30:16,320 --> 00:30:19,620
convenient to isolate partitions so as

724
00:30:19,620 --> 00:30:21,960
to minimize seat Time by making it such

725
00:30:21,960 --> 00:30:23,880
that the head didn't have to move as far

726
00:30:23,880 --> 00:30:26,520
in order to access data now there are

727
00:30:26,520 --> 00:30:29,279
two types of partition tables or data

728
00:30:29,279 --> 00:30:31,740
structure that resides on the disk to

729
00:30:31,740 --> 00:30:33,840
indicate where on the disk the different

730
00:30:33,840 --> 00:30:36,840
partitions lie a common partition table

731
00:30:36,840 --> 00:30:39,299
type that's in widespread use today is

732
00:30:39,299 --> 00:30:41,340
is the master boot record-based

733
00:30:41,340 --> 00:30:43,320
partitioning scheme

734
00:30:43,320 --> 00:30:46,679
and the way this works is that the BIOS

735
00:30:46,679 --> 00:30:48,659
on the system the basic input output

736
00:30:48,659 --> 00:30:52,380
system actually loads the first 512 byte

737
00:30:52,380 --> 00:30:56,220
sector from the boot drive at boot time

738
00:30:56,220 --> 00:31:00,000
and code stored in that 512 byte sector

739
00:31:00,000 --> 00:31:02,340
loads the rest of the system

740
00:31:02,340 --> 00:31:04,799
also within that sector is stored the

741
00:31:04,799 --> 00:31:07,200
partition table which is called a Dos

742
00:31:07,200 --> 00:31:09,179
style partition table

743
00:31:09,179 --> 00:31:11,940
in the Dos partition table still uses

744
00:31:11,940 --> 00:31:14,520
Legacy cylinder head sector addressing

745
00:31:14,520 --> 00:31:16,980
supports a maximum of four primary

746
00:31:16,980 --> 00:31:19,260
partitions one of which can be an

747
00:31:19,260 --> 00:31:21,480
extended partition with logical drives

748
00:31:21,480 --> 00:31:22,380
in it

749
00:31:22,380 --> 00:31:25,620
and supports maximum partition sizes and

750
00:31:25,620 --> 00:31:27,899
maximum partition starting addresses at

751
00:31:27,899 --> 00:31:29,880
two tebi bytes

752
00:31:29,880 --> 00:31:32,159
this is the default partitioning scheme

753
00:31:32,159 --> 00:31:34,559
for Microsoft Windows and most Linux

754
00:31:34,559 --> 00:31:37,200
distributions however as hard drives

755
00:31:37,200 --> 00:31:39,120
become larger and grow past two

756
00:31:39,120 --> 00:31:41,940
terabytes the good partition table or

757
00:31:41,940 --> 00:31:44,399
GPT starts to be used

758
00:31:44,399 --> 00:31:46,559
this is a larger partition table that

759
00:31:46,559 --> 00:31:48,779
can support distance or partitions up to

760
00:31:48,779 --> 00:31:50,940
eight zebi bytes in size

761
00:31:50,940 --> 00:31:53,880
for compatibility with old partitioning

762
00:31:53,880 --> 00:31:56,700
tools to prevent old tools from

763
00:31:56,700 --> 00:31:58,620
overwriting sections of the disk and

764
00:31:58,620 --> 00:32:01,380
seeing in his free space a protective or

765
00:32:01,380 --> 00:32:04,080
dummy Master boot record is retained at

766
00:32:04,080 --> 00:32:06,059
the beginning of the disk

767
00:32:06,059 --> 00:32:08,520
GPT is the default partitioning scheme

768
00:32:08,520 --> 00:32:11,640
in Mac OS 10 is an optional partitioning

769
00:32:11,640 --> 00:32:13,640
scheme in Linux

770
00:32:13,640 --> 00:32:17,399
and is supported in 64-bit versions of

771
00:32:17,399 --> 00:32:20,039
Windows 7 Windows Vista and Windows

772
00:32:20,039 --> 00:32:23,220
Server 2008 provided that the system

773
00:32:23,220 --> 00:32:26,640
uses the extensible firmware interface

774
00:32:26,640 --> 00:32:29,640
or EFI instead of the Legacy BIOS

775
00:32:29,640 --> 00:32:31,080
interface

776
00:32:31,080 --> 00:32:33,899
for Linux the grub2 bootloader can use a

777
00:32:33,899 --> 00:32:37,140
Legacy BIOS interface but it requires a

778
00:32:37,140 --> 00:32:39,840
dedicated small partition on the hard

779
00:32:39,840 --> 00:32:41,940
drive in which to store the rest of the

780
00:32:41,940 --> 00:32:44,039
bootloader hard drives and magnetic

781
00:32:44,039 --> 00:32:46,380
media are used for large quantities of

782
00:32:46,380 --> 00:32:50,159
space because of their relative low cost

783
00:32:50,159 --> 00:32:52,860
when high performance is required we

784
00:32:52,860 --> 00:32:56,340
prefer to use solid state drives or ssds

785
00:32:56,340 --> 00:32:58,799
these drives have no moving Parts which

786
00:32:58,799 --> 00:33:00,960
makes them generally faster and less

787
00:33:00,960 --> 00:33:02,520
subject to physical damage than

788
00:33:02,520 --> 00:33:04,559
mechanical hard disks

789
00:33:04,559 --> 00:33:07,620
most of these ssds use nand flash memory

790
00:33:07,620 --> 00:33:09,059
to store data

791
00:33:09,059 --> 00:33:11,399
and this is a storage mechanism that's

792
00:33:11,399 --> 00:33:13,559
based on injecting or removing an

793
00:33:13,559 --> 00:33:15,779
electron from a flash cell

794
00:33:15,779 --> 00:33:18,539
injecting an electron into a flash cell

795
00:33:18,539 --> 00:33:21,659
changes its state from one to zero so

796
00:33:21,659 --> 00:33:23,460
this is backwards from what one would

797
00:33:23,460 --> 00:33:25,919
expect an empty flash cell actually has

798
00:33:25,919 --> 00:33:28,620
a state of one instead of zero

799
00:33:28,620 --> 00:33:31,440
the membranes through which this eject

800
00:33:31,440 --> 00:33:35,220
this electron is injected and removed

801
00:33:35,220 --> 00:33:37,740
eventually wear out typically after

802
00:33:37,740 --> 00:33:39,419
anywhere from a hundred thousand to a

803
00:33:39,419 --> 00:33:41,360
million Cycles

804
00:33:41,360 --> 00:33:44,340
furthermore the electrons tend to leak

805
00:33:44,340 --> 00:33:46,679
out over long time periods periods of

806
00:33:46,679 --> 00:33:49,860
many years causing flash to lose data

807
00:33:49,860 --> 00:33:52,200
which makes flash based memory systems

808
00:33:52,200 --> 00:33:54,779
unsuitable for long-term backups in this

809
00:33:54,779 --> 00:33:57,419
diagram we can see how a flash or how a

810
00:33:57,419 --> 00:33:59,820
solid state drive using flash memory

811
00:33:59,820 --> 00:34:01,200
works

812
00:34:01,200 --> 00:34:04,080
blank flash memory stores the value one

813
00:34:04,080 --> 00:34:07,919
one one one one one one one one so we

814
00:34:07,919 --> 00:34:10,199
have all ones here

815
00:34:10,199 --> 00:34:12,839
if I want to write the value one zero

816
00:34:12,839 --> 00:34:16,379
zero one zero one zero zero

817
00:34:16,379 --> 00:34:20,339
I have to pop electrons into the second

818
00:34:20,339 --> 00:34:25,020
third fifth seventh and eighth flash

819
00:34:25,020 --> 00:34:28,320
locations the eight those bit locations

820
00:34:28,320 --> 00:34:30,359
I'm I'm pretending we only have a byte

821
00:34:30,359 --> 00:34:33,899
here if later I wish to change that

822
00:34:33,899 --> 00:34:37,500
stored value to one zero one zero zero

823
00:34:37,500 --> 00:34:41,159
zero one one I must first erase that

824
00:34:41,159 --> 00:34:43,800
block of flash memory before I can

825
00:34:43,800 --> 00:34:46,800
program the new data value generally I

826
00:34:46,800 --> 00:34:49,260
must erase flash memory in the size of

827
00:34:49,260 --> 00:34:51,239
an erased block and this is typically

828
00:34:51,239 --> 00:34:53,879
four kilobytes waiting for this block

829
00:34:53,879 --> 00:34:55,619
Erasure procedure causes something

830
00:34:55,619 --> 00:34:57,599
called right amplification where

831
00:34:57,599 --> 00:34:59,940
successive writes to an SSD become

832
00:34:59,940 --> 00:35:02,220
progressively slower to avoid this

833
00:35:02,220 --> 00:35:05,220
problem typically erase the SSD ahead of

834
00:35:05,220 --> 00:35:07,619
time whenever space has been freed on it

835
00:35:07,619 --> 00:35:09,780
and there's an ATA command called trim

836
00:35:09,780 --> 00:35:13,140
that facilitates this process one other

837
00:35:13,140 --> 00:35:15,060
issue that has to be dealt with with

838
00:35:15,060 --> 00:35:18,119
ssds is the fact that each cell can only

839
00:35:18,119 --> 00:35:21,960
be written to and read from or generally

840
00:35:21,960 --> 00:35:25,380
written to erased and written to a fixed

841
00:35:25,380 --> 00:35:27,180
number of times this is typically

842
00:35:27,180 --> 00:35:29,099
between a hundred thousand and a million

843
00:35:29,099 --> 00:35:32,099
so to spread out the rights across the

844
00:35:32,099 --> 00:35:35,700
entire SSD the SSD moves data around the

845
00:35:35,700 --> 00:35:38,160
drive as files are updated and it also

846
00:35:38,160 --> 00:35:40,880
reserves a certain amount of free space

847
00:35:40,880 --> 00:35:43,859
unused so that that free space can be

848
00:35:43,859 --> 00:35:45,960
swapped in and out with space that's in

849
00:35:45,960 --> 00:35:48,300
use later this process called wear

850
00:35:48,300 --> 00:35:50,040
leveling has the advantage of

851
00:35:50,040 --> 00:35:51,900
dramatically increasing the useful life

852
00:35:51,900 --> 00:35:54,540
of the SSD and reducing write

853
00:35:54,540 --> 00:35:56,640
amplification whenever clean blocks are

854
00:35:56,640 --> 00:35:58,920
made available however in order for the

855
00:35:58,920 --> 00:36:00,599
right amplification reduction to be

856
00:36:00,599 --> 00:36:03,180
effective the operating system and the

857
00:36:03,180 --> 00:36:05,579
underlying file system must support the

858
00:36:05,579 --> 00:36:07,980
ATA trim command and furthermore it's

859
00:36:07,980 --> 00:36:10,200
impossible to ensure that the disk is

860
00:36:10,200 --> 00:36:12,180
secure against forensic data recovery

861
00:36:12,180 --> 00:36:14,220
because it may not be possible to

862
00:36:14,220 --> 00:36:17,040
overwrite and properly erase the

863
00:36:17,040 --> 00:36:20,040
reserved cells of memory that have been

864
00:36:20,040 --> 00:36:22,560
taken out of service thus a used

865
00:36:22,560 --> 00:36:24,359
solid-state drive should be physically

866
00:36:24,359 --> 00:36:26,520
destroyed instead of attempting to

867
00:36:26,520 --> 00:36:28,560
resell it which can be an issue because

868
00:36:28,560 --> 00:36:31,440
a solid-state drive has a higher upfront

869
00:36:31,440 --> 00:36:34,020
cost so in summary disks are attached to

870
00:36:34,020 --> 00:36:36,180
the system via some kind of bus the

871
00:36:36,180 --> 00:36:38,820
newer bus styles are SATA and SAS these

872
00:36:38,820 --> 00:36:40,619
modern discs are addressed using logical

873
00:36:40,619 --> 00:36:42,420
block addressing they're partitioned

874
00:36:42,420 --> 00:36:45,000
either with DOs partition tables or good

875
00:36:45,000 --> 00:36:47,760
partition tables GPT use will increase

876
00:36:47,760 --> 00:36:50,339
as the size of disks becomes larger

877
00:36:50,339 --> 00:36:52,260
owing to the limits of the Dos partition

878
00:36:52,260 --> 00:36:54,599
table and solid-state drives offer

879
00:36:54,599 --> 00:36:56,700
higher performance at a higher initial

880
00:36:56,700 --> 00:36:59,280
cost subject to the requirement of wear

881
00:36:59,280 --> 00:37:03,119
leveling and subject to not being able

882
00:37:03,119 --> 00:37:06,060
to be safely resold due to the inability

883
00:37:06,060 --> 00:37:09,359
to forensically secure the data on the

884
00:37:09,359 --> 00:37:11,460
drive in this lecture I'll be discussing

885
00:37:11,460 --> 00:37:14,220
disk scheduling I'll be introducing the

886
00:37:14,220 --> 00:37:16,260
purpose of disk scheduling talking about

887
00:37:16,260 --> 00:37:18,480
some classical and historical disk

888
00:37:18,480 --> 00:37:20,280
scheduling algorithms talking about

889
00:37:20,280 --> 00:37:22,920
Native command queuing and disk

890
00:37:22,920 --> 00:37:24,540
schedulers that are currently in use in

891
00:37:24,540 --> 00:37:26,460
the Linux kernel and then I'll talk a

892
00:37:26,460 --> 00:37:28,500
little bit about how I O requests can be

893
00:37:28,500 --> 00:37:30,540
efficiently scheduled on solid state

894
00:37:30,540 --> 00:37:33,119
drives scheduling serves two purposes

895
00:37:33,119 --> 00:37:35,579
disk scheduling serves two purposes the

896
00:37:35,579 --> 00:37:37,619
first of these is to arbitrate disk

897
00:37:37,619 --> 00:37:40,619
access among different programs

898
00:37:40,619 --> 00:37:43,320
this ensures that competing programs

899
00:37:43,320 --> 00:37:46,440
have access to disk resources and that a

900
00:37:46,440 --> 00:37:48,599
single program cannot monopolize the

901
00:37:48,599 --> 00:37:50,940
disk resources in such a way as to

902
00:37:50,940 --> 00:37:52,619
prevent other programs from accessing

903
00:37:52,619 --> 00:37:54,720
the disk with mechanical hard drives

904
00:37:54,720 --> 00:37:56,940
scheduling algorithms historically have

905
00:37:56,940 --> 00:37:58,560
also attempted to improve disk

906
00:37:58,560 --> 00:38:00,900
performance by reducing the number of

907
00:38:00,900 --> 00:38:03,300
seeks required moving reducing the

908
00:38:03,300 --> 00:38:05,099
number of times the drive head needs to

909
00:38:05,099 --> 00:38:06,960
be moved if the drive head has to be

910
00:38:06,960 --> 00:38:10,440
moved too many times a lot of throughput

911
00:38:10,440 --> 00:38:12,839
can be lost from the disk because we're

912
00:38:12,839 --> 00:38:15,660
waiting on all the seek times to occur

913
00:38:15,660 --> 00:38:18,599
the simplest scheduling algorithm would

914
00:38:18,599 --> 00:38:20,760
be the first come first serve algorithm

915
00:38:20,760 --> 00:38:23,520
which is implemented in Linux as a no op

916
00:38:23,520 --> 00:38:25,680
scheduler this algorithm is extremely

917
00:38:25,680 --> 00:38:27,900
straightforward it simply consists of a

918
00:38:27,900 --> 00:38:30,599
fifo cube into which new requests are

919
00:38:30,599 --> 00:38:32,700
added the requests are removed from the

920
00:38:32,700 --> 00:38:35,400
queue in order one by one these requests

921
00:38:35,400 --> 00:38:37,680
are sent to the disk for processing now

922
00:38:37,680 --> 00:38:39,960
there's no reordering of the queue this

923
00:38:39,960 --> 00:38:42,540
is a first come first serve ordering so

924
00:38:42,540 --> 00:38:44,520
back-to-back requests for different

925
00:38:44,520 --> 00:38:47,400
parts of the disk may cause the drive

926
00:38:47,400 --> 00:38:50,099
head to move back and forth across the

927
00:38:50,099 --> 00:38:52,859
platters wasting quite a bit of time the

928
00:38:52,859 --> 00:38:55,079
seeks historically several attempts have

929
00:38:55,079 --> 00:38:56,940
been made to try to improve this

930
00:38:56,940 --> 00:39:00,240
Behavior one example would be the scan

931
00:39:00,240 --> 00:39:02,700
algorithm or the elevator algorithm and

932
00:39:02,700 --> 00:39:05,220
in this algorithm the drive head only

933
00:39:05,220 --> 00:39:07,740
Moves In One Direction it serves all the

934
00:39:07,740 --> 00:39:10,320
requests in that direction before moving

935
00:39:10,320 --> 00:39:12,180
back in the other direction this is

936
00:39:12,180 --> 00:39:13,920
called the elevator algorithm because

937
00:39:13,920 --> 00:39:17,339
it's modeled after how an elevator Works

938
00:39:17,339 --> 00:39:19,380
in a building the elevator leaves the

939
00:39:19,380 --> 00:39:23,099
ground floor moves to the highest floor

940
00:39:23,099 --> 00:39:27,000
stopping along the way to add passengers

941
00:39:27,000 --> 00:39:29,760
traveling up remove passengers at

942
00:39:29,760 --> 00:39:32,099
whichever floor they wish to stop on and

943
00:39:32,099 --> 00:39:34,079
then once the algorithm reaches or once

944
00:39:34,079 --> 00:39:35,780
the elevator reaches the highest floor

945
00:39:35,780 --> 00:39:38,700
turns around and comes back down same

946
00:39:38,700 --> 00:39:41,160
process here in this example with the

947
00:39:41,160 --> 00:39:43,980
scan algorithm assuming that the head

948
00:39:43,980 --> 00:39:46,859
starts at sector one and this request

949
00:39:46,859 --> 00:39:50,040
for sector 50 comes in while sector 61

950
00:39:50,040 --> 00:39:53,160
is being processed the algorithm is

951
00:39:53,160 --> 00:39:56,820
going to process the requests in order

952
00:39:56,820 --> 00:40:03,960
3 12 32 40 42 61 84 97 and since that

953
00:40:03,960 --> 00:40:07,680
request for sector 50 came in while 61

954
00:40:07,680 --> 00:40:10,380
was being processed that request for

955
00:40:10,380 --> 00:40:12,839
sector 50 is going to have to wait until

956
00:40:12,839 --> 00:40:15,119
the head changes Direction and returns

957
00:40:15,119 --> 00:40:16,980
to sector 50. now there are a few

958
00:40:16,980 --> 00:40:19,020
optimizations of the simple scan

959
00:40:19,020 --> 00:40:20,640
algorithm the original algorithm

960
00:40:20,640 --> 00:40:22,920
proposed that the head would move all

961
00:40:22,920 --> 00:40:24,300
the way from the beginning of the disc

962
00:40:24,300 --> 00:40:26,280
to the end of the disk and then all the

963
00:40:26,280 --> 00:40:27,839
way back to the beginning the look

964
00:40:27,839 --> 00:40:30,240
algorithm improves upon this Behavior by

965
00:40:30,240 --> 00:40:32,820
moving the head only as far as the

966
00:40:32,820 --> 00:40:34,560
highest number of requests before

967
00:40:34,560 --> 00:40:36,599
changing directions and moving it back

968
00:40:36,599 --> 00:40:38,400
down the circular versions of the

969
00:40:38,400 --> 00:40:41,579
algorithm see scan and C look only serve

970
00:40:41,579 --> 00:40:44,160
requests moving in One Direction so for

971
00:40:44,160 --> 00:40:46,440
example with circular scan the head

972
00:40:46,440 --> 00:40:48,900
would start at the first sector move all

973
00:40:48,900 --> 00:40:51,420
the way to the end of the disk servicing

974
00:40:51,420 --> 00:40:53,700
requests and then come all the way back

975
00:40:53,700 --> 00:40:55,140
down to the first sector without

976
00:40:55,140 --> 00:40:57,540
servicing any requests and start the

977
00:40:57,540 --> 00:40:59,700
process over again these are historical

978
00:40:59,700 --> 00:41:01,800
algorithms in the sense that with modern

979
00:41:01,800 --> 00:41:04,140
drives we have LBA or logical block

980
00:41:04,140 --> 00:41:07,619
addressing and so we don't actually know

981
00:41:07,619 --> 00:41:09,599
where the disk is placing data

982
00:41:09,599 --> 00:41:12,300
physically this type of algorithm was

983
00:41:12,300 --> 00:41:14,880
used historically with cylinder head

984
00:41:14,880 --> 00:41:17,460
sector addressing where we knew the

985
00:41:17,460 --> 00:41:19,680
physical properties of the disk and the

986
00:41:19,680 --> 00:41:21,599
idea here was to reduce average seek

987
00:41:21,599 --> 00:41:22,380
time

988
00:41:22,380 --> 00:41:24,839
at no time did we know where the platter

989
00:41:24,839 --> 00:41:26,880
was that was up to the disk to figure

990
00:41:26,880 --> 00:41:29,040
out so there was no way to reduce

991
00:41:29,040 --> 00:41:31,859
rotational delay only minimize seektow

992
00:41:31,859 --> 00:41:33,300
another algorithm and attempts to

993
00:41:33,300 --> 00:41:35,220
minimize seek time is the shortest seek

994
00:41:35,220 --> 00:41:38,700
time first algorithm or sstf

995
00:41:38,700 --> 00:41:41,640
this algorithm actually orders requests

996
00:41:41,640 --> 00:41:43,380
by sector location

997
00:41:43,380 --> 00:41:46,020
so when the request for sector 50 comes

998
00:41:46,020 --> 00:41:49,140
in it's kept in an ordered queue a

999
00:41:49,140 --> 00:41:50,640
priority queue

1000
00:41:50,640 --> 00:41:54,720
and the next request to be served by the

1001
00:41:54,720 --> 00:41:56,579
disk these requests are still sent out

1002
00:41:56,579 --> 00:41:57,900
one at a time

1003
00:41:57,900 --> 00:42:01,619
is chosen by looking at whatever request

1004
00:42:01,619 --> 00:42:05,480
is closest to the correct disk position

1005
00:42:05,480 --> 00:42:07,619
historically this could result in

1006
00:42:07,619 --> 00:42:09,540
Starvation because if a bunch of

1007
00:42:09,540 --> 00:42:12,480
requests come in for one piece of the

1008
00:42:12,480 --> 00:42:15,119
disk requests for the remainder of the

1009
00:42:15,119 --> 00:42:17,220
disk might not be processed for lengthy

1010
00:42:17,220 --> 00:42:19,500
periods of time furthermore once again

1011
00:42:19,500 --> 00:42:22,020
with logical block addressing the

1012
00:42:22,020 --> 00:42:23,880
operating system doesn't really know

1013
00:42:23,880 --> 00:42:25,859
where the sectors are laid out on disk

1014
00:42:25,859 --> 00:42:27,839
and so this algorithm doesn't really

1015
00:42:27,839 --> 00:42:30,780
work with modern hard drives

1016
00:42:30,780 --> 00:42:33,680
also a solid state drives this algorithm

1017
00:42:33,680 --> 00:42:36,480
assumes there's a disk head which in the

1018
00:42:36,480 --> 00:42:38,339
case of a non-mechanical drive there is

1019
00:42:38,339 --> 00:42:41,099
not in the Linux kernel an approximation

1020
00:42:41,099 --> 00:42:42,839
to shortest seek time first was

1021
00:42:42,839 --> 00:42:44,339
implemented with the anticipatory

1022
00:42:44,339 --> 00:42:45,480
scheduler

1023
00:42:45,480 --> 00:42:47,780
this was the default scheduler from

1024
00:42:47,780 --> 00:42:53,760
2.6.0 to 2.6.17 it was removed in 2.6.33

1025
00:42:53,760 --> 00:42:55,800
because it's obsolete

1026
00:42:55,800 --> 00:42:58,079
the idea behind the anticipatory

1027
00:42:58,079 --> 00:43:00,119
scheduler was to approximate short of

1028
00:43:00,119 --> 00:43:02,280
seek time first

1029
00:43:02,280 --> 00:43:06,319
by ordering only the read requests into

1030
00:43:06,319 --> 00:43:10,680
an ordered queue into a priority queue

1031
00:43:10,680 --> 00:43:12,900
if the next read request was close to

1032
00:43:12,900 --> 00:43:15,119
the current head position that request

1033
00:43:15,119 --> 00:43:17,339
would be dispatched immediately

1034
00:43:17,339 --> 00:43:19,200
otherwise the schedule would actually

1035
00:43:19,200 --> 00:43:21,060
wait a few milliseconds to see if

1036
00:43:21,060 --> 00:43:23,099
another request arrives for nearby

1037
00:43:23,099 --> 00:43:24,660
location

1038
00:43:24,660 --> 00:43:26,640
and starvation was avoided in this

1039
00:43:26,640 --> 00:43:29,339
algorithm by placing expiration times on

1040
00:43:29,339 --> 00:43:32,040
each request and adding preemption so

1041
00:43:32,040 --> 00:43:34,500
that if a request was waiting too long

1042
00:43:34,500 --> 00:43:36,119
it would go ahead and be serviced

1043
00:43:36,119 --> 00:43:38,520
regardless of its location

1044
00:43:38,520 --> 00:43:40,440
the idea here was to reduce overall

1045
00:43:40,440 --> 00:43:41,940
seeking

1046
00:43:41,940 --> 00:43:43,800
there is a separate cue for write

1047
00:43:43,800 --> 00:43:45,960
requests because right requests could be

1048
00:43:45,960 --> 00:43:48,060
performed asynchronously we did not have

1049
00:43:48,060 --> 00:43:50,640
to wait on those requests to be

1050
00:43:50,640 --> 00:43:52,319
completed before our process could

1051
00:43:52,319 --> 00:43:54,960
continue doing useful work

1052
00:43:54,960 --> 00:43:57,119
this algorithm was shown with low

1053
00:43:57,119 --> 00:43:59,460
performance drives to improve

1054
00:43:59,460 --> 00:44:02,480
performance on web server applications

1055
00:44:02,480 --> 00:44:04,619
however it was shown to have poor

1056
00:44:04,619 --> 00:44:06,960
performance for database loads where

1057
00:44:06,960 --> 00:44:08,520
there were a lot of random reads and

1058
00:44:08,520 --> 00:44:10,680
writes on the disk and with high

1059
00:44:10,680 --> 00:44:12,839
performance disks this algorithm

1060
00:44:12,839 --> 00:44:15,480
actually breaks down modern hard disks

1061
00:44:15,480 --> 00:44:17,700
generally do qualify as high performance

1062
00:44:17,700 --> 00:44:19,980
disks the reason being is that they

1063
00:44:19,980 --> 00:44:21,599
Implement something called native

1064
00:44:21,599 --> 00:44:24,060
command queuing this is a feature of

1065
00:44:24,060 --> 00:44:26,880
newer SATA drives and basically native

1066
00:44:26,880 --> 00:44:29,160
command queuing leaves scheduling of

1067
00:44:29,160 --> 00:44:32,640
disk requests up to the disk itself the

1068
00:44:32,640 --> 00:44:34,560
disk circuitry and firmware makes the

1069
00:44:34,560 --> 00:44:37,260
decision about which request to handle

1070
00:44:37,260 --> 00:44:38,220
next

1071
00:44:38,220 --> 00:44:40,740
to do this the disk has a built-in

1072
00:44:40,740 --> 00:44:44,579
priority queue of about 32 entries

1073
00:44:44,579 --> 00:44:47,099
and the disk is able to schedule its

1074
00:44:47,099 --> 00:44:49,260
requests automatically taking into

1075
00:44:49,260 --> 00:44:51,420
account both the seat time and the

1076
00:44:51,420 --> 00:44:53,640
rotational delay since the disk knows

1077
00:44:53,640 --> 00:44:55,260
the location of the platter

1078
00:44:55,260 --> 00:44:57,300
this makes modern discs much more

1079
00:44:57,300 --> 00:44:59,520
efficient and this works with logical

1080
00:44:59,520 --> 00:45:02,339
block addressing the operating system's

1081
00:45:02,339 --> 00:45:04,740
role with this type of hard disk is

1082
00:45:04,740 --> 00:45:07,020
really more arbitration of the just

1083
00:45:07,020 --> 00:45:09,540
resources among the different programs

1084
00:45:09,540 --> 00:45:12,180
running on the system one modern Linux

1085
00:45:12,180 --> 00:45:13,740
scheduler that can be used for such

1086
00:45:13,740 --> 00:45:15,300
arbitration is called the deadline

1087
00:45:15,300 --> 00:45:16,619
scheduler

1088
00:45:16,619 --> 00:45:18,420
and in this scheduler the kernel

1089
00:45:18,420 --> 00:45:20,760
maintains separate request cues for both

1090
00:45:20,760 --> 00:45:23,760
read requests and write requests similar

1091
00:45:23,760 --> 00:45:26,579
to the anticipatory scheduler reads are

1092
00:45:26,579 --> 00:45:28,200
prioritized over writes because

1093
00:45:28,200 --> 00:45:30,839
processes typically block or stop and

1094
00:45:30,839 --> 00:45:33,180
wait while waiting to read something

1095
00:45:33,180 --> 00:45:34,800
from the disk

1096
00:45:34,800 --> 00:45:37,500
thus rights can be done later at some

1097
00:45:37,500 --> 00:45:38,760
point when it's convenient for the

1098
00:45:38,760 --> 00:45:40,380
operating system

1099
00:45:40,380 --> 00:45:42,599
the waiting time in each queue with the

1100
00:45:42,599 --> 00:45:44,400
deadline scheduler is used to determine

1101
00:45:44,400 --> 00:45:47,579
which request will be scheduled next

1102
00:45:47,579 --> 00:45:50,520
a 500 millisecond request time is the

1103
00:45:50,520 --> 00:45:52,260
goal for read request this is the time

1104
00:45:52,260 --> 00:45:54,540
it would take to start the request

1105
00:45:54,540 --> 00:45:57,060
with a five second goal to start a write

1106
00:45:57,060 --> 00:45:58,200
requests

1107
00:45:58,200 --> 00:46:00,000
this scheduler May improve system

1108
00:46:00,000 --> 00:46:02,099
responsiveness during periods of heavy

1109
00:46:02,099 --> 00:46:04,440
disk i o at the expense of data

1110
00:46:04,440 --> 00:46:06,960
throughput since each request has a

1111
00:46:06,960 --> 00:46:09,240
deadline and the longer request has been

1112
00:46:09,240 --> 00:46:11,819
waiting the sooner it will be scheduled

1113
00:46:11,819 --> 00:46:14,280
this is especially useful for database

1114
00:46:14,280 --> 00:46:16,319
workloads because there are many

1115
00:46:16,319 --> 00:46:18,420
requests for different parts of the disk

1116
00:46:18,420 --> 00:46:22,200
however for web servers and other

1117
00:46:22,200 --> 00:46:24,540
services that try to access large

1118
00:46:24,540 --> 00:46:26,579
quantities of data located in the same

1119
00:46:26,579 --> 00:46:29,760
location in the disk this particular

1120
00:46:29,760 --> 00:46:31,680
scheduler can actually reduce total

1121
00:46:31,680 --> 00:46:33,839
throughput completely fair queuing is a

1122
00:46:33,839 --> 00:46:35,520
somewhat different idea

1123
00:46:35,520 --> 00:46:37,859
where instead of actually scheduling the

1124
00:46:37,859 --> 00:46:39,540
i o requests

1125
00:46:39,540 --> 00:46:41,280
the completely Fair queuing model

1126
00:46:41,280 --> 00:46:44,339
schedules processes or running programs

1127
00:46:44,339 --> 00:46:49,740
to have time slice access to each disk

1128
00:46:49,740 --> 00:46:53,099
and essentially this cfq scheduler gives

1129
00:46:53,099 --> 00:46:57,119
each process an i o time slice and that

1130
00:46:57,119 --> 00:46:59,400
process can do as much i o on the disk

1131
00:46:59,400 --> 00:47:02,040
as it would like within that time slice

1132
00:47:02,040 --> 00:47:05,640
when the time slice expires the CF key

1133
00:47:05,640 --> 00:47:07,319
scheduler moves on to the next process

1134
00:47:07,319 --> 00:47:10,859
and gives it access time to the disk

1135
00:47:10,859 --> 00:47:12,540
there is a little bit of similarity here

1136
00:47:12,540 --> 00:47:14,579
to anticipatory scheduling since a

1137
00:47:14,579 --> 00:47:17,040
process can send another request during

1138
00:47:17,040 --> 00:47:19,260
its time slice and try to get that

1139
00:47:19,260 --> 00:47:21,060
request in without having a lot of seek

1140
00:47:21,060 --> 00:47:22,200
time

1141
00:47:22,200 --> 00:47:26,520
however this algorithm can waste time if

1142
00:47:26,520 --> 00:47:28,140
a process does not immediately turn

1143
00:47:28,140 --> 00:47:31,140
around and send another request

1144
00:47:31,140 --> 00:47:33,599
thus it can reduce the overall disk

1145
00:47:33,599 --> 00:47:36,000
throughput since there could be idle

1146
00:47:36,000 --> 00:47:37,619
times while waiting to see if another

1147
00:47:37,619 --> 00:47:40,380
request will come in for our time slice

1148
00:47:40,380 --> 00:47:42,720
expires this has been the default

1149
00:47:42,720 --> 00:47:46,500
scheduler in Linux since 2.6.18 for

1150
00:47:46,500 --> 00:47:49,260
solid state disks we have to choose a

1151
00:47:49,260 --> 00:47:51,780
scheduler that accounts for the fact

1152
00:47:51,780 --> 00:47:53,520
that there's no seek time to worry about

1153
00:47:53,520 --> 00:47:54,780
on the disk

1154
00:47:54,780 --> 00:47:57,180
the anticipatory scheduler the elevator

1155
00:47:57,180 --> 00:48:00,660
algorithms short of seek time first

1156
00:48:00,660 --> 00:48:03,300
all of these algorithms can actually

1157
00:48:03,300 --> 00:48:05,640
reduce performance on a solid state

1158
00:48:05,640 --> 00:48:08,220
drive because they make assumptions

1159
00:48:08,220 --> 00:48:11,160
about minimizing head seek time and we

1160
00:48:11,160 --> 00:48:13,200
have no heads to move with a solid-state

1161
00:48:13,200 --> 00:48:16,020
disk completely Fair queuing can also

1162
00:48:16,020 --> 00:48:17,760
reduce disk performance because of

1163
00:48:17,760 --> 00:48:19,500
idling at the end of a Time slice that's

1164
00:48:19,500 --> 00:48:22,319
true for any disk so what do we do to

1165
00:48:22,319 --> 00:48:24,240
maximize performance for solid state

1166
00:48:24,240 --> 00:48:25,319
drive

1167
00:48:25,319 --> 00:48:27,420
there are really two good choices for a

1168
00:48:27,420 --> 00:48:30,119
solid state drive there is the NOAA or

1169
00:48:30,119 --> 00:48:33,000
fifo scheduler this works well for

1170
00:48:33,000 --> 00:48:35,640
general purpose systems however when

1171
00:48:35,640 --> 00:48:38,220
their handy I O workloads and we want to

1172
00:48:38,220 --> 00:48:40,440
maintain system responsiveness the

1173
00:48:40,440 --> 00:48:43,020
deadline algorithm is useful since other

1174
00:48:43,020 --> 00:48:44,940
processes will have more opportunities

1175
00:48:44,940 --> 00:48:49,020
to access the disk in summary operating

1176
00:48:49,020 --> 00:48:50,940
systems are arbitrating disk access

1177
00:48:50,940 --> 00:48:53,940
among different processes to prevent one

1178
00:48:53,940 --> 00:48:56,819
process from monopolizing the disk and

1179
00:48:56,819 --> 00:48:59,220
preventing other processes and having

1180
00:48:59,220 --> 00:49:00,780
access

1181
00:49:00,780 --> 00:49:03,300
on older discs with cylinder head sector

1182
00:49:03,300 --> 00:49:05,940
addressing the operating system was also

1183
00:49:05,940 --> 00:49:08,819
attempting to reduce seek time thus

1184
00:49:08,819 --> 00:49:11,220
improving aggregate disk performance

1185
00:49:11,220 --> 00:49:13,619
however newer sanatists with Native

1186
00:49:13,619 --> 00:49:16,440
command queuing scheduled themselves to

1187
00:49:16,440 --> 00:49:18,420
reduce both seek time and rotational

1188
00:49:18,420 --> 00:49:19,680
delay

1189
00:49:19,680 --> 00:49:21,359
thus

1190
00:49:21,359 --> 00:49:24,359
algorithms that attempt to minimize seek

1191
00:49:24,359 --> 00:49:27,119
time are unnecessary

1192
00:49:27,119 --> 00:49:29,900
Furthermore with solid-state drives

1193
00:49:29,900 --> 00:49:32,520
scheduling mechanisms that are based on

1194
00:49:32,520 --> 00:49:34,859
Old mechanical assumptions can actually

1195
00:49:34,859 --> 00:49:38,160
reduce performance so for ssds we're

1196
00:49:38,160 --> 00:49:40,020
really only interested in arbitration

1197
00:49:40,020 --> 00:49:41,819
this lecture I'm going to discuss

1198
00:49:41,819 --> 00:49:44,280
development Cycles in particular we'll

1199
00:49:44,280 --> 00:49:46,980
talk about software life cycle steps in

1200
00:49:46,980 --> 00:49:48,480
software development

1201
00:49:48,480 --> 00:49:50,160
talk about some software development

1202
00:49:50,160 --> 00:49:52,619
models and give a brief overview of

1203
00:49:52,619 --> 00:49:55,380
formal methods the software life cycle

1204
00:49:55,380 --> 00:49:58,220
is a way of expressing how software

1205
00:49:58,220 --> 00:50:01,560
comes into being and evolves over a

1206
00:50:01,560 --> 00:50:03,839
lengthy period of time there's more to

1207
00:50:03,839 --> 00:50:05,400
software development than simply

1208
00:50:05,400 --> 00:50:07,079
programming

1209
00:50:07,079 --> 00:50:10,140
in particular we need to plan the piece

1210
00:50:10,140 --> 00:50:11,520
of software that we're going to develop

1211
00:50:11,520 --> 00:50:13,079
when we're talking about a new piece of

1212
00:50:13,079 --> 00:50:14,520
software

1213
00:50:14,520 --> 00:50:16,740
figure out what the requirements of that

1214
00:50:16,740 --> 00:50:18,780
software is going to be

1215
00:50:18,780 --> 00:50:21,960
design that software to satisfy those

1216
00:50:21,960 --> 00:50:23,220
requirements

1217
00:50:23,220 --> 00:50:25,560
and then perform several rounds of

1218
00:50:25,560 --> 00:50:28,920
coding and testing to ensure that our

1219
00:50:28,920 --> 00:50:31,500
finished application actually meets the

1220
00:50:31,500 --> 00:50:33,240
requirements before we can put the

1221
00:50:33,240 --> 00:50:35,460
application into production

1222
00:50:35,460 --> 00:50:37,800
the life of a software application is

1223
00:50:37,800 --> 00:50:39,660
not over however simply because it

1224
00:50:39,660 --> 00:50:41,460
enters production

1225
00:50:41,460 --> 00:50:44,819
over time invariably we will find the

1226
00:50:44,819 --> 00:50:47,400
need to upgrade the software which means

1227
00:50:47,400 --> 00:50:49,079
going through the same development

1228
00:50:49,079 --> 00:50:51,960
process all over again

1229
00:50:51,960 --> 00:50:55,319
and since any software application less

1230
00:50:55,319 --> 00:50:57,599
trivial than hello world contains bugs

1231
00:50:57,599 --> 00:51:00,599
we will have quite a bit of ongoing

1232
00:51:00,599 --> 00:51:03,240
maintenance in order to find and fix

1233
00:51:03,240 --> 00:51:06,180
errors that creep up in the software

1234
00:51:06,180 --> 00:51:09,180
we'll also need to support users and go

1235
00:51:09,180 --> 00:51:10,740
through several of these processes

1236
00:51:10,740 --> 00:51:13,200
before the software finally gets to the

1237
00:51:13,200 --> 00:51:14,700
point where it has reached its end of

1238
00:51:14,700 --> 00:51:16,740
life and is replaced by a new

1239
00:51:16,740 --> 00:51:18,480
application software development

1240
00:51:18,480 --> 00:51:21,420
activities comprise a number of steps

1241
00:51:21,420 --> 00:51:23,460
we have to conceptualize the type of

1242
00:51:23,460 --> 00:51:25,559
software that we're going to be creating

1243
00:51:25,559 --> 00:51:28,020
perform requirements analysis to figure

1244
00:51:28,020 --> 00:51:30,000
out what the software actually needs to

1245
00:51:30,000 --> 00:51:30,960
do

1246
00:51:30,960 --> 00:51:33,240
come up with a design for the particular

1247
00:51:33,240 --> 00:51:35,640
application that we wish to implement

1248
00:51:35,640 --> 00:51:38,160
and then finally Implement and test the

1249
00:51:38,160 --> 00:51:39,540
application

1250
00:51:39,540 --> 00:51:42,180
during the maintenance phase of software

1251
00:51:42,180 --> 00:51:43,859
life cycle

1252
00:51:43,859 --> 00:51:47,819
we need to check and fix bugs

1253
00:51:47,819 --> 00:51:49,500
it's important that we be able to

1254
00:51:49,500 --> 00:51:51,599
replicate bugs that are reported to the

1255
00:51:51,599 --> 00:51:54,059
from the user so that we're able to

1256
00:51:54,059 --> 00:51:57,000
verify the bugs do in fact exist and

1257
00:51:57,000 --> 00:51:59,339
determine the actual location of the

1258
00:51:59,339 --> 00:52:02,280
problem before trying to implement a fix

1259
00:52:02,280 --> 00:52:05,099
once a fix is implemented it too needs

1260
00:52:05,099 --> 00:52:06,960
to be tested before a patch can be

1261
00:52:06,960 --> 00:52:09,359
released for the software now managing

1262
00:52:09,359 --> 00:52:12,420
these development activities is an

1263
00:52:12,420 --> 00:52:15,300
important step in and of itself

1264
00:52:15,300 --> 00:52:18,180
each step of this process requires some

1265
00:52:18,180 --> 00:52:20,640
kind of orchestration particularly as

1266
00:52:20,640 --> 00:52:22,200
the size of the development team

1267
00:52:22,200 --> 00:52:23,520
increases

1268
00:52:23,520 --> 00:52:25,980
a discipline process helps to maximize

1269
00:52:25,980 --> 00:52:28,380
Effectiveness when the work is being

1270
00:52:28,380 --> 00:52:31,800
done by more than one person in the

1271
00:52:31,800 --> 00:52:34,500
details of this process management are

1272
00:52:34,500 --> 00:52:36,660
what we call a development model the

1273
00:52:36,660 --> 00:52:39,059
simplest development model is the code

1274
00:52:39,059 --> 00:52:40,380
and fix model

1275
00:52:40,380 --> 00:52:42,720
this is really the simplest of models

1276
00:52:42,720 --> 00:52:46,200
because it exhibits a complete lack of

1277
00:52:46,200 --> 00:52:48,119
any kind of design discipline what

1278
00:52:48,119 --> 00:52:50,640
happens is programmers simply sit down

1279
00:52:50,640 --> 00:52:53,640
write some code maybe run a couple tests

1280
00:52:53,640 --> 00:52:55,760
fix the code based upon the tests

1281
00:52:55,760 --> 00:52:58,980
deliver the result to the customer

1282
00:52:58,980 --> 00:53:01,260
if the customer likes the code then

1283
00:53:01,260 --> 00:53:04,500
they're done if not then go back fix the

1284
00:53:04,500 --> 00:53:07,380
code some more deliver it again this

1285
00:53:07,380 --> 00:53:09,720
process continues until the customer is

1286
00:53:09,720 --> 00:53:11,160
either satisfied or just completely

1287
00:53:11,160 --> 00:53:12,480
gives up

1288
00:53:12,480 --> 00:53:16,200
this type of model is inefficient

1289
00:53:16,200 --> 00:53:18,540
the code is often hastily completed

1290
00:53:18,540 --> 00:53:22,319
quite a few bugs this type of model is

1291
00:53:22,319 --> 00:53:25,020
while fairly well suited to outsourced

1292
00:53:25,020 --> 00:53:28,140
programming is not really suitable for

1293
00:53:28,140 --> 00:53:29,760
long-term support of a particular

1294
00:53:29,760 --> 00:53:32,280
application because the project is

1295
00:53:32,280 --> 00:53:34,020
treated as something that's to be coded

1296
00:53:34,020 --> 00:53:36,839
and later forgotten the opposite extreme

1297
00:53:36,839 --> 00:53:39,720
would be the waterfall model which is an

1298
00:53:39,720 --> 00:53:41,520
attempt to follow a conceptual diagram

1299
00:53:41,520 --> 00:53:44,819
of processes step by step and perform

1300
00:53:44,819 --> 00:53:46,800
each step all the way to completion

1301
00:53:46,800 --> 00:53:48,900
before moving on to the next step

1302
00:53:48,900 --> 00:53:50,819
so one would start with a concept

1303
00:53:50,819 --> 00:53:53,940
perform requirements analysis until all

1304
00:53:53,940 --> 00:53:55,980
the requirements were teased out perform

1305
00:53:55,980 --> 00:53:58,319
a design step until the complete design

1306
00:53:58,319 --> 00:53:59,819
was finished

1307
00:53:59,819 --> 00:54:02,520
and then start the coding this model

1308
00:54:02,520 --> 00:54:04,559
doesn't work well in practice because

1309
00:54:04,559 --> 00:54:09,240
often issues related to requirements do

1310
00:54:09,240 --> 00:54:11,460
not emerge until after a few versions of

1311
00:54:11,460 --> 00:54:13,859
the software have been completed and the

1312
00:54:13,859 --> 00:54:16,680
user comes back and fills in the

1313
00:54:16,680 --> 00:54:18,780
development team on details that weren't

1314
00:54:18,780 --> 00:54:21,000
previously disclosed during the original

1315
00:54:21,000 --> 00:54:23,880
requirements analysis phase similarly

1316
00:54:23,880 --> 00:54:26,760
the design often needs to be changed as

1317
00:54:26,760 --> 00:54:28,680
the source code evolves

1318
00:54:28,680 --> 00:54:30,960
there is a related model called The V

1319
00:54:30,960 --> 00:54:33,000
model that tries to establish

1320
00:54:33,000 --> 00:54:34,680
relationships between these steps

1321
00:54:34,680 --> 00:54:36,660
however these models are generally not

1322
00:54:36,660 --> 00:54:38,579
considered effective iterative and

1323
00:54:38,579 --> 00:54:41,099
incremental models are the most popular

1324
00:54:41,099 --> 00:54:43,500
software development models used today

1325
00:54:43,500 --> 00:54:45,780
and instead of Performing each task to

1326
00:54:45,780 --> 00:54:47,760
completion like one would try to do in

1327
00:54:47,760 --> 00:54:49,859
the waterfall model and break the

1328
00:54:49,859 --> 00:54:51,839
project into pieces and Implement one

1329
00:54:51,839 --> 00:54:53,339
piece at a time

1330
00:54:53,339 --> 00:54:55,680
test and deliver multiple prototypes

1331
00:54:55,680 --> 00:54:58,619
during the project development phase and

1332
00:54:58,619 --> 00:55:01,200
solicit feedback from the customer for

1333
00:55:01,200 --> 00:55:04,559
each given prototype this process begins

1334
00:55:04,559 --> 00:55:07,380
with a concept but then goes through a

1335
00:55:07,380 --> 00:55:10,140
requirements analysis a partial design a

1336
00:55:10,140 --> 00:55:12,900
prototype and testing in this feedback

1337
00:55:12,900 --> 00:55:17,280
process multiple times and over time the

1338
00:55:17,280 --> 00:55:18,780
software application from its

1339
00:55:18,780 --> 00:55:21,000
requirements through its design through

1340
00:55:21,000 --> 00:55:24,599
its code are progressively revised until

1341
00:55:24,599 --> 00:55:27,000
the application actually satisfies the

1342
00:55:27,000 --> 00:55:29,640
customer's requirements once this occurs

1343
00:55:29,640 --> 00:55:31,800
some final testing and integration steps

1344
00:55:31,800 --> 00:55:33,900
can be performed before the software is

1345
00:55:33,900 --> 00:55:35,520
finally released and put into production

1346
00:55:35,520 --> 00:55:37,500
now there are multiple iterative and

1347
00:55:37,500 --> 00:55:39,839
incremental development models rapid

1348
00:55:39,839 --> 00:55:42,660
application development is a model that

1349
00:55:42,660 --> 00:55:44,579
features short planning phase with a

1350
00:55:44,579 --> 00:55:46,800
large number of prototypes Agile

1351
00:55:46,800 --> 00:55:49,079
development puts a strong emphasis on

1352
00:55:49,079 --> 00:55:52,319
people and interactions over particular

1353
00:55:52,319 --> 00:55:54,720
requirements Dot documents and other

1354
00:55:54,720 --> 00:55:57,780
formalities and focuses on responding to

1355
00:55:57,780 --> 00:56:00,599
customer feedback and developing in a

1356
00:56:00,599 --> 00:56:03,059
more feedback Centric way extreme

1357
00:56:03,059 --> 00:56:05,400
programming is a form of Agile

1358
00:56:05,400 --> 00:56:07,380
development with extremely short

1359
00:56:07,380 --> 00:56:10,260
prototype release cycles and very little

1360
00:56:10,260 --> 00:56:12,240
documentation other than the application

1361
00:56:12,240 --> 00:56:15,000
itself for larger teams a more formal

1362
00:56:15,000 --> 00:56:16,920
approach is available with a Spyro model

1363
00:56:16,920 --> 00:56:19,680
which emphasizes risk analysis at each

1364
00:56:19,680 --> 00:56:22,020
step in order to evaluate the progress

1365
00:56:22,020 --> 00:56:24,000
of the project and attempt to prevent

1366
00:56:24,000 --> 00:56:27,240
cost overrents there is also a branch of

1367
00:56:27,240 --> 00:56:29,700
development called formal methods these

1368
00:56:29,700 --> 00:56:31,800
are used for life and safety critical

1369
00:56:31,800 --> 00:56:33,900
software systems and are in fact

1370
00:56:33,900 --> 00:56:35,819
required by the European Union for

1371
00:56:35,819 --> 00:56:37,800
avionics software and other safety

1372
00:56:37,800 --> 00:56:39,780
critical applications clean room

1373
00:56:39,780 --> 00:56:42,540
software engineering is a process in

1374
00:56:42,540 --> 00:56:44,640
which software is formally verified to

1375
00:56:44,640 --> 00:56:46,559
ensure that it meets all specifications

1376
00:56:46,559 --> 00:56:49,740
and is statistically tested and

1377
00:56:49,740 --> 00:56:52,440
statistically quality controlled to

1378
00:56:52,440 --> 00:56:55,440
ensure the application is actually

1379
00:56:55,440 --> 00:56:57,300
performing the tasks that it's supposed

1380
00:56:57,300 --> 00:56:59,819
to perform this is also an iterative and

1381
00:56:59,819 --> 00:57:02,280
incremental approach however it does

1382
00:57:02,280 --> 00:57:05,760
require much greater documentation of

1383
00:57:05,760 --> 00:57:07,800
the testing procedures so how much

1384
00:57:07,800 --> 00:57:09,839
formalism is actually required in a

1385
00:57:09,839 --> 00:57:12,300
software development process well Dr

1386
00:57:12,300 --> 00:57:14,940
Aleister Coburn came up with a scale

1387
00:57:14,940 --> 00:57:17,339
and determined that the need for formal

1388
00:57:17,339 --> 00:57:20,280
development processes increases with the

1389
00:57:20,280 --> 00:57:22,319
size of the development team the

1390
00:57:22,319 --> 00:57:24,960
financial risk of the project or the

1391
00:57:24,960 --> 00:57:26,460
safety critical nature of the final

1392
00:57:26,460 --> 00:57:28,800
system or any combination of those

1393
00:57:28,800 --> 00:57:31,800
factors furthermore depending on the

1394
00:57:31,800 --> 00:57:33,900
regulatory requirements in under which

1395
00:57:33,900 --> 00:57:36,059
the software is being developed there

1396
00:57:36,059 --> 00:57:38,240
may be a greater need for documentation

1397
00:57:38,240 --> 00:57:42,420
and process verification than in

1398
00:57:42,420 --> 00:57:45,300
regulatory domains where there is little

1399
00:57:45,300 --> 00:57:47,640
or no such regulation so in summary

1400
00:57:47,640 --> 00:57:49,859
software development encompasses much

1401
00:57:49,859 --> 00:57:52,500
more than simply writing program code

1402
00:57:52,500 --> 00:57:54,300
most of the popular development

1403
00:57:54,300 --> 00:57:56,640
processes that are in use today are

1404
00:57:56,640 --> 00:57:58,200
iterative and incremental approaches

1405
00:57:58,200 --> 00:58:00,660
that emphasize building small prototypes

1406
00:58:00,660 --> 00:58:03,480
and adding on to those prototypes as the

1407
00:58:03,480 --> 00:58:06,180
project progresses however safety

1408
00:58:06,180 --> 00:58:08,640
critical systems and

1409
00:58:08,640 --> 00:58:10,859
projects with extremely large

1410
00:58:10,859 --> 00:58:14,640
development teams or high risk often

1411
00:58:14,640 --> 00:58:17,700
will need greater formal procedures in

1412
00:58:17,700 --> 00:58:19,079
order to coordinate the development

1413
00:58:19,079 --> 00:58:22,319
process and may require formal verif in

1414
00:58:22,319 --> 00:58:24,660
this lecture I'm going to discuss file

1415
00:58:24,660 --> 00:58:26,339
systems

1416
00:58:26,339 --> 00:58:28,440
I'll be providing an overview of the

1417
00:58:28,440 --> 00:58:31,140
purpose of file systems discussing

1418
00:58:31,140 --> 00:58:33,540
metadata that they store

1419
00:58:33,540 --> 00:58:35,700
explaining how we create a file system

1420
00:58:35,700 --> 00:58:38,280
through a process known as formatting

1421
00:58:38,280 --> 00:58:40,559
talk about some issues with file systems

1422
00:58:40,559 --> 00:58:43,260
including fragmentation and journaling

1423
00:58:43,260 --> 00:58:45,540
briefly discuss some internal layouts

1424
00:58:45,540 --> 00:58:48,240
used by different file systems and

1425
00:58:48,240 --> 00:58:50,099
finally talk about mounting and

1426
00:58:50,099 --> 00:58:51,900
unmounting file systems to make them

1427
00:58:51,900 --> 00:58:55,099
available to users

1428
00:58:55,380 --> 00:58:57,599
the file system is responsible for

1429
00:58:57,599 --> 00:58:59,460
laying out data on a persistent storage

1430
00:58:59,460 --> 00:59:02,160
device and ensuring that data can be

1431
00:59:02,160 --> 00:59:04,500
retrieved reliably

1432
00:59:04,500 --> 00:59:06,480
the file system is an abstraction of

1433
00:59:06,480 --> 00:59:09,540
disk space it provides routines for

1434
00:59:09,540 --> 00:59:12,240
querying opening and closing files and

1435
00:59:12,240 --> 00:59:14,640
providing human readable names for files

1436
00:59:14,640 --> 00:59:16,440
and some kind of organizational

1437
00:59:16,440 --> 00:59:18,780
structure for files typically through

1438
00:59:18,780 --> 00:59:20,940
directories or folders

1439
00:59:20,940 --> 00:59:23,160
without a file system we would have to

1440
00:59:23,160 --> 00:59:26,760
access disk by physical location or by

1441
00:59:26,760 --> 00:59:29,940
address and each program would have to

1442
00:59:29,940 --> 00:59:33,299
reserve certain address limits for its

1443
00:59:33,299 --> 00:59:36,140
exclusive use

1444
00:59:36,540 --> 00:59:39,059
file systems in addition to performing

1445
00:59:39,059 --> 00:59:42,240
this abstraction also arbitrate disk

1446
00:59:42,240 --> 00:59:45,420
space among different programs and

1447
00:59:45,420 --> 00:59:47,700
different users of a computer system

1448
00:59:47,700 --> 00:59:50,099
file permissions allow users to have a

1449
00:59:50,099 --> 00:59:52,020
certain degree of privacy

1450
00:59:52,020 --> 00:59:55,619
while file quotas ensure that one user

1451
00:59:55,619 --> 00:59:58,740
does not monopolize the entire system by

1452
00:59:58,740 --> 01:00:02,099
utilizing all the disk space

1453
01:00:02,099 --> 01:00:04,619
file systems are also responsible for

1454
01:00:04,619 --> 01:00:06,839
storing metadata or information about

1455
01:00:06,839 --> 01:00:10,619
each file this includes a file name file

1456
01:00:10,619 --> 01:00:11,760
size

1457
01:00:11,760 --> 01:00:14,220
who owns the file what group that owner

1458
01:00:14,220 --> 01:00:16,740
belongs to what permissions exist for

1459
01:00:16,740 --> 01:00:19,260
each different category of users on the

1460
01:00:19,260 --> 01:00:22,020
system to access that file as well as to

1461
01:00:22,020 --> 01:00:25,079
provide certain time stamps on Unix we

1462
01:00:25,079 --> 01:00:27,599
have the inode creation time the file

1463
01:00:27,599 --> 01:00:30,780
modification time and optionally the

1464
01:00:30,780 --> 01:00:33,599
last file access time

1465
01:00:33,599 --> 01:00:36,359
metadata records also include internal

1466
01:00:36,359 --> 01:00:38,940
information that is important for the

1467
01:00:38,940 --> 01:00:41,640
file system itself such as pointers to

1468
01:00:41,640 --> 01:00:44,640
the actual data on disk and a reference

1469
01:00:44,640 --> 01:00:47,280
count for how many different names refer

1470
01:00:47,280 --> 01:00:49,740
to the same file system called hard

1471
01:00:49,740 --> 01:00:52,220
links

1472
01:00:52,920 --> 01:00:56,160
we create a file system by taking an

1473
01:00:56,160 --> 01:00:58,500
empty partition or a partition that

1474
01:00:58,500 --> 01:01:01,799
we're ready to reuse and formatting it

1475
01:01:01,799 --> 01:01:04,020
formatting quite simply is the process

1476
01:01:04,020 --> 01:01:06,660
of making a new file system on an

1477
01:01:06,660 --> 01:01:08,579
existing partition

1478
01:01:08,579 --> 01:01:10,859
formatting typically destroys the

1479
01:01:10,859 --> 01:01:12,780
structure of any file system that was

1480
01:01:12,780 --> 01:01:14,400
previously installed on the partition

1481
01:01:14,400 --> 01:01:17,520
thus when you format a partition you

1482
01:01:17,520 --> 01:01:19,740
lose the access to

1483
01:01:19,740 --> 01:01:22,200
its contents at least through standard

1484
01:01:22,200 --> 01:01:23,520
tools

1485
01:01:23,520 --> 01:01:26,940
however unless that free space unless

1486
01:01:26,940 --> 01:01:30,540
that partition is securely erased the

1487
01:01:30,540 --> 01:01:32,040
contents that were formally on the

1488
01:01:32,040 --> 01:01:33,960
partition can still be recovered using

1489
01:01:33,960 --> 01:01:36,480
forensic tools

1490
01:01:36,480 --> 01:01:39,000
the only safe way to switch between file

1491
01:01:39,000 --> 01:01:41,700
systems on a single partition is to back

1492
01:01:41,700 --> 01:01:44,160
the data that's our net partition up to

1493
01:01:44,160 --> 01:01:46,140
another disk

1494
01:01:46,140 --> 01:01:48,420
format the partition using whatever the

1495
01:01:48,420 --> 01:01:50,819
new file system would be and then

1496
01:01:50,819 --> 01:01:53,160
restoring the data from the backup there

1497
01:01:53,160 --> 01:01:55,140
is no safe way to change a file system

1498
01:01:55,140 --> 01:01:59,420
type in place without losing data

1499
01:01:59,819 --> 01:02:03,660
bus systems do suffer from a few issues

1500
01:02:03,660 --> 01:02:05,520
over time

1501
01:02:05,520 --> 01:02:07,559
sections of a file

1502
01:02:07,559 --> 01:02:09,240
in a file system can become

1503
01:02:09,240 --> 01:02:11,579
non-contiguous in other words a file

1504
01:02:11,579 --> 01:02:13,680
gets split over different parts of the

1505
01:02:13,680 --> 01:02:16,740
disk and in the process that also splits

1506
01:02:16,740 --> 01:02:19,500
up the free space so that when new files

1507
01:02:19,500 --> 01:02:21,660
need to be allocated they have to be

1508
01:02:21,660 --> 01:02:23,579
split up to take advantage of smaller

1509
01:02:23,579 --> 01:02:25,500
blocks of free space

1510
01:02:25,500 --> 01:02:28,140
this is a situation called fragmentation

1511
01:02:28,140 --> 01:02:30,480
it's worse in some file systems than

1512
01:02:30,480 --> 01:02:31,799
others

1513
01:02:31,799 --> 01:02:33,900
fragmented file systems were a big

1514
01:02:33,900 --> 01:02:36,180
problem with mechanical hard drives

1515
01:02:36,180 --> 01:02:38,220
simply because a fragmented file

1516
01:02:38,220 --> 01:02:41,460
requires a seek to move from the

1517
01:02:41,460 --> 01:02:43,619
location of the first fragment to the

1518
01:02:43,619 --> 01:02:45,720
location of the next fragment and

1519
01:02:45,720 --> 01:02:47,520
possibly further seeks if there are more

1520
01:02:47,520 --> 01:02:49,140
fragments

1521
01:02:49,140 --> 01:02:51,119
not so much a problem on solid state

1522
01:02:51,119 --> 01:02:52,799
drives however since there's no seek

1523
01:02:52,799 --> 01:02:54,180
time

1524
01:02:54,180 --> 01:02:56,280
and file systems can get around this

1525
01:02:56,280 --> 01:02:57,900
problem either with offline

1526
01:02:57,900 --> 01:03:00,299
defragmentation tools that the system

1527
01:03:00,299 --> 01:03:03,359
administrator can run manually or they

1528
01:03:03,359 --> 01:03:04,980
can use fragmentation avoidance

1529
01:03:04,980 --> 01:03:08,700
strategies or automatic on the Fly

1530
01:03:08,700 --> 01:03:10,980
defragmentation

1531
01:03:10,980 --> 01:03:12,780
another issue that can occur with file

1532
01:03:12,780 --> 01:03:16,500
systems is that a single high-level file

1533
01:03:16,500 --> 01:03:19,319
system operation typically requires

1534
01:03:19,319 --> 01:03:22,079
several low-level steps in order to

1535
01:03:22,079 --> 01:03:23,280
complete

1536
01:03:23,280 --> 01:03:26,460
if the computer Should Crash or power be

1537
01:03:26,460 --> 01:03:28,859
lost in the middle of those steps being

1538
01:03:28,859 --> 01:03:31,380
performed the file system could be left

1539
01:03:31,380 --> 01:03:33,599
in an inconsistent state

1540
01:03:33,599 --> 01:03:35,760
a solution to this problem is called

1541
01:03:35,760 --> 01:03:39,540
journaling and the way this works is by

1542
01:03:39,540 --> 01:03:41,640
recording all the steps that are to be

1543
01:03:41,640 --> 01:03:44,220
taken in something called the journal a

1544
01:03:44,220 --> 01:03:47,280
special part of disk space reserved for

1545
01:03:47,280 --> 01:03:49,680
this particular information

1546
01:03:49,680 --> 01:03:51,540
records all the steps that are going to

1547
01:03:51,540 --> 01:03:54,780
be taken prior to taking the steps

1548
01:03:54,780 --> 01:03:58,440
thus if the system should crash in the

1549
01:03:58,440 --> 01:04:00,000
middle of a file system high level

1550
01:04:00,000 --> 01:04:01,440
operation

1551
01:04:01,440 --> 01:04:03,839
all that needs to occurs the journal

1552
01:04:03,839 --> 01:04:06,119
simply needs to be replayed next time

1553
01:04:06,119 --> 01:04:08,760
the file system is mounted and the steps

1554
01:04:08,760 --> 01:04:11,700
can be carried out again and leave the

1555
01:04:11,700 --> 01:04:15,380
file system in a consistent state

1556
01:04:15,380 --> 01:04:18,720
internally file systems may use one of

1557
01:04:18,720 --> 01:04:20,760
several different approaches for storing

1558
01:04:20,760 --> 01:04:23,280
data on the disk

1559
01:04:23,280 --> 01:04:25,079
a simple layout is called the file

1560
01:04:25,079 --> 01:04:26,640
allocation table

1561
01:04:26,640 --> 01:04:28,680
which simply has a single table on each

1562
01:04:28,680 --> 01:04:31,020
partition to store metadata and the

1563
01:04:31,020 --> 01:04:34,619
addresses of data segments for each file

1564
01:04:34,619 --> 01:04:37,220
dial allocation table type storage

1565
01:04:37,220 --> 01:04:40,500
methods are limited only in terms of how

1566
01:04:40,500 --> 01:04:42,960
big the file allocation table can be

1567
01:04:42,960 --> 01:04:46,020
and these limitations specify among

1568
01:04:46,020 --> 01:04:48,839
other things the maximum size a file can

1569
01:04:48,839 --> 01:04:51,359
be and how many files can be on the

1570
01:04:51,359 --> 01:04:52,980
system

1571
01:04:52,980 --> 01:04:54,960
another approach is to use something

1572
01:04:54,960 --> 01:04:57,180
called inodes which are data structures

1573
01:04:57,180 --> 01:04:59,700
on Unix systems that contain the

1574
01:04:59,700 --> 01:05:02,940
metadata for a file including pointers

1575
01:05:02,940 --> 01:05:05,700
to the actual data

1576
01:05:05,700 --> 01:05:07,920
inodes do not store the file names

1577
01:05:07,920 --> 01:05:09,960
however these are stored in a separate

1578
01:05:09,960 --> 01:05:12,720
structure called a directory that Maps

1579
01:05:12,720 --> 01:05:15,480
file names to inodes

1580
01:05:15,480 --> 01:05:17,760
the maximum number of files of a single

1581
01:05:17,760 --> 01:05:21,119
file system can hold is limited by the

1582
01:05:21,119 --> 01:05:22,859
number of inodes created when the file

1583
01:05:22,859 --> 01:05:25,200
system is formatted this can be a

1584
01:05:25,200 --> 01:05:27,299
particular problem for file systems that

1585
01:05:27,299 --> 01:05:30,119
wind up storing a really large number of

1586
01:05:30,119 --> 01:05:32,520
very small files there could be plenty

1587
01:05:32,520 --> 01:05:35,460
of space left on the file system on the

1588
01:05:35,460 --> 01:05:38,040
partition however if the number of

1589
01:05:38,040 --> 01:05:40,680
inodes is exhausted then no more files

1590
01:05:40,680 --> 01:05:43,640
will be able to be created

1591
01:05:43,740 --> 01:05:46,500
another approach to storing files and

1592
01:05:46,500 --> 01:05:48,900
laying out data on the file system is

1593
01:05:48,900 --> 01:05:50,880
through the use of extents

1594
01:05:50,880 --> 01:05:53,640
extents support larger maximum file

1595
01:05:53,640 --> 01:05:56,339
sizes because they're designed to allow

1596
01:05:56,339 --> 01:05:58,020
files to be composed of several

1597
01:05:58,020 --> 01:06:00,720
non-contiguous blocks of space much like

1598
01:06:00,720 --> 01:06:03,000
fragmenting that could occur with a file

1599
01:06:03,000 --> 01:06:05,400
system that doesn't use extents

1600
01:06:05,400 --> 01:06:08,040
extent information is stored with the

1601
01:06:08,040 --> 01:06:10,799
metadata in the file inode or some other

1602
01:06:10,799 --> 01:06:12,599
type of data structure

1603
01:06:12,599 --> 01:06:17,059
for file systems that support extents

1604
01:06:17,339 --> 01:06:19,559
now regardless of how the file system

1605
01:06:19,559 --> 01:06:22,319
lays out its data internally we need to

1606
01:06:22,319 --> 01:06:24,420
make the file system available to users

1607
01:06:24,420 --> 01:06:26,579
and programs on the computer

1608
01:06:26,579 --> 01:06:28,920
to do this we perform a process called

1609
01:06:28,920 --> 01:06:31,680
mounting mounting is the act of making a

1610
01:06:31,680 --> 01:06:34,559
file system available to the users of

1611
01:06:34,559 --> 01:06:35,940
the system

1612
01:06:35,940 --> 01:06:37,799
the opposite process is called

1613
01:06:37,799 --> 01:06:40,260
unmounting which is disconnecting a

1614
01:06:40,260 --> 01:06:42,960
previously mounted file system

1615
01:06:42,960 --> 01:06:46,920
Unix systems Mount file systems at Mount

1616
01:06:46,920 --> 01:06:48,859
points which are simply directories

1617
01:06:48,859 --> 01:06:51,539
somewhere within the overall directory

1618
01:06:51,539 --> 01:06:52,980
structure of the system

1619
01:06:52,980 --> 01:06:55,319
so if I plug in a flash drive on a Linux

1620
01:06:55,319 --> 01:06:58,200
machine for example that flash drive may

1621
01:06:58,200 --> 01:07:02,520
be mounted at slash media my drive

1622
01:07:02,520 --> 01:07:05,460
I can mount a large number of different

1623
01:07:05,460 --> 01:07:08,579
file systems this way at the same time

1624
01:07:08,579 --> 01:07:11,099
and I can make all of the different file

1625
01:07:11,099 --> 01:07:13,380
systems appear to be part of One

1626
01:07:13,380 --> 01:07:15,359
Directory structure

1627
01:07:15,359 --> 01:07:17,579
on the other hand Windows systems use

1628
01:07:17,579 --> 01:07:20,460
Drive letters where the letter c is

1629
01:07:20,460 --> 01:07:22,500
reserved for the system partition the

1630
01:07:22,500 --> 01:07:25,200
one on which Windows is installed and a

1631
01:07:25,200 --> 01:07:28,440
and b are reserved for floppy drives

1632
01:07:28,440 --> 01:07:31,260
Windows supports a maximum of 26 file

1633
01:07:31,260 --> 01:07:33,299
systems to be mounted at once simply

1634
01:07:33,299 --> 01:07:34,680
because that's the number of letters

1635
01:07:34,680 --> 01:07:37,440
that are available to assigned drives to

1636
01:07:37,440 --> 01:07:39,720
its signed partitions

1637
01:07:39,720 --> 01:07:42,900
so in summary file systems organize data

1638
01:07:42,900 --> 01:07:45,900
store metadata provide an abstraction of

1639
01:07:45,900 --> 01:07:48,000
the underlying storage medium and

1640
01:07:48,000 --> 01:07:50,880
arbitrate access to the storage space

1641
01:07:50,880 --> 01:07:53,039
we create file systems through a process

1642
01:07:53,039 --> 01:07:54,680
known as formatting

1643
01:07:54,680 --> 01:07:57,480
we can make file systems more robust

1644
01:07:57,480 --> 01:07:59,819
against data loss during a power failure

1645
01:07:59,819 --> 01:08:02,819
through the use of journaling

1646
01:08:02,819 --> 01:08:05,220
internally file systems use various

1647
01:08:05,220 --> 01:08:07,140
different mechanisms for laying the data

1648
01:08:07,140 --> 01:08:09,780
out on disk but no matter how they work

1649
01:08:09,780 --> 01:08:12,180
internally we can make them available to

1650
01:08:12,180 --> 01:08:15,299
a running system by mounting them in

1651
01:08:15,299 --> 01:08:16,679
this lecture I'm going to discuss

1652
01:08:16,679 --> 01:08:19,198
requirements analysis

1653
01:08:19,198 --> 01:08:22,140
in particular I'll give an overview of

1654
01:08:22,140 --> 01:08:24,600
different types of projects

1655
01:08:24,600 --> 01:08:27,000
different types of resources that can be

1656
01:08:27,000 --> 01:08:29,160
applied to projects

1657
01:08:29,160 --> 01:08:31,560
talk about the purpose of Performing

1658
01:08:31,560 --> 01:08:33,420
requirements analysis

1659
01:08:33,420 --> 01:08:36,179
discuss stakeholders interests and

1660
01:08:36,179 --> 01:08:37,198
actors

1661
01:08:37,198 --> 01:08:39,000
and talk about the functional and

1662
01:08:39,000 --> 01:08:41,339
non-functional requirements of

1663
01:08:41,339 --> 01:08:43,679
development projects

1664
01:08:43,679 --> 01:08:47,100
software development projects can be

1665
01:08:47,100 --> 01:08:50,399
described as falling into a range in

1666
01:08:50,399 --> 01:08:52,859
between two extremes

1667
01:08:52,859 --> 01:08:54,779
at one extreme we have something called

1668
01:08:54,779 --> 01:08:56,420
a green field project

1669
01:08:56,420 --> 01:08:59,040
and it's called a Greenfield project

1670
01:08:59,040 --> 01:09:02,160
because it's analogous to building a

1671
01:09:02,160 --> 01:09:04,500
building on an empty field start with a

1672
01:09:04,500 --> 01:09:05,880
grassy field

1673
01:09:05,880 --> 01:09:08,399
build everything from scratch

1674
01:09:08,399 --> 01:09:10,799
it's a completely new system

1675
01:09:10,799 --> 01:09:13,020
get to make all the design decisions

1676
01:09:13,020 --> 01:09:15,899
from the ground up there's no existing

1677
01:09:15,899 --> 01:09:17,759
code that has to be merged into the

1678
01:09:17,759 --> 01:09:18,660
system

1679
01:09:18,660 --> 01:09:21,179
and this type of project has the

1680
01:09:21,179 --> 01:09:23,759
potential to be extremely rewarding to

1681
01:09:23,759 --> 01:09:26,279
the people who work on it

1682
01:09:26,279 --> 01:09:28,439
at the opposite extreme we have a

1683
01:09:28,439 --> 01:09:31,020
re-engineering project or a project that

1684
01:09:31,020 --> 01:09:33,299
needs to be re-engineered

1685
01:09:33,299 --> 01:09:36,179
this type of project begins with a pile

1686
01:09:36,179 --> 01:09:39,238
of existing code that lacks any type of

1687
01:09:39,238 --> 01:09:41,520
documentation whatsoever

1688
01:09:41,520 --> 01:09:43,560
the design of the system the

1689
01:09:43,560 --> 01:09:46,500
architecture of the system is an unknown

1690
01:09:46,500 --> 01:09:48,600
and in fact it's necessary to perform

1691
01:09:48,600 --> 01:09:51,960
code analysis to determine how the

1692
01:09:51,960 --> 01:09:54,179
application was designed and how it was

1693
01:09:54,179 --> 01:09:55,739
architected

1694
01:09:55,739 --> 01:09:57,719
this type of project is the greatest

1695
01:09:57,719 --> 01:09:59,880
potential for frustration

1696
01:09:59,880 --> 01:10:03,600
since many older programming paradigms

1697
01:10:03,600 --> 01:10:06,600
did not emphasize making code that was

1698
01:10:06,600 --> 01:10:09,360
easy to untangle

1699
01:10:09,360 --> 01:10:12,120
most projects fall in between these two

1700
01:10:12,120 --> 01:10:13,320
extremes

1701
01:10:13,320 --> 01:10:15,300
there are some projects that fall into

1702
01:10:15,300 --> 01:10:17,640
the Greenfield category there are some

1703
01:10:17,640 --> 01:10:20,100
re-engineering projects however many

1704
01:10:20,100 --> 01:10:21,840
projects are going to land in the middle

1705
01:10:21,840 --> 01:10:25,800
there's going to be some amount of code

1706
01:10:25,800 --> 01:10:28,800
that has to be reused yet there'll be

1707
01:10:28,800 --> 01:10:31,080
some amount of documentation at least

1708
01:10:31,080 --> 01:10:33,739
hopefully

1709
01:10:33,840 --> 01:10:36,540
now regardless of the type of project

1710
01:10:36,540 --> 01:10:39,120
we can utilize several different types

1711
01:10:39,120 --> 01:10:42,179
of resources in the software development

1712
01:10:42,179 --> 01:10:44,159
activities

1713
01:10:44,159 --> 01:10:46,860
of course we begin with people

1714
01:10:46,860 --> 01:10:49,260
we have a number of people who work with

1715
01:10:49,260 --> 01:10:52,199
us on a software development project we

1716
01:10:52,199 --> 01:10:53,699
have software Architects we have

1717
01:10:53,699 --> 01:10:55,679
designers we have developers we have

1718
01:10:55,679 --> 01:10:59,460
programmers we have others one other

1719
01:10:59,460 --> 01:11:01,440
type of person that I didn't put in the

1720
01:11:01,440 --> 01:11:03,540
slides but is important is someone

1721
01:11:03,540 --> 01:11:06,179
called a domain expert that's the type

1722
01:11:06,179 --> 01:11:09,239
of person who knows what types of

1723
01:11:09,239 --> 01:11:11,699
problems the software actually needs to

1724
01:11:11,699 --> 01:11:14,100
solve and what the business rules are

1725
01:11:14,100 --> 01:11:16,860
for that classic problem

1726
01:11:16,860 --> 01:11:19,260
of course we also have money

1727
01:11:19,260 --> 01:11:21,600
and infrastructure infrastructure

1728
01:11:21,600 --> 01:11:22,920
includes things such as computer

1729
01:11:22,920 --> 01:11:26,159
equipment software applications desktop

1730
01:11:26,159 --> 01:11:29,900
environments other computational

1731
01:11:29,900 --> 01:11:33,179
resources that we can utilize in order

1732
01:11:33,179 --> 01:11:35,760
to develop a working solution

1733
01:11:35,760 --> 01:11:37,739
of course given enough money we can

1734
01:11:37,739 --> 01:11:41,580
always purchase additional resources in

1735
01:11:41,580 --> 01:11:43,980
terms of additional infrastructure or

1736
01:11:43,980 --> 01:11:46,340
hire additional programmers Consultants

1737
01:11:46,340 --> 01:11:50,960
others to help with the process

1738
01:11:51,179 --> 01:11:53,640
now the purpose of performing a

1739
01:11:53,640 --> 01:11:56,219
requirements analysis is to make

1740
01:11:56,219 --> 01:11:58,739
effective use of these resources we have

1741
01:11:58,739 --> 01:12:00,239
available to us

1742
01:12:00,239 --> 01:12:02,219
ideally we'd like to keep our

1743
01:12:02,219 --> 01:12:04,199
development staff happy

1744
01:12:04,199 --> 01:12:06,480
we would like to spend our money wisely

1745
01:12:06,480 --> 01:12:09,480
and we'd like to optimize use of the

1746
01:12:09,480 --> 01:12:11,159
infrastructure

1747
01:12:11,159 --> 01:12:14,159
we have the aim of trying to determine

1748
01:12:14,159 --> 01:12:17,100
what exactly needs to be developed so

1749
01:12:17,100 --> 01:12:19,620
that we can build the right product so

1750
01:12:19,620 --> 01:12:22,199
that we can actually make something that

1751
01:12:22,199 --> 01:12:25,380
satisfies the business needs of whoever

1752
01:12:25,380 --> 01:12:28,080
has commissioned the product

1753
01:12:28,080 --> 01:12:30,000
speaking of folks who have an interest

1754
01:12:30,000 --> 01:12:33,060
in the product we can define a few roles

1755
01:12:33,060 --> 01:12:34,860
and relationships for specific

1756
01:12:34,860 --> 01:12:36,659
individuals within a software

1757
01:12:36,659 --> 01:12:39,060
development setting

1758
01:12:39,060 --> 01:12:42,480
one important class of individual is the

1759
01:12:42,480 --> 01:12:43,679
stakeholder

1760
01:12:43,679 --> 01:12:45,719
stakeholders are people or other

1761
01:12:45,719 --> 01:12:49,020
entities such as companies or groups

1762
01:12:49,020 --> 01:12:51,659
that have a vested interest in the

1763
01:12:51,659 --> 01:12:53,580
system under discussion it's often

1764
01:12:53,580 --> 01:12:55,100
called the sud

1765
01:12:55,100 --> 01:12:57,900
stakeholders include the customer the

1766
01:12:57,900 --> 01:12:59,820
development company itself

1767
01:12:59,820 --> 01:13:02,100
users of the system and other direct

1768
01:13:02,100 --> 01:13:04,560
participants in the system

1769
01:13:04,560 --> 01:13:06,840
however stakeholders may also include

1770
01:13:06,840 --> 01:13:09,260
indirect participants in the system

1771
01:13:09,260 --> 01:13:14,100
perhaps another agency or another unit

1772
01:13:14,100 --> 01:13:17,460
of the company is actually funding the

1773
01:13:17,460 --> 01:13:19,260
development work even though they may

1774
01:13:19,260 --> 01:13:22,940
not directly use the resulting products

1775
01:13:22,940 --> 01:13:26,640
these entities have vested interest in

1776
01:13:26,640 --> 01:13:29,460
the outcome of the system because they

1777
01:13:29,460 --> 01:13:32,219
have an investment in the system

1778
01:13:32,219 --> 01:13:35,100
now the interests that one could

1779
01:13:35,100 --> 01:13:38,100
associate with stakeholders are simply

1780
01:13:38,100 --> 01:13:40,679
the expectations that a stakeholder has

1781
01:13:40,679 --> 01:13:43,620
of the system under discussion

1782
01:13:43,620 --> 01:13:45,840
these interests may be of a technical

1783
01:13:45,840 --> 01:13:48,360
nature they could also be of a financial

1784
01:13:48,360 --> 01:13:51,659
nature or even a political nature

1785
01:13:51,659 --> 01:13:54,300
perhaps there's some aspect of the

1786
01:13:54,300 --> 01:13:57,600
system as some political significance to

1787
01:13:57,600 --> 01:13:58,500
someone

1788
01:13:58,500 --> 01:14:01,679
so interests fall into a variety of

1789
01:14:01,679 --> 01:14:04,219
categories

1790
01:14:04,920 --> 01:14:08,640
actors in a system are anything that has

1791
01:14:08,640 --> 01:14:10,800
Behavior

1792
01:14:10,800 --> 01:14:15,300
so this includes both human users and

1793
01:14:15,300 --> 01:14:17,940
other computer systems

1794
01:14:17,940 --> 01:14:20,699
the primary actor in a system is a

1795
01:14:20,699 --> 01:14:22,620
stakeholder that is using the system

1796
01:14:22,620 --> 01:14:25,739
directly to carry out some tasks in

1797
01:14:25,739 --> 01:14:27,719
other words this is the user who sits

1798
01:14:27,719 --> 01:14:30,000
down at the keyboard and actually runs

1799
01:14:30,000 --> 01:14:31,560
the application

1800
01:14:31,560 --> 01:14:34,080
in order to perform some business

1801
01:14:34,080 --> 01:14:36,900
function supporting actors on the other

1802
01:14:36,900 --> 01:14:39,300
hand are other entities upon which the

1803
01:14:39,300 --> 01:14:41,940
system or lies to complete a task

1804
01:14:41,940 --> 01:14:43,860
this could include something such as an

1805
01:14:43,860 --> 01:14:46,500
external database system an external

1806
01:14:46,500 --> 01:14:50,580
printing system some other functionality

1807
01:14:50,580 --> 01:14:52,320
that can be described as having

1808
01:14:52,320 --> 01:14:56,040
behaviors which the system requires in

1809
01:14:56,040 --> 01:14:57,920
order to perform its business functions

1810
01:14:57,920 --> 01:15:00,840
this could even be a person who has to

1811
01:15:00,840 --> 01:15:03,540
go and manually input some type of data

1812
01:15:03,540 --> 01:15:05,699
into the system

1813
01:15:05,699 --> 01:15:09,120
human actors typically require a user

1814
01:15:09,120 --> 01:15:12,719
interface or UI in order to interact the

1815
01:15:12,719 --> 01:15:14,540
system

1816
01:15:14,540 --> 01:15:17,100
computerized actors on the other hand

1817
01:15:17,100 --> 01:15:19,440
typically require something called an

1818
01:15:19,440 --> 01:15:22,440
application programming interface or API

1819
01:15:22,440 --> 01:15:25,980
in order to interact with the system

1820
01:15:25,980 --> 01:15:28,760
now when we're specifying requirements

1821
01:15:28,760 --> 01:15:32,520
and considering what type of actions an

1822
01:15:32,520 --> 01:15:34,800
actor can take with the system

1823
01:15:34,800 --> 01:15:37,620
we can divide the requirements into two

1824
01:15:37,620 --> 01:15:38,820
sets

1825
01:15:38,820 --> 01:15:41,159
the first set of requirements is called

1826
01:15:41,159 --> 01:15:43,380
functional requirements these

1827
01:15:43,380 --> 01:15:45,960
requirements specify what a software

1828
01:15:45,960 --> 01:15:48,060
application does

1829
01:15:48,060 --> 01:15:51,960
in other words given some set of inputs

1830
01:15:51,960 --> 01:15:54,420
this set of requirements should be able

1831
01:15:54,420 --> 01:15:57,000
to tell you what the outputs and side

1832
01:15:57,000 --> 01:15:59,219
effects of the system will be

1833
01:15:59,219 --> 01:16:01,920
for that set of inputs

1834
01:16:01,920 --> 01:16:05,219
this is the design of the software this

1835
01:16:05,219 --> 01:16:08,820
is the low level detail about how the

1836
01:16:08,820 --> 01:16:10,620
software responds to particular

1837
01:16:10,620 --> 01:16:14,480
different types of input

1838
01:16:14,480 --> 01:16:16,620
non-functional requirements on the other

1839
01:16:16,620 --> 01:16:20,159
hand specify what the software is these

1840
01:16:20,159 --> 01:16:22,739
are often called qualities of the

1841
01:16:22,739 --> 01:16:25,440
software an example of this is the

1842
01:16:25,440 --> 01:16:28,080
so-called herps list which includes

1843
01:16:28,080 --> 01:16:30,900
usability reliability performance and

1844
01:16:30,900 --> 01:16:32,280
Sportability

1845
01:16:32,280 --> 01:16:37,260
ISO or IEC 9126 also Define some other

1846
01:16:37,260 --> 01:16:39,179
qualities that a software system may

1847
01:16:39,179 --> 01:16:41,219
have including portability and

1848
01:16:41,219 --> 01:16:43,280
efficiency

1849
01:16:43,280 --> 01:16:45,719
non-functional requirements are embodied

1850
01:16:45,719 --> 01:16:48,360
in the architecture of the software how

1851
01:16:48,360 --> 01:16:51,360
is the software put together to meet

1852
01:16:51,360 --> 01:16:55,199
these quality requirements

1853
01:16:55,199 --> 01:16:56,940
so in summary

1854
01:16:56,940 --> 01:16:59,040
the types of development projects that

1855
01:16:59,040 --> 01:17:01,260
we could be considering vary from the

1856
01:17:01,260 --> 01:17:05,340
extremes of Greenfield to re-engineering

1857
01:17:05,340 --> 01:17:07,380
projects

1858
01:17:07,380 --> 01:17:09,300
these projects are supported by

1859
01:17:09,300 --> 01:17:12,420
resources including people money and

1860
01:17:12,420 --> 01:17:14,219
infrastructure

1861
01:17:14,219 --> 01:17:16,980
each project has stakeholders and each

1862
01:17:16,980 --> 01:17:19,340
stakeholder has interest in the system

1863
01:17:19,340 --> 01:17:22,020
stakeholders who use the system directly

1864
01:17:22,020 --> 01:17:25,620
become primary actors on the system

1865
01:17:25,620 --> 01:17:27,600
and software engineering requirements

1866
01:17:27,600 --> 01:17:30,239
can be classified as functional in other

1867
01:17:30,239 --> 01:17:32,760
words describing how the system works

1868
01:17:32,760 --> 01:17:36,300
what the system does or non-functional

1869
01:17:36,300 --> 01:17:39,120
describing qualities of the system or

1870
01:17:39,120 --> 01:17:42,060
what the system is in this lecture I'm

1871
01:17:42,060 --> 01:17:44,159
going to discuss features of the central

1872
01:17:44,159 --> 01:17:47,460
processing unit or CPU that are useful

1873
01:17:47,460 --> 01:17:49,800
for supporting multiple applications

1874
01:17:49,800 --> 01:17:53,520
sharing a computer system simultaneously

1875
01:17:53,520 --> 01:17:55,260
in particular I'll introduce

1876
01:17:55,260 --> 01:17:57,000
multi-programming and discuss the

1877
01:17:57,000 --> 01:17:58,440
hardware requirements to support

1878
01:17:58,440 --> 01:18:00,179
multi-programming

1879
01:18:00,179 --> 01:18:04,020
I'll discuss CPU privilege amounts x86

1880
01:18:04,020 --> 01:18:07,679
protection Rings mode switches and

1881
01:18:07,679 --> 01:18:10,980
briefly introduce interrupts

1882
01:18:10,980 --> 01:18:13,199
the first concept to introduce is

1883
01:18:13,199 --> 01:18:15,900
multi-programming in multi-programming

1884
01:18:15,900 --> 01:18:17,580
is simply the idea that we can run

1885
01:18:17,580 --> 01:18:20,100
multiple processes or multiple instances

1886
01:18:20,100 --> 01:18:23,040
of potentially several programs at the

1887
01:18:23,040 --> 01:18:24,540
same time

1888
01:18:24,540 --> 01:18:27,239
and we can do this by having the CPU

1889
01:18:27,239 --> 01:18:29,219
switch quickly among the different

1890
01:18:29,219 --> 01:18:32,280
processes enabling all of them to make

1891
01:18:32,280 --> 01:18:34,860
forward progress per unit of human

1892
01:18:34,860 --> 01:18:37,620
perceivable time

1893
01:18:37,620 --> 01:18:40,320
the CPU will switch quickly enough to

1894
01:18:40,320 --> 01:18:42,239
provide the illusion that all the

1895
01:18:42,239 --> 01:18:44,100
processes are running at the same time

1896
01:18:44,100 --> 01:18:48,480
even if we only have one processor core

1897
01:18:48,480 --> 01:18:51,000
in the vast majority of modern Computing

1898
01:18:51,000 --> 01:18:52,860
systems with the exception of some

1899
01:18:52,860 --> 01:18:55,219
special purpose systems are

1900
01:18:55,219 --> 01:18:57,620
multi-programming system

1901
01:18:57,620 --> 01:19:01,440
some of the old computer systems of the

1902
01:19:01,440 --> 01:19:04,380
day were batch systems that only ran one

1903
01:19:04,380 --> 01:19:08,520
sys one application at a time

1904
01:19:08,520 --> 01:19:09,860
now in order to support

1905
01:19:09,860 --> 01:19:12,000
multi-programming we have to have

1906
01:19:12,000 --> 01:19:14,100
certain features of our computer

1907
01:19:14,100 --> 01:19:15,960
hardware

1908
01:19:15,960 --> 01:19:18,179
first of these is an interrupt mechanism

1909
01:19:18,179 --> 01:19:19,980
for enabling preemption of running

1910
01:19:19,980 --> 01:19:22,260
processes whenever some kind of event

1911
01:19:22,260 --> 01:19:25,560
occurs we have to have a way of stopping

1912
01:19:25,560 --> 01:19:28,020
a process handling an event and then

1913
01:19:28,020 --> 01:19:29,940
restarting the process

1914
01:19:29,940 --> 01:19:31,980
we need to have a clock so that we know

1915
01:19:31,980 --> 01:19:34,260
how long the process has been running

1916
01:19:34,260 --> 01:19:36,360
and we need to have CPU protection

1917
01:19:36,360 --> 01:19:38,760
levels to restrict access to certain

1918
01:19:38,760 --> 01:19:41,340
instructions to prevent processes from

1919
01:19:41,340 --> 01:19:43,620
hijacking the system or just trying to

1920
01:19:43,620 --> 01:19:46,080
bypass the operating system altogether

1921
01:19:46,080 --> 01:19:48,179
we also need to restrict access to

1922
01:19:48,179 --> 01:19:50,340
memory in order to prevent reading and

1923
01:19:50,340 --> 01:19:52,500
writing to memory that a particular

1924
01:19:52,500 --> 01:19:54,719
process does not own belongs to somebody

1925
01:19:54,719 --> 01:19:56,340
else

1926
01:19:56,340 --> 01:19:59,400
two CPU protection levels are sufficient

1927
01:19:59,400 --> 01:20:03,679
a protected mode and a privileged mode

1928
01:20:03,840 --> 01:20:06,060
these modes are also called the

1929
01:20:06,060 --> 01:20:08,880
supervisor mode or kernel mode and user

1930
01:20:08,880 --> 01:20:09,960
mode

1931
01:20:09,960 --> 01:20:11,520
in kernel mode

1932
01:20:11,520 --> 01:20:15,179
all instructions on the CPU are enabled

1933
01:20:15,179 --> 01:20:18,120
and the kernel can access all memory on

1934
01:20:18,120 --> 01:20:19,679
the system

1935
01:20:19,679 --> 01:20:22,980
in user mode the CPU disables all the

1936
01:20:22,980 --> 01:20:25,380
privileged instructions and restricts

1937
01:20:25,380 --> 01:20:28,620
most direct memory operations thus a

1938
01:20:28,620 --> 01:20:30,900
user program must make a system call to

1939
01:20:30,900 --> 01:20:33,360
the operating system to request memory

1940
01:20:33,360 --> 01:20:35,699
or perform other resource allocation

1941
01:20:35,699 --> 01:20:37,140
tasks

1942
01:20:37,140 --> 01:20:39,900
in this way the user processes are

1943
01:20:39,900 --> 01:20:42,780
effectively sandboxed both from the

1944
01:20:42,780 --> 01:20:45,900
system and from each other

1945
01:20:45,900 --> 01:20:50,340
on the Intel based systems x86 and x8664

1946
01:20:50,340 --> 01:20:53,219
systems there are actually Four modes

1947
01:20:53,219 --> 01:20:54,600
available

1948
01:20:54,600 --> 01:20:56,820
these are implemented by what are known

1949
01:20:56,820 --> 01:21:00,420
as x86 protection Rings which consist of

1950
01:21:00,420 --> 01:21:02,580
four privileged levels numbered zero

1951
01:21:02,580 --> 01:21:03,960
through three

1952
01:21:03,960 --> 01:21:06,239
rating 0 has the greatest number of

1953
01:21:06,239 --> 01:21:07,800
privileges

1954
01:21:07,800 --> 01:21:11,699
code executing in ring 0 can execute any

1955
01:21:11,699 --> 01:21:14,520
instruction the CPU provides and can

1956
01:21:14,520 --> 01:21:16,500
access all memory

1957
01:21:16,500 --> 01:21:20,460
ring 3 has the fewest privileges all the

1958
01:21:20,460 --> 01:21:22,679
instructions are restricted to the set

1959
01:21:22,679 --> 01:21:25,440
of instructions that are relatively safe

1960
01:21:25,440 --> 01:21:27,900
in practice most operating systems

1961
01:21:27,900 --> 01:21:32,040
actually only use ring 0 and 3. os2 and

1962
01:21:32,040 --> 01:21:34,980
Zen are the notable exceptions that make

1963
01:21:34,980 --> 01:21:37,620
use of ring 1.

1964
01:21:37,620 --> 01:21:39,900
newer systems

1965
01:21:39,900 --> 01:21:43,020
with virtualization extensions either

1966
01:21:43,020 --> 01:21:46,739
the Intel VTX extensions or the amdb

1967
01:21:46,739 --> 01:21:49,800
extensions add an extra privilege level

1968
01:21:49,800 --> 01:21:53,040
below ring zero this is colloquially

1969
01:21:53,040 --> 01:21:55,320
sometimes referred to as ring negative

1970
01:21:55,320 --> 01:21:56,760
one

1971
01:21:56,760 --> 01:22:00,000
and this mode enables instructions that

1972
01:22:00,000 --> 01:22:02,159
allow multiple operating systems to

1973
01:22:02,159 --> 01:22:04,679
share the same processor these

1974
01:22:04,679 --> 01:22:06,300
instructions help

1975
01:22:06,300 --> 01:22:09,480
system support posting multiple virtual

1976
01:22:09,480 --> 01:22:12,800
machines at the same time

1977
01:22:12,900 --> 01:22:14,820
now regardless of the number of modes

1978
01:22:14,820 --> 01:22:17,280
available whenever we wish to change

1979
01:22:17,280 --> 01:22:19,500
modes for whatever reason we have to

1980
01:22:19,500 --> 01:22:21,120
perform something called a mode switch

1981
01:22:21,120 --> 01:22:24,000
and that occurs whenever the CPU

1982
01:22:24,000 --> 01:22:27,540
switches into user mode kernel mode or

1983
01:22:27,540 --> 01:22:31,820
hypervisor mode or whenever an x86 CPU

1984
01:22:31,820 --> 01:22:35,400
changes which protection ring is

1985
01:22:35,400 --> 01:22:37,560
presently effective

1986
01:22:37,560 --> 01:22:39,840
mode switches have the potential to be

1987
01:22:39,840 --> 01:22:41,820
slow operations compared to other

1988
01:22:41,820 --> 01:22:44,219
machine instructions depending upon the

1989
01:22:44,219 --> 01:22:45,239
hardware

1990
01:22:45,239 --> 01:22:47,340
a notable example was the first

1991
01:22:47,340 --> 01:22:49,679
generation of Intel Core 2 Series

1992
01:22:49,679 --> 01:22:52,560
processors in which the mode switches

1993
01:22:52,560 --> 01:22:55,199
into and out of hypervisor mode were

1994
01:22:55,199 --> 01:22:57,739
quite slow

1995
01:22:58,520 --> 01:23:01,679
one situation in which a mode switch

1996
01:23:01,679 --> 01:23:04,380
might occur is when something called an

1997
01:23:04,380 --> 01:23:06,179
interrupt happens

1998
01:23:06,179 --> 01:23:09,540
in an interrupt is simply a situation in

1999
01:23:09,540 --> 01:23:11,880
which the currently executing code is

2000
01:23:11,880 --> 01:23:14,760
interrupted so that an event can be

2001
01:23:14,760 --> 01:23:17,460
handled by the operating system

2002
01:23:17,460 --> 01:23:19,199
interrupts could fall into two

2003
01:23:19,199 --> 01:23:21,179
categories we can have involuntary

2004
01:23:21,179 --> 01:23:23,580
interrupts which are external to running

2005
01:23:23,580 --> 01:23:25,080
processes

2006
01:23:25,080 --> 01:23:27,300
these consist of things such as I O

2007
01:23:27,300 --> 01:23:28,980
interrupts which are generated every

2008
01:23:28,980 --> 01:23:30,480
time you press the key on the keyboard

2009
01:23:30,480 --> 01:23:34,380
or perform any other i o test

2010
01:23:34,380 --> 01:23:36,780
clock interrupts which are timer

2011
01:23:36,780 --> 01:23:39,420
mechanisms that can be scheduled to go

2012
01:23:39,420 --> 01:23:41,460
off at a particular time

2013
01:23:41,460 --> 01:23:43,800
and Page faults which have to do with

2014
01:23:43,800 --> 01:23:46,560
the virtual memory subsystem

2015
01:23:46,560 --> 01:23:49,140
interrupts can also be voluntary in

2016
01:23:49,140 --> 01:23:51,540
other words created by a process that's

2017
01:23:51,540 --> 01:23:52,620
running

2018
01:23:52,620 --> 01:23:55,500
system calls and exceptions such as said

2019
01:23:55,500 --> 01:23:59,159
fault or divide by zero actions can

2020
01:23:59,159 --> 01:24:01,980
result in interrupts as well

2021
01:24:01,980 --> 01:24:04,980
and the CPU provides Hardware mechanisms

2022
01:24:04,980 --> 01:24:07,380
for detecting when an interrupt is

2023
01:24:07,380 --> 01:24:11,159
occurring and handling the interrupt

2024
01:24:11,159 --> 01:24:13,620
so in summary multi-programming systems

2025
01:24:13,620 --> 01:24:15,480
allow multiple applications to run

2026
01:24:15,480 --> 01:24:17,040
simultaneously

2027
01:24:17,040 --> 01:24:19,560
implementing multi-programming reports

2028
01:24:19,560 --> 01:24:22,440
requires support from the hardware in

2029
01:24:22,440 --> 01:24:24,480
particular we need CPU privileges we

2030
01:24:24,480 --> 01:24:25,980
need a clock and we need some kind of

2031
01:24:25,980 --> 01:24:28,500
interrupt handling mechanism

2032
01:24:28,500 --> 01:24:31,320
CPUs used in multi-programming systems

2033
01:24:31,320 --> 01:24:32,940
need to have at least two privileged

2034
01:24:32,940 --> 01:24:36,780
modes Intel x86 Systems Support four or

2035
01:24:36,780 --> 01:24:39,540
five modes depending on the processor

2036
01:24:39,540 --> 01:24:42,120
mode switches can be expensive in terms

2037
01:24:42,120 --> 01:24:43,860
of performance so we don't want to do

2038
01:24:43,860 --> 01:24:46,620
them more than necessary and interrupts

2039
01:24:46,620 --> 01:24:48,719
enable Hardware events to be delivered

2040
01:24:48,719 --> 01:24:50,940
to applications and they allow

2041
01:24:50,940 --> 01:24:52,920
applications to yield control of the

2042
01:24:52,920 --> 01:24:54,900
system while waiting for events or

2043
01:24:54,900 --> 01:24:56,880
waiting for service in this lecture I'm

2044
01:24:56,880 --> 01:24:59,640
going to discuss kernel architectures

2045
01:24:59,640 --> 01:25:01,800
I'll begin by introducing the functions

2046
01:25:01,800 --> 01:25:03,179
of the kernel

2047
01:25:03,179 --> 01:25:05,580
explain the separation between mechanism

2048
01:25:05,580 --> 01:25:06,900
and policy

2049
01:25:06,900 --> 01:25:09,540
talk about some seminal early kernels in

2050
01:25:09,540 --> 01:25:11,340
the history of computing

2051
01:25:11,340 --> 01:25:13,380
and then introduce the differences

2052
01:25:13,380 --> 01:25:15,360
between monolithic kernels and micro

2053
01:25:15,360 --> 01:25:17,760
kernels

2054
01:25:17,760 --> 01:25:20,280
the kernel provides two functions the

2055
01:25:20,280 --> 01:25:21,960
same two functions is in the operating

2056
01:25:21,960 --> 01:25:24,300
system it provides abstraction and

2057
01:25:24,300 --> 01:25:25,739
arbitration

2058
01:25:25,739 --> 01:25:28,199
the kernel provides abstraction in the

2059
01:25:28,199 --> 01:25:30,840
sense that it provides a mechanism for

2060
01:25:30,840 --> 01:25:33,300
programs to access Hardware

2061
01:25:33,300 --> 01:25:35,880
a way to schedule multiple multiple

2062
01:25:35,880 --> 01:25:38,760
programs on the system

2063
01:25:38,760 --> 01:25:41,100
and it provides some method for

2064
01:25:41,100 --> 01:25:44,460
inter-process communication or IPC a way

2065
01:25:44,460 --> 01:25:46,560
for programs to send messages to each

2066
01:25:46,560 --> 01:25:48,540
other or send messages to Hardware

2067
01:25:48,540 --> 01:25:52,460
devices or out to the network

2068
01:25:52,739 --> 01:25:55,140
kernels also provide abstraction

2069
01:25:55,140 --> 01:25:57,780
mechanisms they ensure that a single

2070
01:25:57,780 --> 01:26:00,360
process or running program can't take

2071
01:26:00,360 --> 01:26:02,280
over the entire system

2072
01:26:02,280 --> 01:26:04,020
enforce any kind of security

2073
01:26:04,020 --> 01:26:06,420
requirements such as access privileges

2074
01:26:06,420 --> 01:26:08,639
that might be in place on the system

2075
01:26:08,639 --> 01:26:10,860
and they minimize the risk of a total

2076
01:26:10,860 --> 01:26:13,560
system Crash from a buggy application or

2077
01:26:13,560 --> 01:26:16,080
device driver

2078
01:26:16,080 --> 01:26:18,420
it's important to distinguish between

2079
01:26:18,420 --> 01:26:21,420
mechanism and policy when discussing the

2080
01:26:21,420 --> 01:26:22,860
internal components of an operating

2081
01:26:22,860 --> 01:26:24,239
system

2082
01:26:24,239 --> 01:26:27,780
the mechanism put simply is the software

2083
01:26:27,780 --> 01:26:30,060
methods that enable operations to be

2084
01:26:30,060 --> 01:26:31,440
carried out

2085
01:26:31,440 --> 01:26:34,560
an example of a mechanism would be code

2086
01:26:34,560 --> 01:26:37,400
that implemented inside a device driver

2087
01:26:37,400 --> 01:26:40,199
sends a message to a device that causes

2088
01:26:40,199 --> 01:26:42,960
that device to Blink a light enable a

2089
01:26:42,960 --> 01:26:45,000
camera or perform some other Hardware

2090
01:26:45,000 --> 01:26:47,400
level operation

2091
01:26:47,400 --> 01:26:49,679
policy on the other hand is a set of

2092
01:26:49,679 --> 01:26:51,179
software methods that enforce

2093
01:26:51,179 --> 01:26:54,179
permissions access roles or other limits

2094
01:26:54,179 --> 01:26:57,780
against applications so a policy for

2095
01:26:57,780 --> 01:27:00,540
example would be something that said

2096
01:27:00,540 --> 01:27:03,780
that only users who met certain criteria

2097
01:27:03,780 --> 01:27:06,000
could send a message out to a hardware

2098
01:27:06,000 --> 01:27:09,120
device to Blink a light or enable a

2099
01:27:09,120 --> 01:27:10,739
camera or perform some other Hardware

2100
01:27:10,739 --> 01:27:12,120
function

2101
01:27:12,120 --> 01:27:14,639
it's a generally accepted principle of

2102
01:27:14,639 --> 01:27:17,159
good design with mechanism and policy

2103
01:27:17,159 --> 01:27:20,699
should be separated as much as possible

2104
01:27:20,699 --> 01:27:24,060
an early kernel that separated mechanism

2105
01:27:24,060 --> 01:27:27,120
and policy quite well was the regna

2106
01:27:27,120 --> 01:27:30,900
centralin RC 4000 monitor kernel

2107
01:27:30,900 --> 01:27:33,500
this kernel was developed in 1969

2108
01:27:33,500 --> 01:27:37,320
primarily by Perry Brink Hanson for the

2109
01:27:37,320 --> 01:27:40,020
regna Central and rc4000 computer system

2110
01:27:40,020 --> 01:27:42,420
this was a computer system that was

2111
01:27:42,420 --> 01:27:45,480
developed in Denmark

2112
01:27:45,480 --> 01:27:47,699
and the central component of the system

2113
01:27:47,699 --> 01:27:50,639
was a small nucleus as brinkansen called

2114
01:27:50,639 --> 01:27:52,800
it called monitor

2115
01:27:52,800 --> 01:27:55,020
which allowed programs to send messages

2116
01:27:55,020 --> 01:27:58,020
to each other and allowed programs to

2117
01:27:58,020 --> 01:28:00,560
send and receive buffers which were

2118
01:28:00,560 --> 01:28:03,780
essentially types of messages for

2119
01:28:03,780 --> 01:28:06,300
Hardware to and from different Hardware

2120
01:28:06,300 --> 01:28:09,360
devices in particular at that time they

2121
01:28:09,360 --> 01:28:13,679
had a card reader a tape reader and a

2122
01:28:13,679 --> 01:28:17,760
printing style output device

2123
01:28:17,760 --> 01:28:20,520
other kernels with different scheduling

2124
01:28:20,520 --> 01:28:22,679
mechanisms and other capabilities could

2125
01:28:22,679 --> 01:28:25,860
be run under monitor in those days it

2126
01:28:25,860 --> 01:28:28,560
was not clear that multi-programming was

2127
01:28:28,560 --> 01:28:31,080
really a desirable feature for computing

2128
01:28:31,080 --> 01:28:33,360
thus someone could write a

2129
01:28:33,360 --> 01:28:35,820
multi-programming capable kernel and

2130
01:28:35,820 --> 01:28:38,520
actually run that as a sub kernel under

2131
01:28:38,520 --> 01:28:40,199
the monitor system

2132
01:28:40,199 --> 01:28:42,480
importantly this was also the first

2133
01:28:42,480 --> 01:28:45,060
system that allowed sub kernels and

2134
01:28:45,060 --> 01:28:47,100
systems level software to be written in

2135
01:28:47,100 --> 01:28:49,380
a high-level language in this case

2136
01:28:49,380 --> 01:28:52,139
Pascal

2137
01:28:52,139 --> 01:28:54,179
the system performance was actually

2138
01:28:54,179 --> 01:28:57,540
quite awful Brink Hansen stated that the

2139
01:28:57,540 --> 01:29:00,960
operating system itself was so slow at

2140
01:29:00,960 --> 01:29:04,800
performing its IPC tasks that there were

2141
01:29:04,800 --> 01:29:07,219
a number of issues with the system

2142
01:29:07,219 --> 01:29:09,900
completing tasks on time

2143
01:29:09,900 --> 01:29:12,360
however the system was stable and

2144
01:29:12,360 --> 01:29:14,159
reliable

2145
01:29:14,159 --> 01:29:16,560
making it successful in computer science

2146
01:29:16,560 --> 01:29:19,560
history even if it was not a successful

2147
01:29:19,560 --> 01:29:22,699
product commercially

2148
01:29:23,400 --> 01:29:25,620
on the other hand the opposite extreme

2149
01:29:25,620 --> 01:29:28,139
would be the Unix kernel this was

2150
01:29:28,139 --> 01:29:30,540
developed at Bell Labs by a team headed

2151
01:29:30,540 --> 01:29:33,420
by Ken Thompson and Dennis Ritchie also

2152
01:29:33,420 --> 01:29:35,880
starting in the late 1960s

2153
01:29:35,880 --> 01:29:38,040
the difference between the Unix kernel

2154
01:29:38,040 --> 01:29:41,639
and the rc4000 monitor was that the Unix

2155
01:29:41,639 --> 01:29:44,639
Kernel's design implemented performance

2156
01:29:44,639 --> 01:29:47,940
thus instead of having a very small

2157
01:29:47,940 --> 01:29:50,520
kernel that simply provided an IPC

2158
01:29:50,520 --> 01:29:53,900
mechanism and some basic resource

2159
01:29:53,900 --> 01:29:56,340
collision avoidance

2160
01:29:56,340 --> 01:29:58,920
this kernel actually provided all the

2161
01:29:58,920 --> 01:30:01,320
device drivers all the scheduling all

2162
01:30:01,320 --> 01:30:02,780
the memory management

2163
01:30:02,780 --> 01:30:05,480
including support for multi-programming

2164
01:30:05,480 --> 01:30:08,699
directly inside the kernel

2165
01:30:08,699 --> 01:30:11,159
this kernel was an early example of what

2166
01:30:11,159 --> 01:30:13,080
would later be called a monolithic

2167
01:30:13,080 --> 01:30:16,080
kernel a monolithic kernel is a kernel

2168
01:30:16,080 --> 01:30:17,880
that contains the entire operating

2169
01:30:17,880 --> 01:30:19,920
system in kernel space

2170
01:30:19,920 --> 01:30:22,860
runs all of the operating system code in

2171
01:30:22,860 --> 01:30:26,040
privileged mode or ring 0 on an x86

2172
01:30:26,040 --> 01:30:27,060
system

2173
01:30:27,060 --> 01:30:30,659
and divides the different functions of

2174
01:30:30,659 --> 01:30:33,239
the operating system into subsystems of

2175
01:30:33,239 --> 01:30:34,440
the kernel

2176
01:30:34,440 --> 01:30:37,199
all of these subsystems however are run

2177
01:30:37,199 --> 01:30:39,960
in the same memory space

2178
01:30:39,960 --> 01:30:42,120
this has the advantage of higher

2179
01:30:42,120 --> 01:30:44,100
performance

2180
01:30:44,100 --> 01:30:47,280
but the disadvantage is that the kernel

2181
01:30:47,280 --> 01:30:49,260
becomes less modular and more difficult

2182
01:30:49,260 --> 01:30:51,900
to maintain and the components are not

2183
01:30:51,900 --> 01:30:55,020
separated very well so a crash in one

2184
01:30:55,020 --> 01:30:57,300
component could in fact bring down the

2185
01:30:57,300 --> 01:30:58,980
entire system

2186
01:30:58,980 --> 01:31:02,040
the opposite of this the rc4000 style

2187
01:31:02,040 --> 01:31:04,440
kernel is what we now call a micro

2188
01:31:04,440 --> 01:31:07,020
kernel in a micro kernel basically

2189
01:31:07,020 --> 01:31:09,840
contains the bare minimum of code is

2190
01:31:09,840 --> 01:31:13,020
necessary in order to implement basic

2191
01:31:13,020 --> 01:31:15,480
addressing inter-process Communications

2192
01:31:15,480 --> 01:31:17,940
and scheduling

2193
01:31:17,940 --> 01:31:20,880
this basic amount of code runs in kernel

2194
01:31:20,880 --> 01:31:24,600
space and everything else runs in user

2195
01:31:24,600 --> 01:31:25,560
space

2196
01:31:25,560 --> 01:31:28,380
often with lower privileges

2197
01:31:28,380 --> 01:31:31,380
as a general rule of thumb micro kernels

2198
01:31:31,380 --> 01:31:35,280
contain less than 10 000 lines of code

2199
01:31:35,280 --> 01:31:37,860
micro kernel based operating systems

2200
01:31:37,860 --> 01:31:40,560
tend to be quite modular because they

2201
01:31:40,560 --> 01:31:42,659
divide the operating system functions

2202
01:31:42,659 --> 01:31:46,199
between the kernel and a set of servers

2203
01:31:46,199 --> 01:31:48,540
that run in user space

2204
01:31:48,540 --> 01:31:51,179
however because many of the core

2205
01:31:51,179 --> 01:31:53,040
functions of the operating system are

2206
01:31:53,040 --> 01:31:55,739
performed by user space components which

2207
01:31:55,739 --> 01:31:57,719
have to communicate with each other via

2208
01:31:57,719 --> 01:31:58,860
the kernel

2209
01:31:58,860 --> 01:32:01,860
performance does suffer

2210
01:32:01,860 --> 01:32:04,500
thus most kernels they're in use today

2211
01:32:04,500 --> 01:32:08,400
are a hybrid of these two designs

2212
01:32:08,400 --> 01:32:10,800
I'm going to introduce Murphy's Law of

2213
01:32:10,800 --> 01:32:13,320
reality sort of an extension of the

2214
01:32:13,320 --> 01:32:15,060
Murphy's laws with which you may be

2215
01:32:15,060 --> 01:32:16,260
familiar

2216
01:32:16,260 --> 01:32:18,960
and by definition of Murphy's Law of

2217
01:32:18,960 --> 01:32:21,540
reality is simply that reality is the

2218
01:32:21,540 --> 01:32:23,639
hazy space between the extremes of

2219
01:32:23,639 --> 01:32:26,040
competing academic theories in which

2220
01:32:26,040 --> 01:32:28,260
everything is wrong in some way at least

2221
01:32:28,260 --> 01:32:31,020
according to the theories

2222
01:32:31,020 --> 01:32:33,060
this idea of a hybrid kernel

2223
01:32:33,060 --> 01:32:36,120
architecture is a controversial one some

2224
01:32:36,120 --> 01:32:37,679
people do not like to use this

2225
01:32:37,679 --> 01:32:40,020
terminology at all

2226
01:32:40,020 --> 01:32:42,600
many people prefer to keep the binary

2227
01:32:42,600 --> 01:32:45,179
classification of Monolithic kernel and

2228
01:32:45,179 --> 01:32:46,440
micro kernel

2229
01:32:46,440 --> 01:32:49,440
however if we look at modern kernels

2230
01:32:49,440 --> 01:32:51,719
typically the monolithic versions of

2231
01:32:51,719 --> 01:32:54,179
modern kernels are broken into modules

2232
01:32:54,179 --> 01:32:56,460
that can be loaded and unloaded at

2233
01:32:56,460 --> 01:32:58,679
runtime this helps to increase

2234
01:32:58,679 --> 01:33:01,199
maintainability of the kernel

2235
01:33:01,199 --> 01:33:03,900
and true micro kernels today would have

2236
01:33:03,900 --> 01:33:06,480
unacceptable performance thus micro

2237
01:33:06,480 --> 01:33:09,480
kernel based systems typically have some

2238
01:33:09,480 --> 01:33:11,400
of the features of Monolithic kernels

2239
01:33:11,400 --> 01:33:13,739
such as more device drivers and other

2240
01:33:13,739 --> 01:33:16,199
code that runs inside the Kernel's

2241
01:33:16,199 --> 01:33:18,540
memory space

2242
01:33:18,540 --> 01:33:21,060
some examples of different types of

2243
01:33:21,060 --> 01:33:23,940
kernels for monolithic kernels in

2244
01:33:23,940 --> 01:33:26,040
addition to the system 5 units kernel

2245
01:33:26,040 --> 01:33:27,420
which is a descendant from the original

2246
01:33:27,420 --> 01:33:30,060
units kernel we have the Linux kernel

2247
01:33:30,060 --> 01:33:34,800
BSD MS-DOS and windows 9x kernels

2248
01:33:34,800 --> 01:33:39,000
Windows NT XP Vista and seven if you

2249
01:33:39,000 --> 01:33:40,560
don't prefer to use the hybrid

2250
01:33:40,560 --> 01:33:43,080
terminology would also qualify as

2251
01:33:43,080 --> 01:33:46,139
monolithic minerals and the Mac OS 10

2252
01:33:46,139 --> 01:33:49,560
kernel falls into the same category

2253
01:33:49,560 --> 01:33:52,620
terms of micro kernels the rc4000

2254
01:33:52,620 --> 01:33:54,120
monitor kernel would have been the

2255
01:33:54,120 --> 01:33:56,219
earliest however there have been plenty

2256
01:33:56,219 --> 01:34:00,139
other examples including mock L4 the MIT

2257
01:34:00,139 --> 01:34:04,320
exokernel project and the idea at least

2258
01:34:04,320 --> 01:34:07,020
behind the Windows NT kernel which was

2259
01:34:07,020 --> 01:34:09,659
based upon a micro kernel design the

2260
01:34:09,659 --> 01:34:12,179
same is true of the Mac OS 10 kernel

2261
01:34:12,179 --> 01:34:14,159
since that was originally based on the

2262
01:34:14,159 --> 01:34:16,620
mock micro kernel however those have

2263
01:34:16,620 --> 01:34:19,020
been heavily modified and now have many

2264
01:34:19,020 --> 01:34:23,100
properties of Monolithic kernels also

2265
01:34:23,100 --> 01:34:24,780
so in summary

2266
01:34:24,780 --> 01:34:27,360
the kernel is the minimum layer of

2267
01:34:27,360 --> 01:34:29,219
software inside the operating system

2268
01:34:29,219 --> 01:34:31,380
that provides the basic foundations for

2269
01:34:31,380 --> 01:34:33,120
abstracting away details of the hardware

2270
01:34:33,120 --> 01:34:35,880
and arbitrating between multiple

2271
01:34:35,880 --> 01:34:37,199
applications

2272
01:34:37,199 --> 01:34:40,400
when the bearer absolute bare minimum

2273
01:34:40,400 --> 01:34:42,900
implementations are used we call the

2274
01:34:42,900 --> 01:34:46,020
result a micro kernel

2275
01:34:46,020 --> 01:34:47,880
monolithic kernels on the other hand

2276
01:34:47,880 --> 01:34:50,040
have all their major OS components

2277
01:34:50,040 --> 01:34:51,780
contained within them

2278
01:34:51,780 --> 01:34:53,940
running everything inside kernel space

2279
01:34:53,940 --> 01:34:56,639
to improve performance

2280
01:34:56,639 --> 01:34:59,159
two early influential kernels were the

2281
01:34:59,159 --> 01:35:01,860
rc4000 monitor an example of a micro

2282
01:35:01,860 --> 01:35:04,380
kernel and the original Unix terminal

2283
01:35:04,380 --> 01:35:06,179
which was an example of a monolithic

2284
01:35:06,179 --> 01:35:07,320
kernel

2285
01:35:07,320 --> 01:35:10,320
in practice however most modern

2286
01:35:10,320 --> 01:35:12,659
operating system kernels are hybrids of

2287
01:35:12,659 --> 01:35:15,060
the two designs and have features of

2288
01:35:15,060 --> 01:35:17,280
both kernel type in this lecture I'm

2289
01:35:17,280 --> 01:35:19,500
going to introduce the unified modeling

2290
01:35:19,500 --> 01:35:20,460
language

2291
01:35:20,460 --> 01:35:22,320
uml

2292
01:35:22,320 --> 01:35:25,139
I'll be discussing software modeling

2293
01:35:25,139 --> 01:35:27,300
introduce uml

2294
01:35:27,300 --> 01:35:30,000
talk about some of its limitations

2295
01:35:30,000 --> 01:35:33,000
discuss a few of its diagram types

2296
01:35:33,000 --> 01:35:35,400
discuss the role of uml and software

2297
01:35:35,400 --> 01:35:40,400
engineering and mention a few case tools

2298
01:35:40,620 --> 01:35:43,320
in software systems especially complex

2299
01:35:43,320 --> 01:35:46,679
software systems it's useful to be able

2300
01:35:46,679 --> 01:35:49,380
to present a design to other Developers

2301
01:35:49,380 --> 01:35:52,080
for discussion during the development

2302
01:35:52,080 --> 01:35:53,940
process

2303
01:35:53,940 --> 01:35:56,400
complex software systems need to be

2304
01:35:56,400 --> 01:35:58,139
designed before they can be constructed

2305
01:35:58,139 --> 01:36:01,020
or modified anyway and it's helpful to

2306
01:36:01,020 --> 01:36:04,080
keep design documentation on hand so

2307
01:36:04,080 --> 01:36:06,000
that the system can be modified more

2308
01:36:06,000 --> 01:36:08,780
easily later

2309
01:36:08,940 --> 01:36:11,219
in order to communicate with other

2310
01:36:11,219 --> 01:36:13,800
developers and other stakeholders in the

2311
01:36:13,800 --> 01:36:14,699
system

2312
01:36:14,699 --> 01:36:18,900
it's helpful to have some analog to a

2313
01:36:18,900 --> 01:36:21,060
contractor's blueprint

2314
01:36:21,060 --> 01:36:23,280
consider for example in the real world

2315
01:36:23,280 --> 01:36:25,380
building a large building such as a

2316
01:36:25,380 --> 01:36:26,520
hospital

2317
01:36:26,520 --> 01:36:28,560
first an architect will come up with a

2318
01:36:28,560 --> 01:36:30,780
high level design for the project

2319
01:36:30,780 --> 01:36:33,000
Engineers will Design the individual

2320
01:36:33,000 --> 01:36:34,920
components and ensure that the hospital

2321
01:36:34,920 --> 01:36:38,159
will meet all codes and remain standing

2322
01:36:38,159 --> 01:36:39,960
and operational

2323
01:36:39,960 --> 01:36:42,060
and then during construction the designs

2324
01:36:42,060 --> 01:36:44,400
get updated slightly to account for

2325
01:36:44,400 --> 01:36:46,080
changes in any problems that are

2326
01:36:46,080 --> 01:36:47,040
encountered during the construction

2327
01:36:47,040 --> 01:36:48,659
phase

2328
01:36:48,659 --> 01:36:50,940
after construction the blueprints are

2329
01:36:50,940 --> 01:36:53,040
retained in case an addition is needed

2330
01:36:53,040 --> 01:36:55,320
later or in case modifications are

2331
01:36:55,320 --> 01:36:57,360
needed to the building

2332
01:36:57,360 --> 01:37:00,000
unified modeling language provides an

2333
01:37:00,000 --> 01:37:03,719
option for software Engineers to have

2334
01:37:03,719 --> 01:37:06,900
similar design documentation for

2335
01:37:06,900 --> 01:37:09,239
software projects

2336
01:37:09,239 --> 01:37:11,040
and in the early days of software

2337
01:37:11,040 --> 01:37:13,980
engineering diagrams were drawn using a

2338
01:37:13,980 --> 01:37:16,380
wide variety of different formats with

2339
01:37:16,380 --> 01:37:18,239
different symbols different connectors

2340
01:37:18,239 --> 01:37:20,820
different annotations and so forth

2341
01:37:20,820 --> 01:37:23,100
and developers moving between companies

2342
01:37:23,100 --> 01:37:25,580
or trying to collaborate across company

2343
01:37:25,580 --> 01:37:28,620
or even divisional boundaries within a

2344
01:37:28,620 --> 01:37:30,840
company had to be trained on each

2345
01:37:30,840 --> 01:37:33,780
specific format that was being used for

2346
01:37:33,780 --> 01:37:35,880
the communication

2347
01:37:35,880 --> 01:37:38,040
the idea behind unified modeling

2348
01:37:38,040 --> 01:37:40,460
language was to provide a single

2349
01:37:40,460 --> 01:37:42,719
standardized formatting in a

2350
01:37:42,719 --> 01:37:45,120
standardized set of symbols in order to

2351
01:37:45,120 --> 01:37:47,340
create a Common Language and the group

2352
01:37:47,340 --> 01:37:49,980
of folks that did this were Grady booch

2353
01:37:49,980 --> 01:37:53,460
Ivar Jacobson and Jim Rumba at rational

2354
01:37:53,460 --> 01:37:55,800
software corporation which was later

2355
01:37:55,800 --> 01:37:59,060
purchased by IBM

2356
01:37:59,280 --> 01:38:02,159
UMO was standardized by the object

2357
01:38:02,159 --> 01:38:03,780
Management Group

2358
01:38:03,780 --> 01:38:05,940
but the standards are not always

2359
01:38:05,940 --> 01:38:09,060
followed by uml tools and in particular

2360
01:38:09,060 --> 01:38:11,760
with the latest version of uml there is

2361
01:38:11,760 --> 01:38:14,340
no set of tests in order to verify tool

2362
01:38:14,340 --> 01:38:17,100
compliance with standards

2363
01:38:17,100 --> 01:38:18,239
however

2364
01:38:18,239 --> 01:38:20,400
uml has become popular for drawing

2365
01:38:20,400 --> 01:38:22,860
certain types of diagrams either

2366
01:38:22,860 --> 01:38:25,620
manually by hand using different tools

2367
01:38:25,620 --> 01:38:29,420
or using electronic tools

2368
01:38:29,420 --> 01:38:32,340
individuals drawing uml diagrams by hand

2369
01:38:32,340 --> 01:38:34,760
typically do not remain strictly

2370
01:38:34,760 --> 01:38:37,080
adherent to the standards there can be

2371
01:38:37,080 --> 01:38:40,320
slight variations in the diagrams as

2372
01:38:40,320 --> 01:38:41,360
drawn

2373
01:38:41,360 --> 01:38:44,880
the uml provides diagram types to model

2374
01:38:44,880 --> 01:38:47,340
system structure behavior and

2375
01:38:47,340 --> 01:38:49,260
interaction

2376
01:38:49,260 --> 01:38:52,500
there are some limitations to uml first

2377
01:38:52,500 --> 01:38:54,719
and foremost uml does not replace other

2378
01:38:54,719 --> 01:38:57,540
types of design documents a good example

2379
01:38:57,540 --> 01:38:59,940
of this is use cases

2380
01:38:59,940 --> 01:39:02,820
uml use case diagrams can provide useful

2381
01:39:02,820 --> 01:39:06,179
indexes into use cases however they do

2382
01:39:06,179 --> 01:39:09,540
not replace the use cases themselves

2383
01:39:09,540 --> 01:39:12,000
many of the diagram types that uml

2384
01:39:12,000 --> 01:39:15,120
provides are not actually used widely

2385
01:39:15,120 --> 01:39:17,940
simply because their specialty diagrams

2386
01:39:17,940 --> 01:39:21,179
that many developers don't choose to

2387
01:39:21,179 --> 01:39:22,920
utilize

2388
01:39:22,920 --> 01:39:25,260
uml diagramming tools often use

2389
01:39:25,260 --> 01:39:27,780
incompatible formats making them

2390
01:39:27,780 --> 01:39:30,360
difficult to Interchange diagrams

2391
01:39:30,360 --> 01:39:33,000
between one tool and another

2392
01:39:33,000 --> 01:39:36,300
in standardization of uml was a

2393
01:39:36,300 --> 01:39:37,980
controversial and in some circles

2394
01:39:37,980 --> 01:39:40,800
remains a controversial topic today

2395
01:39:40,800 --> 01:39:43,380
other software modeling approaches do

2396
01:39:43,380 --> 01:39:46,080
exist but were not included in uml

2397
01:39:46,080 --> 01:39:48,600
because they were not considered by the

2398
01:39:48,600 --> 01:39:50,760
uml authors

2399
01:39:50,760 --> 01:39:54,000
nevertheless uml does provide a rich

2400
01:39:54,000 --> 01:39:56,820
variety of diagram types

2401
01:39:56,820 --> 01:40:00,179
these can be classified into two to

2402
01:40:00,179 --> 01:40:02,040
three categories depending on how you

2403
01:40:02,040 --> 01:40:04,500
prefer to draw the classification

2404
01:40:04,500 --> 01:40:07,080
we have structural diagrams in

2405
01:40:07,080 --> 01:40:09,719
particular class diagrams that are

2406
01:40:09,719 --> 01:40:11,820
widely used to show how object-oriented

2407
01:40:11,820 --> 01:40:13,679
systems are designed

2408
01:40:13,679 --> 01:40:16,500
we have Behavior diagrams in particular

2409
01:40:16,500 --> 01:40:21,120
activity diagrams which can show how a

2410
01:40:21,120 --> 01:40:23,100
development process can be coordinated

2411
01:40:23,100 --> 01:40:26,219
and state machine diagrams which are

2412
01:40:26,219 --> 01:40:28,199
useful for representing finite State

2413
01:40:28,199 --> 01:40:30,840
machines that exist in many types of

2414
01:40:30,840 --> 01:40:32,159
software

2415
01:40:32,159 --> 01:40:34,500
there are also interaction diagrams

2416
01:40:34,500 --> 01:40:36,360
which can be thought of as a subset of

2417
01:40:36,360 --> 01:40:39,060
behavior diagrams and this can show how

2418
01:40:39,060 --> 01:40:40,980
different software components interact

2419
01:40:40,980 --> 01:40:43,520
with each other

2420
01:40:43,980 --> 01:40:46,320
uml as a tool when software engineering

2421
01:40:46,320 --> 01:40:48,900
is simply one of a number of tools that

2422
01:40:48,900 --> 01:40:51,659
can be used to plan architect and design

2423
01:40:51,659 --> 01:40:54,060
software applications

2424
01:40:54,060 --> 01:40:57,060
diagrams using uml are convenient for

2425
01:40:57,060 --> 01:40:58,620
communication between different members

2426
01:40:58,620 --> 01:41:00,780
of a development team

2427
01:41:00,780 --> 01:41:02,760
and they help communicate the

2428
01:41:02,760 --> 01:41:04,560
architecture and design of an

2429
01:41:04,560 --> 01:41:06,960
implemented Software System to Future

2430
01:41:06,960 --> 01:41:08,880
developers who might need to maintain

2431
01:41:08,880 --> 01:41:10,860
that system

2432
01:41:10,860 --> 01:41:13,260
there are some tools available called

2433
01:41:13,260 --> 01:41:15,480
case tools or computer-aided software

2434
01:41:15,480 --> 01:41:18,120
engineering tools that can take uml

2435
01:41:18,120 --> 01:41:20,460
diagrams a bit further and actually

2436
01:41:20,460 --> 01:41:23,520
generate Partial Program code from the

2437
01:41:23,520 --> 01:41:24,840
uml diagram

2438
01:41:24,840 --> 01:41:27,300
so if you have a uml diagram laying out

2439
01:41:27,300 --> 01:41:30,420
a few classes the case tools can often

2440
01:41:30,420 --> 01:41:34,340
fill in templates of the classes and

2441
01:41:34,340 --> 01:41:36,659
programmers would only need to fill in

2442
01:41:36,659 --> 01:41:38,760
the code for each individual method in

2443
01:41:38,760 --> 01:41:40,679
the class

2444
01:41:40,679 --> 01:41:43,560
other tools exist that can actually take

2445
01:41:43,560 --> 01:41:46,920
existing code and extract euml diagram

2446
01:41:46,920 --> 01:41:50,580
from that code showing how the code is

2447
01:41:50,580 --> 01:41:52,679
structured

2448
01:41:52,679 --> 01:41:55,320
so in summary uml provides us a common

2449
01:41:55,320 --> 01:41:57,239
set of communication tools for

2450
01:41:57,239 --> 01:42:00,420
presenting And discussing aspects of the

2451
01:42:00,420 --> 01:42:02,219
architecture and design of software

2452
01:42:02,219 --> 01:42:03,900
systems

2453
01:42:03,900 --> 01:42:05,880
uml is one of many tools used by

2454
01:42:05,880 --> 01:42:08,219
software engineers and software

2455
01:42:08,219 --> 01:42:10,619
applications exist for drawing uml

2456
01:42:10,619 --> 01:42:11,820
diagrams

2457
01:42:11,820 --> 01:42:14,940
and potentially generating code from

2458
01:42:14,940 --> 01:42:16,679
those diagrams

2459
01:42:16,679 --> 01:42:19,199
however these tools are often not

2460
01:42:19,199 --> 01:42:21,540
interoperable with each other in this

2461
01:42:21,540 --> 01:42:23,699
lecture I'm going to discuss uml

2462
01:42:23,699 --> 01:42:27,020
activity diagrams

2463
01:42:28,560 --> 01:42:30,900
uml activity diagrams are used for

2464
01:42:30,900 --> 01:42:32,580
modeling processes

2465
01:42:32,580 --> 01:42:35,460
these processes can include different

2466
01:42:35,460 --> 01:42:38,520
operations within software

2467
01:42:38,520 --> 01:42:40,320
they can include the software

2468
01:42:40,320 --> 01:42:42,239
development process itself

2469
01:42:42,239 --> 01:42:45,360
can also include business processes and

2470
01:42:45,360 --> 01:42:47,820
other types of process

2471
01:42:47,820 --> 01:42:50,760
in this example graphic I have a uml

2472
01:42:50,760 --> 01:42:53,820
activity diagram illustrating the

2473
01:42:53,820 --> 01:42:56,159
development for a simple client server

2474
01:42:56,159 --> 01:42:57,300
project

2475
01:42:57,300 --> 01:43:00,119
in which the client and the server are

2476
01:43:00,119 --> 01:43:02,699
implemented by different members of the

2477
01:43:02,699 --> 01:43:04,440
development team

2478
01:43:04,440 --> 01:43:06,960
the basic parts of the uml activity

2479
01:43:06,960 --> 01:43:08,100
diagram

2480
01:43:08,100 --> 01:43:10,860
include the initial State the final

2481
01:43:10,860 --> 01:43:11,940
state

2482
01:43:11,940 --> 01:43:15,900
and set of transitions in other states

2483
01:43:15,900 --> 01:43:18,119
and controls in between the initial

2484
01:43:18,119 --> 01:43:20,400
State and the final state

2485
01:43:20,400 --> 01:43:22,920
the initial state is represented by a

2486
01:43:22,920 --> 01:43:24,300
filled Circle

2487
01:43:24,300 --> 01:43:26,580
and represents the point at which we

2488
01:43:26,580 --> 01:43:29,760
enter the process

2489
01:43:29,760 --> 01:43:34,080
the final state is displayed as a filled

2490
01:43:34,080 --> 01:43:37,920
Circle within another Circle and this is

2491
01:43:37,920 --> 01:43:42,679
the state in which we exit the process

2492
01:43:42,780 --> 01:43:45,420
in between these two states we have

2493
01:43:45,420 --> 01:43:48,540
action States and activity States

2494
01:43:48,540 --> 01:43:50,880
action States represent single

2495
01:43:50,880 --> 01:43:53,699
operations in the process being modeled

2496
01:43:53,699 --> 01:43:56,219
and these operations are not broken down

2497
01:43:56,219 --> 01:43:59,460
into another activity diagram

2498
01:43:59,460 --> 01:44:03,000
activity States represent longer running

2499
01:44:03,000 --> 01:44:06,300
processes that occur as steps in our

2500
01:44:06,300 --> 01:44:08,280
outer process

2501
01:44:08,280 --> 01:44:11,699
and these inner processes have their own

2502
01:44:11,699 --> 01:44:14,699
activity diagrams to explain how they

2503
01:44:14,699 --> 01:44:17,060
function

2504
01:44:17,520 --> 01:44:20,760
within an activity diagram we can make a

2505
01:44:20,760 --> 01:44:23,219
decision to perform one step or another

2506
01:44:23,219 --> 01:44:26,580
or even repeat a prior step based upon

2507
01:44:26,580 --> 01:44:29,600
some condition in a uml activity diagram

2508
01:44:29,600 --> 01:44:32,159
this decision is called a sequential

2509
01:44:32,159 --> 01:44:34,860
branch and it's represented by a small

2510
01:44:34,860 --> 01:44:37,380
diamond borrowed from flowcharting

2511
01:44:37,380 --> 01:44:38,940
symbols

2512
01:44:38,940 --> 01:44:42,060
a decision can be taken at the point of

2513
01:44:42,060 --> 01:44:43,260
the diamond

2514
01:44:43,260 --> 01:44:45,960
and then transitions leading from the

2515
01:44:45,960 --> 01:44:49,520
diamond will indicate the next state

2516
01:44:49,520 --> 01:44:51,719
conditions associated with those

2517
01:44:51,719 --> 01:44:53,820
transitions are included in square

2518
01:44:53,820 --> 01:44:57,060
brackets as annotations next to the

2519
01:44:57,060 --> 01:44:58,980
transition error

2520
01:44:58,980 --> 01:45:02,580
the special annotation else indicates a

2521
01:45:02,580 --> 01:45:05,520
path to take if no other condition is

2522
01:45:05,520 --> 01:45:07,940
satisfied

2523
01:45:08,340 --> 01:45:11,520
in modeling processes it's useful to

2524
01:45:11,520 --> 01:45:14,340
show where certain steps can be carried

2525
01:45:14,340 --> 01:45:15,960
out by different people or different

2526
01:45:15,960 --> 01:45:19,020
components of the system in parallel

2527
01:45:19,020 --> 01:45:21,420
we can represent this in a uml activity

2528
01:45:21,420 --> 01:45:23,699
diagram by means of something called a

2529
01:45:23,699 --> 01:45:25,380
concurrent Fork

2530
01:45:25,380 --> 01:45:28,199
a concurrent Fork is simply a thick line

2531
01:45:28,199 --> 01:45:31,440
to which a transition connects and

2532
01:45:31,440 --> 01:45:34,800
several transitions originate

2533
01:45:34,800 --> 01:45:37,380
from the originating transitions we have

2534
01:45:37,380 --> 01:45:39,780
states that are reached in parallel

2535
01:45:39,780 --> 01:45:42,360
presumably by different entities within

2536
01:45:42,360 --> 01:45:43,679
the system

2537
01:45:43,679 --> 01:45:45,840
thus the concurrent Fork allows our

2538
01:45:45,840 --> 01:45:48,179
process to be split into multiple

2539
01:45:48,179 --> 01:45:50,820
concurrent paths things that can be done

2540
01:45:50,820 --> 01:45:52,920
at the same time and then we can get

2541
01:45:52,920 --> 01:45:55,080
back together later

2542
01:45:55,080 --> 01:45:57,060
in the way we come back together from a

2543
01:45:57,060 --> 01:45:59,280
concurrent Fork is with the opposite a

2544
01:45:59,280 --> 01:46:02,280
concurrent join this is the same kind of

2545
01:46:02,280 --> 01:46:03,659
heavy line

2546
01:46:03,659 --> 01:46:06,900
however transition arrows come into the

2547
01:46:06,900 --> 01:46:09,360
line and a single transition comes out

2548
01:46:09,360 --> 01:46:11,880
of the line to the next state in the

2549
01:46:11,880 --> 01:46:13,380
sequential process

2550
01:46:13,380 --> 01:46:15,540
so we have multiple concurrent parallel

2551
01:46:15,540 --> 01:46:18,119
paths meeting to form a single

2552
01:46:18,119 --> 01:46:20,900
sequential path

2553
01:46:20,900 --> 01:46:23,940
it's useful with concurrent forks and

2554
01:46:23,940 --> 01:46:25,920
concurrent joints to have something

2555
01:46:25,920 --> 01:46:29,699
called activity partitions or Swim Lanes

2556
01:46:29,699 --> 01:46:32,340
these are ways of annotating the diagram

2557
01:46:32,340 --> 01:46:35,580
to show which component individual or

2558
01:46:35,580 --> 01:46:39,300
entity is responsible for each parallel

2559
01:46:39,300 --> 01:46:41,280
path in the project

2560
01:46:41,280 --> 01:46:43,860
in this example we can see that the

2561
01:46:43,860 --> 01:46:46,860
entire team performs research and then

2562
01:46:46,860 --> 01:46:48,900
performs a design step

2563
01:46:48,900 --> 01:46:51,900
then we have a concurrent Fork after

2564
01:46:51,900 --> 01:46:55,440
which Bob implements the client and Jill

2565
01:46:55,440 --> 01:46:57,420
implements the server

2566
01:46:57,420 --> 01:46:59,760
after those implementations are done we

2567
01:46:59,760 --> 01:47:02,460
have a concurrent join and come back to

2568
01:47:02,460 --> 01:47:04,560
the team

2569
01:47:04,560 --> 01:47:06,840
separation of responsibility is

2570
01:47:06,840 --> 01:47:10,260
indicated by drawing a box or activity

2571
01:47:10,260 --> 01:47:14,400
partition around those parts of the path

2572
01:47:14,400 --> 01:47:17,400
that are the responsibility of one

2573
01:47:17,400 --> 01:47:19,560
single component one single team member

2574
01:47:19,560 --> 01:47:23,000
or one single entity

2575
01:47:23,400 --> 01:47:25,260
I'll take just a moment to talk about

2576
01:47:25,260 --> 01:47:28,139
types of tools we can use to draw uml

2577
01:47:28,139 --> 01:47:30,480
activity diagrams

2578
01:47:30,480 --> 01:47:33,480
a simple way is to draw the diagrams by

2579
01:47:33,480 --> 01:47:34,860
hand on paper

2580
01:47:34,860 --> 01:47:37,080
if we need a digital copy we can simply

2581
01:47:37,080 --> 01:47:39,600
use a camera such as the type of camera

2582
01:47:39,600 --> 01:47:41,699
in your cell phone to make a digital

2583
01:47:41,699 --> 01:47:43,380
image

2584
01:47:43,380 --> 01:47:45,119
some more professional looking results

2585
01:47:45,119 --> 01:47:46,920
can be obtained by using a drawing

2586
01:47:46,920 --> 01:47:49,860
program I've used Google Docs drawing

2587
01:47:49,860 --> 01:47:52,080
tool to make the examples in these

2588
01:47:52,080 --> 01:47:54,060
lecture slides however you could use

2589
01:47:54,060 --> 01:47:57,960
OpenOffice draw Vizio or another type of

2590
01:47:57,960 --> 01:48:00,420
drawing program in order to make these

2591
01:48:00,420 --> 01:48:01,679
diagrams

2592
01:48:01,679 --> 01:48:04,020
there are also some open source tools

2593
01:48:04,020 --> 01:48:07,080
that have uml-specific additions that

2594
01:48:07,080 --> 01:48:09,900
can be useful for making uml diagrams

2595
01:48:09,900 --> 01:48:12,000
these include DIA

2596
01:48:12,000 --> 01:48:14,400
certain plugins to the eclipse framework

2597
01:48:14,400 --> 01:48:16,500
however these are complicated to set up

2598
01:48:16,500 --> 01:48:18,900
and sometimes difficult to use

2599
01:48:18,900 --> 01:48:22,400
and umbrella which is a general purpose

2600
01:48:22,400 --> 01:48:26,820
computer-aided software engineering tool

2601
01:48:26,820 --> 01:48:28,380
so in summary

2602
01:48:28,380 --> 01:48:31,440
uml activity diagrams allow us to model

2603
01:48:31,440 --> 01:48:32,880
a process

2604
01:48:32,880 --> 01:48:35,340
this process can fall into any one of

2605
01:48:35,340 --> 01:48:37,800
several domains this could be a process

2606
01:48:37,800 --> 01:48:40,440
inside software this could be a business

2607
01:48:40,440 --> 01:48:43,380
process this could even be the software

2608
01:48:43,380 --> 01:48:45,540
development process itself how the

2609
01:48:45,540 --> 01:48:47,699
individual team members are going to

2610
01:48:47,699 --> 01:48:49,560
come together in the project

2611
01:48:49,560 --> 01:48:53,580
in this example I am modeling a software

2612
01:48:53,580 --> 01:48:57,000
development process a very simple one

2613
01:48:57,000 --> 01:48:59,340
you can see the initial State the filled

2614
01:48:59,340 --> 01:49:01,440
circle at the top at which the

2615
01:49:01,440 --> 01:49:03,840
development process begins

2616
01:49:03,840 --> 01:49:06,179
this process begins with the entire team

2617
01:49:06,179 --> 01:49:08,159
performing research

2618
01:49:08,159 --> 01:49:10,800
research is an activity state so it

2619
01:49:10,800 --> 01:49:12,420
would be described by a separate

2620
01:49:12,420 --> 01:49:16,020
activity diagram which I have not shown

2621
01:49:16,020 --> 01:49:19,080
after the research phase we would move

2622
01:49:19,080 --> 01:49:21,239
to the design phase in which the entire

2623
01:49:21,239 --> 01:49:23,159
team would be working on the design for

2624
01:49:23,159 --> 01:49:24,840
the software

2625
01:49:24,840 --> 01:49:27,480
after the design state which is an

2626
01:49:27,480 --> 01:49:29,420
action state so it's not further

2627
01:49:29,420 --> 01:49:31,860
Illustrated anywhere else

2628
01:49:31,860 --> 01:49:34,860
we have a concurrent Fork at which point

2629
01:49:34,860 --> 01:49:37,860
Bob goes and implements the client part

2630
01:49:37,860 --> 01:49:40,139
of the project and Jill goes and

2631
01:49:40,139 --> 01:49:41,580
implements the server part of the

2632
01:49:41,580 --> 01:49:42,840
project

2633
01:49:42,840 --> 01:49:45,420
when both Bob and Jill are finished with

2634
01:49:45,420 --> 01:49:47,400
their implementations we have a

2635
01:49:47,400 --> 01:49:50,040
concurrent join at which point the

2636
01:49:50,040 --> 01:49:52,679
entire team reassembles to integrate the

2637
01:49:52,679 --> 01:49:55,800
project and test the project

2638
01:49:55,800 --> 01:49:59,040
if all the tests pass we move on to the

2639
01:49:59,040 --> 01:50:00,540
ship state

2640
01:50:00,540 --> 01:50:03,600
however if the tests are not passing if

2641
01:50:03,600 --> 01:50:06,179
we take the else branch of that

2642
01:50:06,179 --> 01:50:09,600
sequential Branch then we go back to the

2643
01:50:09,600 --> 01:50:11,280
test step

2644
01:50:11,280 --> 01:50:13,739
finally once we've moved to the ship

2645
01:50:13,739 --> 01:50:14,760
state

2646
01:50:14,760 --> 01:50:17,820
we can move to the final state of the

2647
01:50:17,820 --> 01:50:19,980
diagram which indicates that this

2648
01:50:19,980 --> 01:50:22,199
process is complete

2649
01:50:22,199 --> 01:50:24,000
in this lecture I'm going to discuss

2650
01:50:24,000 --> 01:50:28,520
interrupts and device input output

2651
01:50:28,860 --> 01:50:30,659
when Hardware devices on a computer

2652
01:50:30,659 --> 01:50:33,540
produce events

2653
01:50:33,540 --> 01:50:35,699
we need some way of being able to handle

2654
01:50:35,699 --> 01:50:37,440
those events within the operating system

2655
01:50:37,440 --> 01:50:40,440
and deliver them to Applications

2656
01:50:40,440 --> 01:50:42,239
and Hardware devices are going to

2657
01:50:42,239 --> 01:50:45,119
produce events at times and in patterns

2658
01:50:45,119 --> 01:50:47,699
that we don't know about in advance for

2659
01:50:47,699 --> 01:50:49,920
example we don't know which Keys the

2660
01:50:49,920 --> 01:50:51,420
user is going to press on the keyboard

2661
01:50:51,420 --> 01:50:53,880
until the user actually presses those

2662
01:50:53,880 --> 01:50:54,840
keys

2663
01:50:54,840 --> 01:50:57,600
if a cat walks across the keyboard we're

2664
01:50:57,600 --> 01:50:58,860
going to see a completely different

2665
01:50:58,860 --> 01:51:01,139
pattern of key presses from which we

2666
01:51:01,139 --> 01:51:05,580
would expect to see with the human user

2667
01:51:05,580 --> 01:51:07,860
similarly if we have incoming Network

2668
01:51:07,860 --> 01:51:09,659
packets if we're running a server

2669
01:51:09,659 --> 01:51:11,639
application or even just a workstation

2670
01:51:11,639 --> 01:51:13,980
and we have messages coming in from the

2671
01:51:13,980 --> 01:51:16,619
network we don't know the order and

2672
01:51:16,619 --> 01:51:18,659
timing of those messages

2673
01:51:18,659 --> 01:51:20,699
we also don't know when the mouse is

2674
01:51:20,699 --> 01:51:23,340
going to be moved or when any other of a

2675
01:51:23,340 --> 01:51:24,780
whole bunch of Hardware events is going

2676
01:51:24,780 --> 01:51:26,400
to occur

2677
01:51:26,400 --> 01:51:28,080
so how can we get the information

2678
01:51:28,080 --> 01:51:31,199
generated by these events and make it

2679
01:51:31,199 --> 01:51:34,980
available to our applications for use

2680
01:51:34,980 --> 01:51:37,739
well we have two options

2681
01:51:37,739 --> 01:51:39,780
first option is that we can pull each

2682
01:51:39,780 --> 01:51:41,940
device we can ask each device if it has

2683
01:51:41,940 --> 01:51:44,280
any new information and retrieve that

2684
01:51:44,280 --> 01:51:46,080
information

2685
01:51:46,080 --> 01:51:49,020
or we can let the devices send a signal

2686
01:51:49,020 --> 01:51:51,480
whenever they have information and have

2687
01:51:51,480 --> 01:51:53,940
the operating system stop whatever it's

2688
01:51:53,940 --> 01:51:57,000
doing and pick up that information this

2689
01:51:57,000 --> 01:51:59,639
is called an interrupt

2690
01:51:59,639 --> 01:52:02,340
the polling model of input involves the

2691
01:52:02,340 --> 01:52:04,739
OS periodically polling each device for

2692
01:52:04,739 --> 01:52:07,440
information so every so often the CPU is

2693
01:52:07,440 --> 01:52:08,940
going to send a message to each Hardware

2694
01:52:08,940 --> 01:52:11,400
device in the system and say Hey you

2695
01:52:11,400 --> 01:52:12,900
have any data for me

2696
01:52:12,900 --> 01:52:15,119
and most of the time the device is going

2697
01:52:15,119 --> 01:52:16,980
to send back no don't really have any

2698
01:52:16,980 --> 01:52:18,239
data for you

2699
01:52:18,239 --> 01:52:20,280
other times the device is going to send

2700
01:52:20,280 --> 01:52:22,320
back some data

2701
01:52:22,320 --> 01:52:24,679
it's a really simple design

2702
01:52:24,679 --> 01:52:27,480
extremely simple to implement

2703
01:52:27,480 --> 01:52:29,340
but there are a number of problems with

2704
01:52:29,340 --> 01:52:30,420
polling

2705
01:52:30,420 --> 01:52:32,520
first problem is is that most of the

2706
01:52:32,520 --> 01:52:35,159
time when you're polling the devices are

2707
01:52:35,159 --> 01:52:36,480
not going to have any input data

2708
01:52:36,480 --> 01:52:37,500
delivered

2709
01:52:37,500 --> 01:52:39,659
thus polling is going to waste a whole

2710
01:52:39,659 --> 01:52:41,639
lot of CPU time

2711
01:52:41,639 --> 01:52:43,800
the second issue that occurs is high

2712
01:52:43,800 --> 01:52:46,080
latency if I press the key on the

2713
01:52:46,080 --> 01:52:48,300
keyboard that keystroke is not going to

2714
01:52:48,300 --> 01:52:50,219
get transmitted to the computer until

2715
01:52:50,219 --> 01:52:53,040
the next time the CPU pulls the keyboard

2716
01:52:53,040 --> 01:52:55,380
to ask which Keys have been pressed

2717
01:52:55,380 --> 01:52:56,820
if that

2718
01:52:56,820 --> 01:53:00,060
time is set to be really short I'll have

2719
01:53:00,060 --> 01:53:02,880
good responsiveness but the CPU is not

2720
01:53:02,880 --> 01:53:05,580
going to get any useful work done

2721
01:53:05,580 --> 01:53:07,980
on the other hand if we set that time

2722
01:53:07,980 --> 01:53:09,900
length to be long enough for the CPU to

2723
01:53:09,900 --> 01:53:11,880
get some work done there's going to be a

2724
01:53:11,880 --> 01:53:13,980
noticeable lag between the time I press

2725
01:53:13,980 --> 01:53:16,260
a key and the time a character appears

2726
01:53:16,260 --> 01:53:18,239
on the screen

2727
01:53:18,239 --> 01:53:21,480
since the device must wait for a polling

2728
01:53:21,480 --> 01:53:23,760
interval because it can translate input

2729
01:53:23,760 --> 01:53:25,380
we're going to have a high latency

2730
01:53:25,380 --> 01:53:26,940
situation

2731
01:53:26,940 --> 01:53:29,760
and again shortening that polling

2732
01:53:29,760 --> 01:53:31,520
interval to try to reduce the latency

2733
01:53:31,520 --> 01:53:34,320
simply wastes a whole lot of CPU time

2734
01:53:34,320 --> 01:53:37,920
checking devices that have no input

2735
01:53:37,920 --> 01:53:40,139
so better mechanism is to use a system

2736
01:53:40,139 --> 01:53:42,300
called interrupts and with interrupts

2737
01:53:42,300 --> 01:53:44,940
the hardware device is actually signal

2738
01:53:44,940 --> 01:53:46,800
the operating system whenever events

2739
01:53:46,800 --> 01:53:49,139
occur or more precisely they signal the

2740
01:53:49,139 --> 01:53:51,060
CPU and then it's up to the operating

2741
01:53:51,060 --> 01:53:54,540
system to receive and handle that signal

2742
01:53:54,540 --> 01:53:56,699
what the operating system will do is it

2743
01:53:56,699 --> 01:53:58,619
will preempt any running process in

2744
01:53:58,619 --> 01:54:00,480
other words it will switch what we call

2745
01:54:00,480 --> 01:54:03,060
context away from that running process

2746
01:54:03,060 --> 01:54:05,699
to handle the event basically it will

2747
01:54:05,699 --> 01:54:08,400
move the program counter of the CPU

2748
01:54:08,400 --> 01:54:11,400
to the code to handle that particular

2749
01:54:11,400 --> 01:54:13,800
interrupt

2750
01:54:13,800 --> 01:54:16,139
this allows for a more responsive system

2751
01:54:16,139 --> 01:54:17,580
than we could ever achieve through

2752
01:54:17,580 --> 01:54:19,920
polling without having to waste a whole

2753
01:54:19,920 --> 01:54:22,980
bunch of time asking idle devices for

2754
01:54:22,980 --> 01:54:24,119
data

2755
01:54:24,119 --> 01:54:26,600
however this does require a more complex

2756
01:54:26,600 --> 01:54:29,460
implementation and that implementation

2757
01:54:29,460 --> 01:54:33,360
complexity begins at the hardware level

2758
01:54:33,360 --> 01:54:36,540
specifically within the CPU we need to

2759
01:54:36,540 --> 01:54:38,820
have a mechanism for checking and

2760
01:54:38,820 --> 01:54:40,860
responding to interrupts

2761
01:54:40,860 --> 01:54:43,380
and this mechanism is implemented as

2762
01:54:43,380 --> 01:54:46,440
part of the cpu's fetch execute cycle

2763
01:54:46,440 --> 01:54:49,139
in the process of fetch execute the CPU

2764
01:54:49,139 --> 01:54:50,760
is going to fetch an instruction for

2765
01:54:50,760 --> 01:54:51,600
memory

2766
01:54:51,600 --> 01:54:53,940
increment the program counter

2767
01:54:53,940 --> 01:54:56,580
execute that instruction

2768
01:54:56,580 --> 01:54:58,800
but instead of Simply going back to the

2769
01:54:58,800 --> 01:55:01,679
next fetch the CPU actually has to have

2770
01:55:01,679 --> 01:55:04,020
additional Hardware to check to see if

2771
01:55:04,020 --> 01:55:06,360
an interrupt event is pending

2772
01:55:06,360 --> 01:55:09,239
if there is an interrupt pending then

2773
01:55:09,239 --> 01:55:11,280
the CPU has to be switched to Kernel

2774
01:55:11,280 --> 01:55:13,619
mode if it's running in user mode so the

2775
01:55:13,619 --> 01:55:16,139
privilege level needs to be escalated

2776
01:55:16,139 --> 01:55:18,600
save the program counter by pushing it

2777
01:55:18,600 --> 01:55:20,159
onto the stack

2778
01:55:20,159 --> 01:55:22,860
and load a program counter from fixed

2779
01:55:22,860 --> 01:55:25,260
memory location and that fixed memory

2780
01:55:25,260 --> 01:55:28,139
location is called the interrupt Vector

2781
01:55:28,139 --> 01:55:30,480
table or ivt

2782
01:55:30,480 --> 01:55:32,340
so we load the program counter from the

2783
01:55:32,340 --> 01:55:35,580
IBT and then the CPU goes and executes

2784
01:55:35,580 --> 01:55:38,880
that new instruction the next time the

2785
01:55:38,880 --> 01:55:41,639
fetch execute cycle resumes so the CPU

2786
01:55:41,639 --> 01:55:43,320
actually moves from executing program

2787
01:55:43,320 --> 01:55:46,199
code to executing code from the

2788
01:55:46,199 --> 01:55:47,880
interrupt Handler for the particular

2789
01:55:47,880 --> 01:55:49,260
event

2790
01:55:49,260 --> 01:55:51,960
if no interrupt is pending at the end of

2791
01:55:51,960 --> 01:55:55,080
an execute then we simply go back to the

2792
01:55:55,080 --> 01:55:57,900
next instruction fetch

2793
01:55:57,900 --> 01:55:59,760
the interrupt Vector table

2794
01:55:59,760 --> 01:56:01,920
consists of an array

2795
01:56:01,920 --> 01:56:05,100
of addresses of handlers

2796
01:56:05,100 --> 01:56:07,980
each element in this array essentially

2797
01:56:07,980 --> 01:56:10,560
gives the program counter location for

2798
01:56:10,560 --> 01:56:13,139
the Handler for a particular interrupt

2799
01:56:13,139 --> 01:56:15,300
this Handler is going to be in a

2800
01:56:15,300 --> 01:56:17,280
subsystem of the kernel for a monolithic

2801
01:56:17,280 --> 01:56:20,100
kernel or this Handler might invoke a

2802
01:56:20,100 --> 01:56:22,440
call to an external server for a micro

2803
01:56:22,440 --> 01:56:23,699
kernel

2804
01:56:23,699 --> 01:56:26,940
in any case however the first Handler by

2805
01:56:26,940 --> 01:56:30,360
convention element 0 of the array is

2806
01:56:30,360 --> 01:56:33,119
always the Handler for the clock

2807
01:56:33,119 --> 01:56:36,659
then handlers for different devices are

2808
01:56:36,659 --> 01:56:40,380
in the array after the clock Handler

2809
01:56:40,380 --> 01:56:43,739
so the interrupt Vector is always mapped

2810
01:56:43,739 --> 01:56:46,260
into the user part of memory it's always

2811
01:56:46,260 --> 01:56:49,139
available at all times so that the

2812
01:56:49,139 --> 01:56:50,940
kernel can go and look up interrupt

2813
01:56:50,940 --> 01:56:54,920
information whenever is necessary

2814
01:56:55,260 --> 01:56:58,320
an interrupt is processed by branching

2815
01:56:58,320 --> 01:56:59,699
the program counter to the interrupt

2816
01:56:59,699 --> 01:57:01,080
Handler

2817
01:57:01,080 --> 01:57:03,659
executing interrupt handling code

2818
01:57:03,659 --> 01:57:05,880
and then at the end of the interrupt

2819
01:57:05,880 --> 01:57:07,920
handling code there'll be an instruction

2820
01:57:07,920 --> 01:57:10,860
to return from the interrupt in the

2821
01:57:10,860 --> 01:57:12,780
Intel Assembly Language this is The

2822
01:57:12,780 --> 01:57:15,480
Irate instruction which loads the

2823
01:57:15,480 --> 01:57:17,580
process program counter back from memory

2824
01:57:17,580 --> 01:57:19,860
it pops the stack to get the original

2825
01:57:19,860 --> 01:57:21,659
program counter back

2826
01:57:21,659 --> 01:57:24,659
and goes ahead and changes the CPU back

2827
01:57:24,659 --> 01:57:27,060
to user mode so it removes the privilege

2828
01:57:27,060 --> 01:57:29,340
escalation

2829
01:57:29,340 --> 01:57:32,400
the interrupt handling mechanism is thus

2830
01:57:32,400 --> 01:57:34,860
able to handle events from Hardware

2831
01:57:34,860 --> 01:57:37,860
devices without having to poll each

2832
01:57:37,860 --> 01:57:41,159
device individually to get data in this

2833
01:57:41,159 --> 01:57:43,020
lecture I'll be discussing interrupt

2834
01:57:43,020 --> 01:57:44,219
controllers

2835
01:57:44,219 --> 01:57:47,219
in particular I'll introduce the old and

2836
01:57:47,219 --> 01:57:49,980
new mechanisms for delivering interrupts

2837
01:57:49,980 --> 01:57:53,760
from Hardware devices to the CPU

2838
01:57:53,760 --> 01:57:55,320
these methods include the original

2839
01:57:55,320 --> 01:57:58,020
programmable interrupt controllers and

2840
01:57:58,020 --> 01:58:00,300
the new Advanced programmable interrupt

2841
01:58:00,300 --> 01:58:02,219
controller with message signaled

2842
01:58:02,219 --> 01:58:04,679
interrupts

2843
01:58:04,679 --> 01:58:06,540
interrupt controllers provide an

2844
01:58:06,540 --> 01:58:08,820
interface for Hardware to Signal the CPU

2845
01:58:08,820 --> 01:58:11,280
whenever a device needs attention

2846
01:58:11,280 --> 01:58:14,099
it's important to note that this signal

2847
01:58:14,099 --> 01:58:16,800
only includes a message that essentially

2848
01:58:16,800 --> 01:58:19,860
says hey I'm a device I need attention

2849
01:58:19,860 --> 01:58:22,500
the CPU historically then actually does

2850
01:58:22,500 --> 01:58:24,960
have to go and pull the device to get

2851
01:58:24,960 --> 01:58:28,880
any data that the device may have

2852
01:58:29,219 --> 01:58:31,560
the older mechanism for performing this

2853
01:58:31,560 --> 01:58:33,420
operation was called a programmable

2854
01:58:33,420 --> 01:58:35,580
interrupt controller or pick

2855
01:58:35,580 --> 01:58:38,159
and it actually required dedicated lines

2856
01:58:38,159 --> 01:58:40,500
to be added to the motherboard

2857
01:58:40,500 --> 01:58:42,780
the ISA or industry standard

2858
01:58:42,780 --> 01:58:45,840
architecture bus Which dates back all

2859
01:58:45,840 --> 01:58:49,440
the way to the first PC back in 1987.

2860
01:58:49,440 --> 01:58:52,260
and older versions of the PCI or

2861
01:58:52,260 --> 01:58:54,800
peripheral component interconnect bus

2862
01:58:54,800 --> 01:58:58,500
utilized this mechanism

2863
01:58:58,500 --> 01:59:00,659
the new mechanism or the advanced

2864
01:59:00,659 --> 01:59:02,820
programmable interrupt controller is

2865
01:59:02,820 --> 01:59:05,940
used on PCI Express devices and some

2866
01:59:05,940 --> 01:59:08,940
newer PCI devices

2867
01:59:08,940 --> 01:59:10,920
now the old controller or the

2868
01:59:10,920 --> 01:59:12,360
programmable interrupt controller

2869
01:59:12,360 --> 01:59:15,300
actually consisted of two programmable

2870
01:59:15,300 --> 01:59:18,300
interrupt controller chips that were

2871
01:59:18,300 --> 01:59:20,400
attached to each other with one of the

2872
01:59:20,400 --> 01:59:23,219
chips being attached to the CPU

2873
01:59:23,219 --> 01:59:25,679
the so-called Master chip was the one

2874
01:59:25,679 --> 01:59:27,659
attached to the CPU

2875
01:59:27,659 --> 01:59:31,860
and pin 2 of that Master chip was

2876
01:59:31,860 --> 01:59:34,920
attached to a slave chip

2877
01:59:34,920 --> 01:59:39,239
each pin on each of the two chips allows

2878
01:59:39,239 --> 01:59:42,780
for 16 interrupt numbers to be created

2879
01:59:42,780 --> 01:59:46,500
interrupts 0 through 7 are correspond to

2880
01:59:46,500 --> 01:59:49,380
the pins of the master chip

2881
01:59:49,380 --> 01:59:53,099
and interrupts 8 through 15 correspond

2882
01:59:53,099 --> 01:59:56,280
to the pins of the slave chip now it

2883
01:59:56,280 --> 01:59:58,920
should be noted that since pin 2 of The

2884
01:59:58,920 --> 02:00:01,739
Master chip handles the slave chip

2885
02:00:01,739 --> 02:00:04,500
that the master programmable interrupt

2886
02:00:04,500 --> 02:00:07,739
controller only supports an effective

2887
02:00:07,739 --> 02:00:09,480
seven interrupts

2888
02:00:09,480 --> 02:00:12,540
so there are only 15 usable interrupt

2889
02:00:12,540 --> 02:00:15,659
Hardware lines for devices

2890
02:00:15,659 --> 02:00:19,260
and these are numbered 0 through 15 but

2891
02:00:19,260 --> 02:00:21,900
we have to skip the number two

2892
02:00:21,900 --> 02:00:25,619
now historically pin number zero which

2893
02:00:25,619 --> 02:00:28,139
corresponds in software terms to what we

2894
02:00:28,139 --> 02:00:32,280
call interrupt request line or irq0 was

2895
02:00:32,280 --> 02:00:34,380
connected to the timer

2896
02:00:34,380 --> 02:00:37,080
interrupt request line 1 was connected

2897
02:00:37,080 --> 02:00:39,000
to the keyboard

2898
02:00:39,000 --> 02:00:41,699
different Isa and PCI devices could then

2899
02:00:41,699 --> 02:00:44,219
use the remainder of the master chip by

2900
02:00:44,219 --> 02:00:46,080
connecting to irq lines three through

2901
02:00:46,080 --> 02:00:47,460
seven

2902
02:00:47,460 --> 02:00:49,920
on the slave chip pin 0 which

2903
02:00:49,920 --> 02:00:53,460
corresponds to irq8 was connected to the

2904
02:00:53,460 --> 02:00:56,880
real-time clock pin 4 corresponding to

2905
02:00:56,880 --> 02:01:02,280
irq12 was connected to a PS2 Mouse

2906
02:01:02,280 --> 02:01:05,719
pin 5 or irq13 connected to the math

2907
02:01:05,719 --> 02:01:08,639
coprocessor which was a separate

2908
02:01:08,639 --> 02:01:11,400
component from the main CPU in earlier

2909
02:01:11,400 --> 02:01:13,139
PCS

2910
02:01:13,139 --> 02:01:15,840
and then pin 6 and 7 corresponding to

2911
02:01:15,840 --> 02:01:19,320
irq lines 14 and 15 connected to the IDE

2912
02:01:19,320 --> 02:01:22,560
controllers these were used for disk and

2913
02:01:22,560 --> 02:01:25,679
eventually for optical devices

2914
02:01:25,679 --> 02:01:29,280
this left pins one through three on the

2915
02:01:29,280 --> 02:01:32,300
slave controller or irqs 9 through 11

2916
02:01:32,300 --> 02:01:36,780
available for Hardware devices

2917
02:01:36,780 --> 02:01:39,000
now these interrupt lines on the

2918
02:01:39,000 --> 02:01:41,940
motherboard were actually circuit traces

2919
02:01:41,940 --> 02:01:44,280
these were conductive paths

2920
02:01:44,280 --> 02:01:46,139
etched into the motherboard

2921
02:01:46,139 --> 02:01:49,560
that allowed interrupts to be received

2922
02:01:49,560 --> 02:01:52,340
from devices

2923
02:01:52,380 --> 02:01:55,560
there were 15 lines available of the 16

2924
02:01:55,560 --> 02:01:58,080
that could be used by devices with lines

2925
02:01:58,080 --> 02:02:01,320
0 and 1 reserved for the timer and a PS2

2926
02:02:01,320 --> 02:02:03,840
keyboard respectively actually even

2927
02:02:03,840 --> 02:02:06,300
before the PS2 reservation the original

2928
02:02:06,300 --> 02:02:09,119
at keyboard

2929
02:02:09,119 --> 02:02:12,360
Isa and PCI add-in devices actually had

2930
02:02:12,360 --> 02:02:15,179
to share interrupt request lines and

2931
02:02:15,179 --> 02:02:16,560
this sharing could lead to Hardware

2932
02:02:16,560 --> 02:02:19,080
conflicts that could lock up the system

2933
02:02:19,080 --> 02:02:22,199
it was thus up to the system owner to

2934
02:02:22,199 --> 02:02:24,420
manage the sharing by setting little

2935
02:02:24,420 --> 02:02:27,719
jumpers on the add-in cards so that the

2936
02:02:27,719 --> 02:02:31,440
cards were using different irq lines

2937
02:02:31,440 --> 02:02:33,659
there were also performance issues when

2938
02:02:33,659 --> 02:02:35,820
irq lines were shared because the

2939
02:02:35,820 --> 02:02:37,440
operating system actually had to pull

2940
02:02:37,440 --> 02:02:40,380
each device sharing an irq to determine

2941
02:02:40,380 --> 02:02:42,179
which device it was that raised the

2942
02:02:42,179 --> 02:02:45,000
interrupt polling was still necessary in

2943
02:02:45,000 --> 02:02:46,560
order to receive any kind of data from

2944
02:02:46,560 --> 02:02:48,659
the device regardless of whether it was

2945
02:02:48,659 --> 02:02:51,960
sharing an interrupt line or not

2946
02:02:51,960 --> 02:02:54,360
on Modern systems a completely different

2947
02:02:54,360 --> 02:02:56,880
interrupt mechanism is used

2948
02:02:56,880 --> 02:03:00,540
and this mechanism has a set of memory

2949
02:03:00,540 --> 02:03:02,760
registers on what's called an advanced

2950
02:03:02,760 --> 02:03:04,860
programmable interrupt control

2951
02:03:04,860 --> 02:03:07,080
in this set of memory registers is

2952
02:03:07,080 --> 02:03:09,659
connected to a single shared bus that

2953
02:03:09,659 --> 02:03:12,480
each device on the system can use to

2954
02:03:12,480 --> 02:03:15,239
raise an interrupt message by writing

2955
02:03:15,239 --> 02:03:16,800
that message into one of the memory

2956
02:03:16,800 --> 02:03:17,940
registers

2957
02:03:17,940 --> 02:03:19,679
these are called message signal

2958
02:03:19,679 --> 02:03:22,679
interrupts using the MSI and MSI X

2959
02:03:22,679 --> 02:03:24,560
specifications

2960
02:03:24,560 --> 02:03:27,000
essentially each device here I have a

2961
02:03:27,000 --> 02:03:30,659
timer RTC USB host controller SATA

2962
02:03:30,659 --> 02:03:33,599
controller is attached to the bus

2963
02:03:33,599 --> 02:03:37,500
and indicates its interest in raising an

2964
02:03:37,500 --> 02:03:40,320
interrupt to the apic by sending a

2965
02:03:40,320 --> 02:03:42,300
message over that bus

2966
02:03:42,300 --> 02:03:45,360
now this message does not contain any

2967
02:03:45,360 --> 02:03:48,420
data it's only a request for attention

2968
02:03:48,420 --> 02:03:51,980
if the CPU has to be involved in the

2969
02:03:51,980 --> 02:03:54,300
operation of sending or receiving

2970
02:03:54,300 --> 02:03:57,900
information then the CPU actually has to

2971
02:03:57,900 --> 02:03:59,760
contact the device in other words pull

2972
02:03:59,760 --> 02:04:01,500
it directly

2973
02:04:01,500 --> 02:04:04,020
there is a way around this called direct

2974
02:04:04,020 --> 02:04:07,320
memory access or dma transfers which are

2975
02:04:07,320 --> 02:04:09,800
used extensively on PCI Express devices

2976
02:04:09,800 --> 02:04:14,040
the register on the Apec stores the

2977
02:04:14,040 --> 02:04:16,619
request for attention until such time as

2978
02:04:16,619 --> 02:04:19,199
the operating system handles the

2979
02:04:19,199 --> 02:04:20,880
interrupt request and then that message

2980
02:04:20,880 --> 02:04:22,920
is cleared from the apic

2981
02:04:22,920 --> 02:04:25,260
this is the only interrupt mechanism

2982
02:04:25,260 --> 02:04:27,960
that's available on PCI Express buses

2983
02:04:27,960 --> 02:04:30,960
there are no Hardware interrupt lines

2984
02:04:30,960 --> 02:04:33,960
however a number of motherboards still

2985
02:04:33,960 --> 02:04:36,719
have interrupt lines physical interrupt

2986
02:04:36,719 --> 02:04:40,739
lines and have physical pick pens

2987
02:04:40,739 --> 02:04:43,139
so that they can support Legacy devices

2988
02:04:43,139 --> 02:04:45,599
your number of specialty Legacy devices

2989
02:04:45,599 --> 02:04:49,199
still in use that need to be supported

2990
02:04:49,199 --> 02:04:51,960
message signal interrupts do solve a

2991
02:04:51,960 --> 02:04:53,400
number of problems with interrupt

2992
02:04:53,400 --> 02:04:55,080
request sharing the original

2993
02:04:55,080 --> 02:04:58,080
specification allows each device to use

2994
02:04:58,080 --> 02:05:00,900
any one of 32 irq lines

2995
02:05:00,900 --> 02:05:04,320
the MSI X specification will allow each

2996
02:05:04,320 --> 02:05:08,639
device to use up to 2048 virtual lines

2997
02:05:08,639 --> 02:05:10,980
virtual interrupt request offers

2998
02:05:10,980 --> 02:05:13,980
essentially and this allows for Less

2999
02:05:13,980 --> 02:05:16,800
contention and reduces the need to share

3000
02:05:16,800 --> 02:05:19,980
interrupt request numbers by device thus

3001
02:05:19,980 --> 02:05:22,500
reduces the amount of time necessary for

3002
02:05:22,500 --> 02:05:24,599
the CPU to determine which device wanted

3003
02:05:24,599 --> 02:05:26,280
attention

3004
02:05:26,280 --> 02:05:29,340
so main thing to take away from this is

3005
02:05:29,340 --> 02:05:31,860
that the interrupt controller and the

3006
02:05:31,860 --> 02:05:34,739
interrupt request mechanism only allows

3007
02:05:34,739 --> 02:05:36,599
the device to raise a signal that says

3008
02:05:36,599 --> 02:05:37,800
it wants attention

3009
02:05:37,800 --> 02:05:40,860
it's up to the CPU or on certain buses

3010
02:05:40,860 --> 02:05:43,560
up the device and the memory controller

3011
02:05:43,560 --> 02:05:45,780
to get the information out of that

3012
02:05:45,780 --> 02:05:48,780
device and into memory in this lecture I

3013
02:05:48,780 --> 02:05:50,580
will introduce use cases

3014
02:05:50,580 --> 02:05:53,219
use cases are a type of requirements

3015
02:05:53,219 --> 02:05:54,659
document that provides narrative

3016
02:05:54,659 --> 02:05:57,060
descriptions of scenarios that will be

3017
02:05:57,060 --> 02:05:59,900
handled by the system

3018
02:05:59,940 --> 02:06:01,739
I will be discussing the elements that

3019
02:06:01,739 --> 02:06:03,420
make up a use case

3020
02:06:03,420 --> 02:06:05,219
these elements include the trigger

3021
02:06:05,219 --> 02:06:07,639
actors in The use case

3022
02:06:07,639 --> 02:06:10,380
preconditions steps in the process

3023
02:06:10,380 --> 02:06:13,260
described by the use case guarantees

3024
02:06:13,260 --> 02:06:15,900
made to the stakeholders and any quality

3025
02:06:15,900 --> 02:06:20,300
requirements applicable to the use kits

3026
02:06:21,239 --> 02:06:24,239
use cases are one type of requirements

3027
02:06:24,239 --> 02:06:25,199
document

3028
02:06:25,199 --> 02:06:27,179
they provide a written narrative that

3029
02:06:27,179 --> 02:06:28,560
describes how the system under

3030
02:06:28,560 --> 02:06:31,619
discussion or sud will behave in given

3031
02:06:31,619 --> 02:06:33,119
scenarios

3032
02:06:33,119 --> 02:06:35,460
after the system is implemented the sud

3033
02:06:35,460 --> 02:06:37,320
could be tested by following the use

3034
02:06:37,320 --> 02:06:39,780
cases and checking the behavior of the

3035
02:06:39,780 --> 02:06:41,520
system matches the requirements for the

3036
02:06:41,520 --> 02:06:43,320
given scenario

3037
02:06:43,320 --> 02:06:45,360
it is important to remember that a use

3038
02:06:45,360 --> 02:06:47,760
case is only one type of requirements

3039
02:06:47,760 --> 02:06:48,780
document

3040
02:06:48,780 --> 02:06:51,000
other types of requirements documents

3041
02:06:51,000 --> 02:06:53,520
such as the system conceptualization or

3042
02:06:53,520 --> 02:06:58,159
user interface specification do exist

3043
02:06:58,260 --> 02:07:01,139
the primary function of a use case is to

3044
02:07:01,139 --> 02:07:02,940
describe how the sud responds to

3045
02:07:02,940 --> 02:07:04,619
interaction from a stakeholder in the

3046
02:07:04,619 --> 02:07:05,639
system

3047
02:07:05,639 --> 02:07:08,460
in other words a use case specifies what

3048
02:07:08,460 --> 02:07:11,760
the set is to do in different scenarios

3049
02:07:11,760 --> 02:07:14,580
for example a use case for a database

3050
02:07:14,580 --> 02:07:16,860
system might specify what steps are to

3051
02:07:16,860 --> 02:07:18,480
be taken whenever the database

3052
02:07:18,480 --> 02:07:20,639
administrator asks to update a record in

3053
02:07:20,639 --> 02:07:22,980
the table on the other hand a use case

3054
02:07:22,980 --> 02:07:24,719
might specify that certain information

3055
02:07:24,719 --> 02:07:27,420
needs to be updated whenever a customer

3056
02:07:27,420 --> 02:07:30,420
makes a new order from a company

3057
02:07:30,420 --> 02:07:32,639
these two scenarios illustrate the

3058
02:07:32,639 --> 02:07:34,800
different levels at which use cases can

3059
02:07:34,800 --> 02:07:35,880
be written

3060
02:07:35,880 --> 02:07:38,040
at the high level we have business use

3061
02:07:38,040 --> 02:07:40,260
cases that describe the business process

3062
02:07:40,260 --> 02:07:42,300
that must be carried out

3063
02:07:42,300 --> 02:07:45,060
without specifying any details of the

3064
02:07:45,060 --> 02:07:46,380
system

3065
02:07:46,380 --> 02:07:48,719
these use cases are also sometimes

3066
02:07:48,719 --> 02:07:51,659
called essential use cases

3067
02:07:51,659 --> 02:07:54,420
lower level use cases or system use

3068
02:07:54,420 --> 02:07:57,000
cases describe how the sun will behave

3069
02:07:57,000 --> 02:08:00,000
in specific situations these use cases

3070
02:08:00,000 --> 02:08:02,040
incorporate details of the technology

3071
02:08:02,040 --> 02:08:04,820
being used

3072
02:08:05,580 --> 02:08:08,699
use cases may have either black box or

3073
02:08:08,699 --> 02:08:10,679
white box scope

3074
02:08:10,679 --> 02:08:13,320
all business use cases and many system

3075
02:08:13,320 --> 02:08:16,739
use cases use Black Box scope

3076
02:08:16,739 --> 02:08:18,840
this means they treat the system as a

3077
02:08:18,840 --> 02:08:20,460
mystery device

3078
02:08:20,460 --> 02:08:22,440
this specify how the system will behave

3079
02:08:22,440 --> 02:08:24,599
under given conditions but they leave

3080
02:08:24,599 --> 02:08:26,699
out all the details of how the behaviors

3081
02:08:26,699 --> 02:08:28,739
will be implemented

3082
02:08:28,739 --> 02:08:30,900
some system use cases on the other hand

3083
02:08:30,900 --> 02:08:32,820
may be written from a white box

3084
02:08:32,820 --> 02:08:34,619
perspective

3085
02:08:34,619 --> 02:08:37,199
the easiest cases detail some of the

3086
02:08:37,199 --> 02:08:39,719
internal operations of the sud such as

3087
02:08:39,719 --> 02:08:41,760
specific protocols or algorithms that

3088
02:08:41,760 --> 02:08:43,139
will be used

3089
02:08:43,139 --> 02:08:45,420
white box use cases are especially

3090
02:08:45,420 --> 02:08:46,980
useful for describing how different

3091
02:08:46,980 --> 02:08:49,320
components of the sud will interoperate

3092
02:08:49,320 --> 02:08:51,800
with each other

3093
02:08:52,679 --> 02:08:55,440
when writing use case narratives it is

3094
02:08:55,440 --> 02:08:56,940
customary to include a number of

3095
02:08:56,940 --> 02:08:59,099
standard pieces of information

3096
02:08:59,099 --> 02:09:01,260
the specific entries and the Order of

3097
02:09:01,260 --> 02:09:03,900
the entries will vary by organization

3098
02:09:03,900 --> 02:09:06,300
in most cases you will write use cases

3099
02:09:06,300 --> 02:09:09,119
by following a template

3100
02:09:09,119 --> 02:09:11,639
a sample use case template might contain

3101
02:09:11,639 --> 02:09:13,800
items such as the trigger for the East

3102
02:09:13,800 --> 02:09:16,560
case a list of actors involved in the

3103
02:09:16,560 --> 02:09:18,780
use case and a list of preconditions

3104
02:09:18,780 --> 02:09:20,580
that must be true before the East case

3105
02:09:20,580 --> 02:09:22,560
steps can begin

3106
02:09:22,560 --> 02:09:24,900
use case then specifies the system

3107
02:09:24,900 --> 02:09:26,760
behavior is a series of steps

3108
02:09:26,760 --> 02:09:29,099
illustrating how the primary actor

3109
02:09:29,099 --> 02:09:31,139
interacts with the sud

3110
02:09:31,139 --> 02:09:33,300
at the end of the scenario described by

3111
02:09:33,300 --> 02:09:35,820
the use case certain guarantees are made

3112
02:09:35,820 --> 02:09:37,920
to the stakeholders about the state of

3113
02:09:37,920 --> 02:09:39,420
the system

3114
02:09:39,420 --> 02:09:42,000
the use case might also specify quality

3115
02:09:42,000 --> 02:09:44,159
requirements such as the maximum amount

3116
02:09:44,159 --> 02:09:48,139
of time allowed to complete the scenario

3117
02:09:48,420 --> 02:09:50,639
in general a use case will have a

3118
02:09:50,639 --> 02:09:52,080
triggering condition

3119
02:09:52,080 --> 02:09:54,300
this trigger corresponds to the user

3120
02:09:54,300 --> 02:09:56,340
wishing to perform some action using the

3121
02:09:56,340 --> 02:09:57,500
sud

3122
02:09:57,500 --> 02:09:59,820
alternatively this trigger could be the

3123
02:09:59,820 --> 02:10:01,260
results of an event that occurs

3124
02:10:01,260 --> 02:10:03,420
somewhere in the system or outside the

3125
02:10:03,420 --> 02:10:05,480
system

3126
02:10:05,480 --> 02:10:07,560
preconditions are statements that are

3127
02:10:07,560 --> 02:10:09,300
assumed to be true when executing the

3128
02:10:09,300 --> 02:10:11,820
use case these conditions are not

3129
02:10:11,820 --> 02:10:15,840
checked anywhere in the use case

3130
02:10:15,840 --> 02:10:17,880
use cases guarantee that certain

3131
02:10:17,880 --> 02:10:19,560
conditions will be true at the end of a

3132
02:10:19,560 --> 02:10:20,580
process

3133
02:10:20,580 --> 02:10:22,560
these guarantees are promises made to

3134
02:10:22,560 --> 02:10:24,300
the stakeholder as to how the system

3135
02:10:24,300 --> 02:10:26,460
will behave

3136
02:10:26,460 --> 02:10:28,980
ideally the process would be successful

3137
02:10:28,980 --> 02:10:31,380
and the stud will deliver all guarantees

3138
02:10:31,380 --> 02:10:33,420
presented by the use case

3139
02:10:33,420 --> 02:10:35,820
however if an error or unexpected

3140
02:10:35,820 --> 02:10:37,560
condition occurs somewhere during the

3141
02:10:37,560 --> 02:10:39,900
process some minimal guarantees about

3142
02:10:39,900 --> 02:10:43,380
the state of the system should be given

3143
02:10:43,380 --> 02:10:46,520
actors in eu's case are external persons

3144
02:10:46,520 --> 02:10:49,260
systems or other entities that interact

3145
02:10:49,260 --> 02:10:51,239
with Assad in some way

3146
02:10:51,239 --> 02:10:53,639
these actors include the user or users

3147
02:10:53,639 --> 02:10:56,580
of the system any entities upon which

3148
02:10:56,580 --> 02:10:58,560
the system depends in order to carry out

3149
02:10:58,560 --> 02:11:00,719
a business function and any other

3150
02:11:00,719 --> 02:11:04,260
systems with which the sud interfaces

3151
02:11:04,260 --> 02:11:06,540
the actor that performs the actions in

3152
02:11:06,540 --> 02:11:09,360
the use case is called the primary actor

3153
02:11:09,360 --> 02:11:11,940
in a general sense the primary actor is

3154
02:11:11,940 --> 02:11:13,440
the user of the system that will be

3155
02:11:13,440 --> 02:11:14,400
created

3156
02:11:14,400 --> 02:11:17,580
thus by definition the primary actor is

3157
02:11:17,580 --> 02:11:20,820
also a stakeholder in the system

3158
02:11:20,820 --> 02:11:23,040
supporting actors have roles in carrying

3159
02:11:23,040 --> 02:11:25,500
out some operation of the system but

3160
02:11:25,500 --> 02:11:28,320
they do not utilize the system directly

3161
02:11:28,320 --> 02:11:30,480
in a business level use case the

3162
02:11:30,480 --> 02:11:32,099
supporting actors have important roles

3163
02:11:32,099 --> 02:11:34,380
in the business process but they do not

3164
02:11:34,380 --> 02:11:38,060
carry out the process directly

3165
02:11:38,219 --> 02:11:40,800
now use case documents are narrative

3166
02:11:40,800 --> 02:11:43,679
texts they tell a story about how the

3167
02:11:43,679 --> 02:11:45,179
system is going to act under given

3168
02:11:45,179 --> 02:11:46,739
scenarios

3169
02:11:46,739 --> 02:11:48,480
in order to communicate the story

3170
02:11:48,480 --> 02:11:50,760
effectively there are certain rows of

3171
02:11:50,760 --> 02:11:53,219
thumb that should be followed when

3172
02:11:53,219 --> 02:11:55,560
writing use cases

3173
02:11:55,560 --> 02:11:58,619
first use Simple language with active

3174
02:11:58,619 --> 02:12:01,320
voice and simple sentence constructs

3175
02:12:01,320 --> 02:12:04,500
for example say the user sits down at

3176
02:12:04,500 --> 02:12:06,780
the keyboard instead of

3177
02:12:06,780 --> 02:12:10,380
keyboard is presented to the user

3178
02:12:10,380 --> 02:12:12,900
second do not include user interface

3179
02:12:12,900 --> 02:12:14,699
elements in the use case

3180
02:12:14,699 --> 02:12:17,659
say the user enters data into the system

3181
02:12:17,659 --> 02:12:20,460
instead of the user types characters

3182
02:12:20,460 --> 02:12:22,320
into a text box in the middle of the

3183
02:12:22,320 --> 02:12:23,580
screen

3184
02:12:23,580 --> 02:12:25,980
leave the user interface designed

3185
02:12:25,980 --> 02:12:29,219
separate specifications or prototypes

3186
02:12:29,219 --> 02:12:31,679
finally every use case should end with

3187
02:12:31,679 --> 02:12:33,540
at least one guarantee about the state

3188
02:12:33,540 --> 02:12:35,099
of the system

3189
02:12:35,099 --> 02:12:37,560
if the process is successful how does

3190
02:12:37,560 --> 02:12:39,360
the system react

3191
02:12:39,360 --> 02:12:42,000
if the process fails what is the

3192
02:12:42,000 --> 02:12:43,440
condition of the system after the

3193
02:12:43,440 --> 02:12:44,760
failure

3194
02:12:44,760 --> 02:12:47,099
remember that computer software can and

3195
02:12:47,099 --> 02:12:49,199
does periodically fail

3196
02:12:49,199 --> 02:12:51,420
also remember that human users are

3197
02:12:51,420 --> 02:12:53,699
guaranteed to fail and that the system

3198
02:12:53,699 --> 02:12:56,460
should be made robust or as idiot proof

3199
02:12:56,460 --> 02:12:59,000
as possible

3200
02:12:59,579 --> 02:13:01,500
now you may be aware that the unified

3201
02:13:01,500 --> 02:13:03,420
modeling language provides a graphical

3202
02:13:03,420 --> 02:13:05,159
use case diagram

3203
02:13:05,159 --> 02:13:07,440
you may also believe that these diagrams

3204
02:13:07,440 --> 02:13:09,239
will save time compared to writing use

3205
02:13:09,239 --> 02:13:11,099
case narratives

3206
02:13:11,099 --> 02:13:13,260
unfortunately graphical use case

3207
02:13:13,260 --> 02:13:15,300
diagrams do not provide much information

3208
02:13:15,300 --> 02:13:17,880
about the process being described

3209
02:13:17,880 --> 02:13:19,380
they illustrate a stick figure

3210
02:13:19,380 --> 02:13:21,840
representing a primary actor

3211
02:13:21,840 --> 02:13:24,060
executing a use case

3212
02:13:24,060 --> 02:13:26,579
represented by a box containing the use

3213
02:13:26,579 --> 02:13:28,199
case title

3214
02:13:28,199 --> 02:13:30,900
however the graphical diagrams do not

3215
02:13:30,900 --> 02:13:34,500
provide any detail about the process

3216
02:13:34,500 --> 02:13:37,079
as such the diagrams are useful for

3217
02:13:37,079 --> 02:13:39,840
providing indexes into the use case

3218
02:13:39,840 --> 02:13:42,540
narratives but they do not add any real

3219
02:13:42,540 --> 02:13:45,599
value to the use cases themselves a

3220
02:13:45,599 --> 02:13:47,820
simple textual index with numbered use

3221
02:13:47,820 --> 02:13:49,619
cases would accomplish the same Purpose

3222
02:13:49,619 --> 02:13:52,820
with less effort

3223
02:13:52,980 --> 02:13:55,679
agile methods particularly extreme

3224
02:13:55,679 --> 02:13:57,780
programming have extremely short

3225
02:13:57,780 --> 02:13:59,940
iteration times that are not conducive

3226
02:13:59,940 --> 02:14:02,040
to formal use cases

3227
02:14:02,040 --> 02:14:04,500
one lightweight alternative to use cases

3228
02:14:04,500 --> 02:14:07,020
is the user story which is a short and

3229
02:14:07,020 --> 02:14:08,820
simple way of expressing a particular

3230
02:14:08,820 --> 02:14:10,199
requirement

3231
02:14:10,199 --> 02:14:12,060
user stories are written for each

3232
02:14:12,060 --> 02:14:14,219
scenario similar to the approach used in

3233
02:14:14,219 --> 02:14:15,480
use cases

3234
02:14:15,480 --> 02:14:18,360
however instead of a formal document the

3235
02:14:18,360 --> 02:14:20,460
user story simply expresses what a

3236
02:14:20,460 --> 02:14:22,380
primary actor would like to achieve in

3237
02:14:22,380 --> 02:14:23,760
the system

3238
02:14:23,760 --> 02:14:25,260
for example

3239
02:14:25,260 --> 02:14:27,060
a user story for a database

3240
02:14:27,060 --> 02:14:28,860
administrator might read

3241
02:14:28,860 --> 02:14:31,739
as a database administrator I want to be

3242
02:14:31,739 --> 02:14:33,360
able to perform an operation that

3243
02:14:33,360 --> 02:14:35,940
updates the name address and age fields

3244
02:14:35,940 --> 02:14:38,579
in a single transaction

3245
02:14:38,579 --> 02:14:41,159
user stories typically omit some design

3246
02:14:41,159 --> 02:14:43,320
details but these details can be

3247
02:14:43,320 --> 02:14:44,880
discovered later as the software is

3248
02:14:44,880 --> 02:14:46,560
developed

3249
02:14:46,560 --> 02:14:48,960
also these stories can be either black

3250
02:14:48,960 --> 02:14:50,900
box or white box in perspective

3251
02:14:50,900 --> 02:14:52,980
depending upon the needs of the

3252
02:14:52,980 --> 02:14:55,639
development team

3253
02:14:55,920 --> 02:14:58,980
in summary es cases describe a scenario

3254
02:14:58,980 --> 02:15:01,560
in which a primary actor interacts with

3255
02:15:01,560 --> 02:15:03,480
the system under discussion

3256
02:15:03,480 --> 02:15:05,699
each use case is named according to the

3257
02:15:05,699 --> 02:15:08,099
process it describes in use cases

3258
02:15:08,099 --> 02:15:10,079
generally have triggers indicating the

3259
02:15:10,079 --> 02:15:11,820
conditions under which the process is

3260
02:15:11,820 --> 02:15:13,079
applicable

3261
02:15:13,079 --> 02:15:15,599
use cases May specify preconditions

3262
02:15:15,599 --> 02:15:17,940
which are assumed to be true prior to

3263
02:15:17,940 --> 02:15:20,639
execution of the use case

3264
02:15:20,639 --> 02:15:23,760
use cases provide an outline of the

3265
02:15:23,760 --> 02:15:26,400
steps required in the process along with

3266
02:15:26,400 --> 02:15:28,139
a set of guarantees about the state of

3267
02:15:28,139 --> 02:15:30,960
the sud after the scenario is finished

3268
02:15:30,960 --> 02:15:33,480
quality requirements such as execution

3269
02:15:33,480 --> 02:15:37,079
time limits may also be specified

3270
02:15:37,079 --> 02:15:39,360
Agile development methods especially

3271
02:15:39,360 --> 02:15:42,420
extreme programming disfavor use cases

3272
02:15:42,420 --> 02:15:44,340
due to the time involved in creating the

3273
02:15:44,340 --> 02:15:45,659
documentation

3274
02:15:45,659 --> 02:15:47,579
the short iteration development

3275
02:15:47,579 --> 02:15:50,040
techniques use user stories and other

3276
02:15:50,040 --> 02:15:52,500
lightweight methods instead in this

3277
02:15:52,500 --> 02:15:54,540
lecture I'm going to discuss interrupt

3278
02:15:54,540 --> 02:15:55,619
handling

3279
02:15:55,619 --> 02:15:57,719
I'm going to begin by discussing

3280
02:15:57,719 --> 02:16:00,119
interrupt handling at the hardware level

3281
02:16:00,119 --> 02:16:02,579
and then move on to Features provided by

3282
02:16:02,579 --> 02:16:05,520
the CPU and finally features of the

3283
02:16:05,520 --> 02:16:09,060
operating system for handling interrupts

3284
02:16:09,060 --> 02:16:11,639
at the hardware level devices are

3285
02:16:11,639 --> 02:16:13,619
connected either via traces on the

3286
02:16:13,619 --> 02:16:16,739
motherboard or via a shared messaging

3287
02:16:16,739 --> 02:16:19,079
bus to the advanced programmable

3288
02:16:19,079 --> 02:16:21,060
interrupt controller

3289
02:16:21,060 --> 02:16:23,880
the CPU checks for Hardware interrupt

3290
02:16:23,880 --> 02:16:26,699
signals from this controller after each

3291
02:16:26,699 --> 02:16:29,520
user mode instruction is processed so

3292
02:16:29,520 --> 02:16:31,639
after each instruction is executed

3293
02:16:31,639 --> 02:16:34,558
running some particular program on the

3294
02:16:34,558 --> 02:16:35,280
system

3295
02:16:35,280 --> 02:16:37,799
the CPU actually checks to see if there

3296
02:16:37,799 --> 02:16:39,058
are any interrupts that need to be

3297
02:16:39,058 --> 02:16:40,320
processed

3298
02:16:40,320 --> 02:16:43,620
if an interrupt signal is present then a

3299
02:16:43,620 --> 02:16:46,080
kernel routine is called by the CPU in

3300
02:16:46,080 --> 02:16:48,299
order to handle this interrupt

3301
02:16:48,299 --> 02:16:50,879
the interrupt dispatch routine if it's

3302
02:16:50,879 --> 02:16:53,700
not implemented directly in Hardware is

3303
02:16:53,700 --> 02:16:56,160
actually a compact and fast routine that

3304
02:16:56,160 --> 02:16:58,500
could be implemented in the kernel often

3305
02:16:58,500 --> 02:17:00,660
coded in Assembly Language it has to be

3306
02:17:00,660 --> 02:17:02,218
that fast

3307
02:17:02,218 --> 02:17:05,160
the specific interrupt Handler is always

3308
02:17:05,160 --> 02:17:06,780
a kernel routine

3309
02:17:06,780 --> 02:17:09,420
or in the case of a micro kernel an

3310
02:17:09,420 --> 02:17:12,058
external server routine in this specific

3311
02:17:12,058 --> 02:17:14,099
Handler depends upon the type of

3312
02:17:14,099 --> 02:17:15,959
interrupt received these are typically

3313
02:17:15,959 --> 02:17:18,000
coded in C

3314
02:17:18,000 --> 02:17:21,478
so once again the fetch execute cycle we

3315
02:17:21,478 --> 02:17:23,760
check for an interrupt pending after

3316
02:17:23,760 --> 02:17:26,459
each instruction is executed

3317
02:17:26,459 --> 02:17:28,978
if there is an interrupt pending we

3318
02:17:28,978 --> 02:17:31,740
escalate privilege to Kernel mode

3319
02:17:31,740 --> 02:17:33,718
push the program counter onto the stack

3320
02:17:33,718 --> 02:17:35,638
in other words save it so we can resume

3321
02:17:35,638 --> 02:17:38,040
from that point in whatever program

3322
02:17:38,040 --> 02:17:39,599
we're interrupting

3323
02:17:39,599 --> 02:17:42,420
and then go and handle the interrupt we

3324
02:17:42,420 --> 02:17:44,580
do this by loading the program counter

3325
02:17:44,580 --> 02:17:47,638
the new program counter that is from a

3326
02:17:47,638 --> 02:17:50,519
fixed memory location provided to us by

3327
02:17:50,519 --> 02:17:53,218
the interrupt Vector table

3328
02:17:53,218 --> 02:17:55,620
the interrupt Vector table gives us the

3329
02:17:55,620 --> 02:17:57,420
address of all the different interrupt

3330
02:17:57,420 --> 02:18:00,359
handlers we need a separate Handler for

3331
02:18:00,359 --> 02:18:02,580
each type of interrupt the clock

3332
02:18:02,580 --> 02:18:04,260
requires different logic from the

3333
02:18:04,260 --> 02:18:07,379
keyboard for example other devices such

3334
02:18:07,379 --> 02:18:09,478
as say a webcam attached to your

3335
02:18:09,478 --> 02:18:11,939
computer needs different logic in order

3336
02:18:11,939 --> 02:18:14,700
to process messages from it so we have

3337
02:18:14,700 --> 02:18:16,679
different interrupt handlers for each of

3338
02:18:16,679 --> 02:18:19,138
these different devices

3339
02:18:19,138 --> 02:18:22,320
table simply stores the addresses of

3340
02:18:22,320 --> 02:18:24,959
each Handler and in our monolithic

3341
02:18:24,959 --> 02:18:27,120
kernel case the handlers are actually

3342
02:18:27,120 --> 02:18:29,459
part of the kernel and are mapped into

3343
02:18:29,459 --> 02:18:32,179
kernel memory space

3344
02:18:32,179 --> 02:18:36,179
the interrupt Vector table consists of a

3345
02:18:36,179 --> 02:18:38,519
list of each of these addresses for

3346
02:18:38,519 --> 02:18:42,240
kernel handles and conceptually is

3347
02:18:42,240 --> 02:18:45,179
mapped into both kernel memory and user

3348
02:18:45,179 --> 02:18:47,398
memory so that it can be accessed

3349
02:18:47,398 --> 02:18:49,799
quickly and historically these started

3350
02:18:49,799 --> 02:18:53,218
at address 0. however the mappings are

3351
02:18:53,218 --> 02:18:56,580
different depending on the architecture

3352
02:18:56,580 --> 02:18:59,580
on Intel based systems we have something

3353
02:18:59,580 --> 02:19:02,580
called the interrupt descriptor table

3354
02:19:02,580 --> 02:19:05,340
and the IDT provides special

3355
02:19:05,340 --> 02:19:07,740
instructions and data structures that

3356
02:19:07,740 --> 02:19:10,260
are actually managed by the CPU itself

3357
02:19:10,260 --> 02:19:12,840
so the interrupt handling can be as fast

3358
02:19:12,840 --> 02:19:15,299
as possible and protection rings can be

3359
02:19:15,299 --> 02:19:17,040
changed automatically

3360
02:19:17,040 --> 02:19:19,500
the IET is simply a reserved block of

3361
02:19:19,500 --> 02:19:24,420
RAM used by the CPU to jump quickly to a

3362
02:19:24,420 --> 02:19:26,760
specific interrupt Handler

3363
02:19:26,760 --> 02:19:30,540
this IDT is mapped into kernel space

3364
02:19:30,540 --> 02:19:32,700
which was originally beginning in

3365
02:19:32,700 --> 02:19:34,978
address zero but this mapping is

3366
02:19:34,978 --> 02:19:37,019
actually flexible with modern CPUs and

3367
02:19:37,019 --> 02:19:38,760
can be mapped into other parts of the

3368
02:19:38,760 --> 02:19:40,260
memory space

3369
02:19:40,260 --> 02:19:43,200
the first 32 entries of the IDT are

3370
02:19:43,200 --> 02:19:45,299
actually not used for interrupts per se

3371
02:19:45,299 --> 02:19:48,179
but they're actually used for CPU fault

3372
02:19:48,179 --> 02:19:50,520
handlers and then the interrupt Vector

3373
02:19:50,520 --> 02:19:53,340
table part of the data structure begins

3374
02:19:53,340 --> 02:19:57,680
after the CPU fault Handler table

3375
02:19:57,859 --> 02:20:00,660
when we actually go to handle interrupts

3376
02:20:00,660 --> 02:20:03,479
the handling occurs in the kernel and

3377
02:20:03,479 --> 02:20:05,340
this is done with two levels of

3378
02:20:05,340 --> 02:20:07,680
interrupt handling the fast interrupt

3379
02:20:07,680 --> 02:20:10,439
Handler and the slow interrupt Handler

3380
02:20:10,439 --> 02:20:12,960
the fast interrupt Handler is the piece

3381
02:20:12,960 --> 02:20:15,780
of code that's invoked directly from the

3382
02:20:15,780 --> 02:20:17,340
interrupt Vector table whenever an

3383
02:20:17,340 --> 02:20:19,380
interrupt occurs this is the piece of

3384
02:20:19,380 --> 02:20:21,899
code that the CPU is just going to jump

3385
02:20:21,899 --> 02:20:25,080
to when an interrupt occurs

3386
02:20:25,080 --> 02:20:27,840
fast handlers execute in real time and

3387
02:20:27,840 --> 02:20:29,399
they're called Fast interrupt handlers

3388
02:20:29,399 --> 02:20:31,680
because they need to be fast the

3389
02:20:31,680 --> 02:20:33,120
execution of one of these interrupt

3390
02:20:33,120 --> 02:20:35,580
handlers needs to be short

3391
02:20:35,580 --> 02:20:38,640
if any large-scale data transfer needs

3392
02:20:38,640 --> 02:20:40,260
to occur say we need to get a lot of

3393
02:20:40,260 --> 02:20:42,479
data from the device cell at once

3394
02:20:42,479 --> 02:20:45,120
this operation is handled by having the

3395
02:20:45,120 --> 02:20:47,520
fast interrupt Handler enqueue something

3396
02:20:47,520 --> 02:20:49,859
called a task into the operating systems

3397
02:20:49,859 --> 02:20:51,359
task queue

3398
02:20:51,359 --> 02:20:53,580
whenever all the fast interrupt handlers

3399
02:20:53,580 --> 02:20:54,720
for all the different interrupts are

3400
02:20:54,720 --> 02:20:57,660
done executing the CPU will go and check

3401
02:20:57,660 --> 02:21:00,780
the task queue and execute any tasks

3402
02:21:00,780 --> 02:21:02,640
that are present there

3403
02:21:02,640 --> 02:21:04,859
part of interrupt handling that goes

3404
02:21:04,859 --> 02:21:06,479
into the task queue is called slow

3405
02:21:06,479 --> 02:21:08,580
interrupt handling and it's called this

3406
02:21:08,580 --> 02:21:10,500
because it's not executed immediately

3407
02:21:10,500 --> 02:21:12,359
and it can be interrupted by other

3408
02:21:12,359 --> 02:21:14,340
devices

3409
02:21:14,340 --> 02:21:16,560
so what happens if an interrupt request

3410
02:21:16,560 --> 02:21:19,080
is received while we're still processing

3411
02:21:19,080 --> 02:21:20,760
an interrupt from a previous request

3412
02:21:20,760 --> 02:21:23,100
well there's no problem if we're in the

3413
02:21:23,100 --> 02:21:25,319
slow interrupt Handler because this

3414
02:21:25,319 --> 02:21:27,899
processing is done in such a way that we

3415
02:21:27,899 --> 02:21:29,880
can stop this processing and handle the

3416
02:21:29,880 --> 02:21:32,340
new interact if necessary what happens

3417
02:21:32,340 --> 02:21:34,979
if we are still running a fast interrupt

3418
02:21:34,979 --> 02:21:36,720
handle

3419
02:21:36,720 --> 02:21:39,600
well the new interrupt Handler could be

3420
02:21:39,600 --> 02:21:41,460
executed before the first interrupt

3421
02:21:41,460 --> 02:21:43,080
Handler is finished and this could cause

3422
02:21:43,080 --> 02:21:45,660
some major problems especially if we get

3423
02:21:45,660 --> 02:21:47,939
a new interrupt from a device that's

3424
02:21:47,939 --> 02:21:49,859
sharing the same interrupt line as the

3425
02:21:49,859 --> 02:21:51,840
one that we're handling

3426
02:21:51,840 --> 02:21:54,780
so what we do is we make fast interrupt

3427
02:21:54,780 --> 02:21:57,060
handling Atomic that is we make it

3428
02:21:57,060 --> 02:21:59,220
uninterruptable

3429
02:21:59,220 --> 02:22:01,620
on a single core system this is as

3430
02:22:01,620 --> 02:22:04,260
simple as disabling interrupts as long

3431
02:22:04,260 --> 02:22:05,700
as we're running a fast interrupt

3432
02:22:05,700 --> 02:22:08,040
Handler on multi-core systems their

3433
02:22:08,040 --> 02:22:10,439
actual special machine instructions to

3434
02:22:10,439 --> 02:22:13,380
facilitate Atomic operations that are

3435
02:22:13,380 --> 02:22:16,620
pegged to one CPU core

3436
02:22:16,620 --> 02:22:19,140
these Atomic interrupt handling

3437
02:22:19,140 --> 02:22:21,240
operations will run to completion

3438
02:22:21,240 --> 02:22:23,700
without interruption by any other

3439
02:22:23,700 --> 02:22:26,520
interrupt or any other request on the

3440
02:22:26,520 --> 02:22:27,560
system

3441
02:22:27,560 --> 02:22:30,120
thus the longer an interrupt Handler

3442
02:22:30,120 --> 02:22:32,880
takes to run the longer the system will

3443
02:22:32,880 --> 02:22:36,300
be unresponsive to any new interrupts

3444
02:22:36,300 --> 02:22:38,160
so what happens if a fast interrupt

3445
02:22:38,160 --> 02:22:39,960
Handler is coded in such a way that it

3446
02:22:39,960 --> 02:22:42,060
takes too long

3447
02:22:42,060 --> 02:22:44,280
other devices might be requesting

3448
02:22:44,280 --> 02:22:46,319
attention at the same time that this

3449
02:22:46,319 --> 02:22:48,240
long-running interrupt Handler is

3450
02:22:48,240 --> 02:22:50,100
executing

3451
02:22:50,100 --> 02:22:52,920
worse the same device that generated the

3452
02:22:52,920 --> 02:22:54,899
original interrupt might now have more

3453
02:22:54,899 --> 02:22:57,840
data to deliver to the OS before all the

3454
02:22:57,840 --> 02:22:59,700
previous data is completely received

3455
02:22:59,700 --> 02:23:01,979
this could cause Hardware failures

3456
02:23:01,979 --> 02:23:05,640
buffer overflows dropped data dropped

3457
02:23:05,640 --> 02:23:07,620
messages all kinds of issues at the

3458
02:23:07,620 --> 02:23:09,600
hardware level

3459
02:23:09,600 --> 02:23:12,540
however inside the operating system this

3460
02:23:12,540 --> 02:23:13,979
could lead to something called an

3461
02:23:13,979 --> 02:23:17,160
interrupt storm which is really bad

3462
02:23:17,160 --> 02:23:19,260
an interrupt storm occurs whenever

3463
02:23:19,260 --> 02:23:21,060
another interrupt is always waiting to

3464
02:23:21,060 --> 02:23:23,399
be processed whenever a fast interrupt

3465
02:23:23,399 --> 02:23:25,380
Handler finishes its execution

3466
02:23:25,380 --> 02:23:27,060
that could occur either because the fast

3467
02:23:27,060 --> 02:23:29,700
interrupt Handler is too long it needs

3468
02:23:29,700 --> 02:23:31,979
to be split into a fast and slow Handler

3469
02:23:31,979 --> 02:23:35,700
this can also occur if Hardware has

3470
02:23:35,700 --> 02:23:37,439
certain bugs that cause it to erase

3471
02:23:37,439 --> 02:23:40,020
spurious interrupts

3472
02:23:40,020 --> 02:23:42,420
if the operating system is perpetually

3473
02:23:42,420 --> 02:23:44,520
handling interrupts it never runs any

3474
02:23:44,520 --> 02:23:45,899
application code

3475
02:23:45,899 --> 02:23:49,319
thus it never appears to respond to any

3476
02:23:49,319 --> 02:23:51,000
user inputs

3477
02:23:51,000 --> 02:23:52,920
the result of the situation something

3478
02:23:52,920 --> 02:23:55,319
called a live lock the system is still

3479
02:23:55,319 --> 02:23:57,120
running it's still processing all these

3480
02:23:57,120 --> 02:23:59,580
interrupts however it's not doing any

3481
02:23:59,580 --> 02:24:02,160
useful work thus to the user the system

3482
02:24:02,160 --> 02:24:03,960
appears to be frozen

3483
02:24:03,960 --> 02:24:06,180
and when an interrupt storm occurs in

3484
02:24:06,180 --> 02:24:08,700
this live lock situation results the

3485
02:24:08,700 --> 02:24:11,760
typical way out of this problem involves

3486
02:24:11,760 --> 02:24:14,340
judicious use of the power button

3487
02:24:14,340 --> 02:24:17,460
so interrupt handling is an important

3488
02:24:17,460 --> 02:24:18,800
Concept in order to support

3489
02:24:18,800 --> 02:24:20,819
multi-programming systems

3490
02:24:20,819 --> 02:24:22,500
an interrupt handling when these

3491
02:24:22,500 --> 02:24:24,479
interrupt messages come through from

3492
02:24:24,479 --> 02:24:27,180
Hardware is divided into two types of

3493
02:24:27,180 --> 02:24:29,160
Handler so that we don't get the

3494
02:24:29,160 --> 02:24:30,660
interrupt storm

3495
02:24:30,660 --> 02:24:32,819
the fast interrupt Handler executes

3496
02:24:32,819 --> 02:24:35,160
atomically without being interrupted by

3497
02:24:35,160 --> 02:24:38,100
anything else but it must be fast must

3498
02:24:38,100 --> 02:24:40,740
enter that interrupt handler do some

3499
02:24:40,740 --> 02:24:42,600
very short operations and immediately

3500
02:24:42,600 --> 02:24:45,600
exit that handle if any long-running

3501
02:24:45,600 --> 02:24:47,819
operations need to occur as a result of

3502
02:24:47,819 --> 02:24:50,160
the device interrupt request we need to

3503
02:24:50,160 --> 02:24:52,260
handle those operations inside the slow

3504
02:24:52,260 --> 02:24:53,880
interrupt Handler

3505
02:24:53,880 --> 02:24:56,280
in this lecture I will discuss finite

3506
02:24:56,280 --> 02:25:01,100
State machines and uml state diagrams

3507
02:25:01,439 --> 02:25:03,600
uml State diagrams provide a way to

3508
02:25:03,600 --> 02:25:06,359
Model Behavior of a system by analyzing

3509
02:25:06,359 --> 02:25:08,340
how the state of the system changes in

3510
02:25:08,340 --> 02:25:10,620
response to input data

3511
02:25:10,620 --> 02:25:13,020
in this diagram we have a model of a

3512
02:25:13,020 --> 02:25:14,819
simple system that captures the user

3513
02:25:14,819 --> 02:25:16,859
entering a number consisting only of the

3514
02:25:16,859 --> 02:25:20,399
digits 0 through 9 and at most one

3515
02:25:20,399 --> 02:25:22,260
decimal point

3516
02:25:22,260 --> 02:25:24,540
the system finishes and presumably

3517
02:25:24,540 --> 02:25:26,880
Returns the inner number whenever the

3518
02:25:26,880 --> 02:25:28,680
user presses the enter key

3519
02:25:28,680 --> 02:25:32,040
invalid keystrokes are simply ignored

3520
02:25:32,040 --> 02:25:33,899
with the simple State machine such as

3521
02:25:33,899 --> 02:25:35,939
the one presented here we can verify

3522
02:25:35,939 --> 02:25:37,800
that the user has entered only numeric

3523
02:25:37,800 --> 02:25:40,500
data however understanding how the state

3524
02:25:40,500 --> 02:25:43,380
machine operates and how uml provides us

3525
02:25:43,380 --> 02:25:44,819
with the convenient way to draw the

3526
02:25:44,819 --> 02:25:49,040
state machine requires some explanation

3527
02:25:49,080 --> 02:25:52,140
First We Begin by observing that every

3528
02:25:52,140 --> 02:25:54,300
software system has something that we

3529
02:25:54,300 --> 02:25:55,920
call State

3530
02:25:55,920 --> 02:25:58,740
in simple terms Software State consists

3531
02:25:58,740 --> 02:26:00,240
of the current values of all the

3532
02:26:00,240 --> 02:26:02,700
variables in a program at any given

3533
02:26:02,700 --> 02:26:04,740
moment in time

3534
02:26:04,740 --> 02:26:07,200
in the case of object-oriented software

3535
02:26:07,200 --> 02:26:09,540
systems the state of the system is

3536
02:26:09,540 --> 02:26:11,399
stored within the objects in the system

3537
02:26:11,399 --> 02:26:14,399
and each object has its own state which

3538
02:26:14,399 --> 02:26:16,620
is stored in the object's variables or

3539
02:26:16,620 --> 02:26:18,000
fields

3540
02:26:18,000 --> 02:26:19,560
the essence of running a computer

3541
02:26:19,560 --> 02:26:22,140
program is changing the software from

3542
02:26:22,140 --> 02:26:23,939
one state to another

3543
02:26:23,939 --> 02:26:26,399
a computer at least as we know it today

3544
02:26:26,399 --> 02:26:29,160
is a machine capable of representing an

3545
02:26:29,160 --> 02:26:32,700
extremely large but finite number of

3546
02:26:32,700 --> 02:26:34,979
different states

3547
02:26:34,979 --> 02:26:37,140
computer programs simply move the

3548
02:26:37,140 --> 02:26:39,479
computer system from one state to

3549
02:26:39,479 --> 02:26:41,580
another state

3550
02:26:41,580 --> 02:26:43,740
a conceptual way to model a simple

3551
02:26:43,740 --> 02:26:46,140
computer or a single object in a

3552
02:26:46,140 --> 02:26:48,600
software system is to use a finite State

3553
02:26:48,600 --> 02:26:49,800
machine

3554
02:26:49,800 --> 02:26:51,720
finite State machines have a fixed

3555
02:26:51,720 --> 02:26:53,580
number of states and the system is

3556
02:26:53,580 --> 02:26:55,620
always in one of these states when it is

3557
02:26:55,620 --> 02:26:56,640
running

3558
02:26:56,640 --> 02:26:58,979
as computation progresses the finite

3559
02:26:58,979 --> 02:27:01,020
State machine transitions from one state

3560
02:27:01,020 --> 02:27:02,760
to the next

3561
02:27:02,760 --> 02:27:05,760
each state machine can receive input and

3562
02:27:05,760 --> 02:27:07,740
a state machine possibly produces output

3563
02:27:07,740 --> 02:27:10,380
during a state transition upon entering

3564
02:27:10,380 --> 02:27:13,080
a state upon leaving a state or even

3565
02:27:13,080 --> 02:27:14,640
within a state

3566
02:27:14,640 --> 02:27:17,220
for Simplicity the conceptual model used

3567
02:27:17,220 --> 02:27:20,280
for input and output data is a tape the

3568
02:27:20,280 --> 02:27:22,020
state machine can read characters from

3569
02:27:22,020 --> 02:27:24,840
or write characters to one of these

3570
02:27:24,840 --> 02:27:26,220
tapes

3571
02:27:26,220 --> 02:27:28,020
the set of characters that a machine

3572
02:27:28,020 --> 02:27:29,939
knows how to read or write is called an

3573
02:27:29,939 --> 02:27:31,260
alphabet

3574
02:27:31,260 --> 02:27:33,479
words are formed from this alphabet

3575
02:27:33,479 --> 02:27:35,460
creating a language that the state

3576
02:27:35,460 --> 02:27:37,620
machine recognizes

3577
02:27:37,620 --> 02:27:40,020
nearly all state machines have an input

3578
02:27:40,020 --> 02:27:41,100
tape

3579
02:27:41,100 --> 02:27:43,500
technically speaking a finite State

3580
02:27:43,500 --> 02:27:45,660
machine with only an input tape and no

3581
02:27:45,660 --> 02:27:47,819
output tape is called a finite State

3582
02:27:47,819 --> 02:27:49,319
automaton

3583
02:27:49,319 --> 02:27:51,840
this type of machine simply accepts or

3584
02:27:51,840 --> 02:27:54,359
rejects the input validating whether or

3585
02:27:54,359 --> 02:27:56,340
not it is a recognized word in the

3586
02:27:56,340 --> 02:27:57,540
language

3587
02:27:57,540 --> 02:28:00,600
a finite State transducer has two tapes

3588
02:28:00,600 --> 02:28:03,000
one for reading input and one for

3589
02:28:03,000 --> 02:28:05,720
writing output

3590
02:28:06,000 --> 02:28:07,920
State machines can be either

3591
02:28:07,920 --> 02:28:10,979
deterministic or non-deterministic

3592
02:28:10,979 --> 02:28:13,200
a deterministic finite State machine

3593
02:28:13,200 --> 02:28:15,300
transitions from its present state to

3594
02:28:15,300 --> 02:28:18,479
another state based solely upon present

3595
02:28:18,479 --> 02:28:20,280
State and the most recent input

3596
02:28:20,280 --> 02:28:22,800
character read from the input tape

3597
02:28:22,800 --> 02:28:25,680
in contrast a non-deterministic finite

3598
02:28:25,680 --> 02:28:27,960
State machine can transition from one

3599
02:28:27,960 --> 02:28:30,000
state to another on its own without

3600
02:28:30,000 --> 02:28:32,399
consuming any input data

3601
02:28:32,399 --> 02:28:34,260
these types of transitions are called

3602
02:28:34,260 --> 02:28:36,780
Lambda transitions or Epsilon

3603
02:28:36,780 --> 02:28:38,220
transitions in programming language

3604
02:28:38,220 --> 02:28:40,080
Theory

3605
02:28:40,080 --> 02:28:42,420
a state machine that produces output can

3606
02:28:42,420 --> 02:28:45,060
be limited to producing output only upon

3607
02:28:45,060 --> 02:28:46,979
entering a new state

3608
02:28:46,979 --> 02:28:49,200
this type of estate machine is known as

3609
02:28:49,200 --> 02:28:51,060
a war machine and is theoretically

3610
02:28:51,060 --> 02:28:52,920
easier to model

3611
02:28:52,920 --> 02:28:55,020
if a state machine can produce output at

3612
02:28:55,020 --> 02:28:56,880
any time within a state or during a

3613
02:28:56,880 --> 02:28:59,160
state transition it is called a melee

3614
02:28:59,160 --> 02:29:01,140
machine

3615
02:29:01,140 --> 02:29:03,240
by now you might be thinking that state

3616
02:29:03,240 --> 02:29:05,160
machines sound rather Limited in their

3617
02:29:05,160 --> 02:29:07,260
capabilities and this is a correct

3618
02:29:07,260 --> 02:29:09,359
observation for the simple finite State

3619
02:29:09,359 --> 02:29:10,439
machine

3620
02:29:10,439 --> 02:29:12,720
both deterministic and non-deterministic

3621
02:29:12,720 --> 02:29:14,220
finite State machines are equally

3622
02:29:14,220 --> 02:29:16,620
powerful but their power is limited to

3623
02:29:16,620 --> 02:29:18,300
recognizing inputs that could be

3624
02:29:18,300 --> 02:29:21,120
described using a regular expression

3625
02:29:21,120 --> 02:29:23,160
to obtain the power to process computer

3626
02:29:23,160 --> 02:29:25,200
programming languages which typically

3627
02:29:25,200 --> 02:29:27,120
utilize what are known as context-free

3628
02:29:27,120 --> 02:29:29,939
grammars we must add a stack to our

3629
02:29:29,939 --> 02:29:31,500
finite State machine to create a push

3630
02:29:31,500 --> 02:29:33,439
down automaton

3631
02:29:33,439 --> 02:29:35,939
alternatively if we modify a finite

3632
02:29:35,939 --> 02:29:37,560
State machine to be able to move back

3633
02:29:37,560 --> 02:29:39,840
and forth along a tape used for both

3634
02:29:39,840 --> 02:29:42,420
input and output we create a linearly

3635
02:29:42,420 --> 02:29:44,300
bounded automaton that can handle

3636
02:29:44,300 --> 02:29:47,220
context-sensitive languages as input

3637
02:29:47,220 --> 02:29:49,979
the linearly bounded automaton is the

3638
02:29:49,979 --> 02:29:51,840
closest theoretical State machine to the

3639
02:29:51,840 --> 02:29:54,300
present day computer the final type of

3640
02:29:54,300 --> 02:29:55,740
State machine is the turing machine

3641
02:29:55,740 --> 02:29:57,840
which further modifies the linearly

3642
02:29:57,840 --> 02:30:00,000
bounded automaton to make the tape

3643
02:30:00,000 --> 02:30:02,220
infinitely long giving it infinite

3644
02:30:02,220 --> 02:30:03,240
memory

3645
02:30:03,240 --> 02:30:05,819
such a machine if it existed could

3646
02:30:05,819 --> 02:30:09,359
handle recursively innumerable languages

3647
02:30:09,359 --> 02:30:11,700
the unified modeling language allows us

3648
02:30:11,700 --> 02:30:14,040
to diagram deterministic finite State

3649
02:30:14,040 --> 02:30:16,560
machines which allows us to model many

3650
02:30:16,560 --> 02:30:18,899
of the operations in individual objects

3651
02:30:18,899 --> 02:30:21,540
in a large-scale system perform

3652
02:30:21,540 --> 02:30:24,240
in the practice of writing software we

3653
02:30:24,240 --> 02:30:26,540
try to minimize non-determinism since

3654
02:30:26,540 --> 02:30:28,740
non-deterministic programs could produce

3655
02:30:28,740 --> 02:30:30,840
different results each time they are run

3656
02:30:30,840 --> 02:30:32,520
with the same inputs

3657
02:30:32,520 --> 02:30:34,380
therefore we would like our Enterprise

3658
02:30:34,380 --> 02:30:38,460
applications to be deterministic

3659
02:30:38,460 --> 02:30:40,920
uml State diagrams are used to model the

3660
02:30:40,920 --> 02:30:43,020
behavior of individual objects within

3661
02:30:43,020 --> 02:30:45,000
the system under discussion

3662
02:30:45,000 --> 02:30:47,340
one diagram is generally used for each

3663
02:30:47,340 --> 02:30:49,920
object being modeled so a normal set of

3664
02:30:49,920 --> 02:30:52,020
design documents would contain multiple

3665
02:30:52,020 --> 02:30:54,479
State diagrams

3666
02:30:54,479 --> 02:30:57,060
State machines expressed by uml either

3667
02:30:57,060 --> 02:30:59,700
can produce output at any time or the

3668
02:30:59,700 --> 02:31:01,500
designers can restrict the output to the

3669
02:31:01,500 --> 02:31:03,479
entry condition for each state

3670
02:31:03,479 --> 02:31:05,760
thus these State machines can use either

3671
02:31:05,760 --> 02:31:08,880
the melee or more model

3672
02:31:08,880 --> 02:31:10,500
I'm now going to illustrate the

3673
02:31:10,500 --> 02:31:13,859
components of the uml state diagram

3674
02:31:13,859 --> 02:31:16,319
first we have the initial state in the

3675
02:31:16,319 --> 02:31:17,880
final state of the system

3676
02:31:17,880 --> 02:31:19,800
these states represent the entry and

3677
02:31:19,800 --> 02:31:23,399
exit points for the diagram respectively

3678
02:31:23,399 --> 02:31:26,340
the initial state or diagram entry point

3679
02:31:26,340 --> 02:31:29,700
is represented by a filled Circle

3680
02:31:29,700 --> 02:31:33,120
the final state or diagram exit point is

3681
02:31:33,120 --> 02:31:35,040
represented by a filled Circle within

3682
02:31:35,040 --> 02:31:37,580
another Circle

3683
02:31:37,859 --> 02:31:40,200
internal States within the uml state

3684
02:31:40,200 --> 02:31:42,660
diagram are given by a rounded rectangle

3685
02:31:42,660 --> 02:31:44,880
divided into two sections

3686
02:31:44,880 --> 02:31:47,220
in the top section a human readable name

3687
02:31:47,220 --> 02:31:49,620
for the state is generally provided

3688
02:31:49,620 --> 02:31:51,720
this name should reflect the purpose of

3689
02:31:51,720 --> 02:31:53,280
the state

3690
02:31:53,280 --> 02:31:55,560
below the name the bottom section of the

3691
02:31:55,560 --> 02:31:57,300
state rectangle contains the set of

3692
02:31:57,300 --> 02:31:59,100
activities that the system performs

3693
02:31:59,100 --> 02:32:02,340
while in the listed state

3694
02:32:02,340 --> 02:32:04,380
these activities are specified by

3695
02:32:04,380 --> 02:32:06,240
providing a condition under which the

3696
02:32:06,240 --> 02:32:08,640
activity is performed followed by a

3697
02:32:08,640 --> 02:32:11,160
slash followed by the name of the action

3698
02:32:11,160 --> 02:32:13,319
that is to be executed

3699
02:32:13,319 --> 02:32:15,600
Three Special condition names are

3700
02:32:15,600 --> 02:32:18,120
reserved by the uml specification to

3701
02:32:18,120 --> 02:32:20,100
handle specific activities

3702
02:32:20,100 --> 02:32:23,580
these are entry which specifies an

3703
02:32:23,580 --> 02:32:26,280
action to take upon entering the state

3704
02:32:26,280 --> 02:32:28,859
exit which specifies an action to take

3705
02:32:28,859 --> 02:32:31,140
upon exiting the state

3706
02:32:31,140 --> 02:32:34,740
and do which specifies an action to take

3707
02:32:34,740 --> 02:32:36,600
while in the state

3708
02:32:36,600 --> 02:32:39,060
note that a do action may be a

3709
02:32:39,060 --> 02:32:41,460
continuous ongoing action that occurs

3710
02:32:41,460 --> 02:32:44,700
until the system leaves the state

3711
02:32:44,700 --> 02:32:47,340
transitions between states are drawn as

3712
02:32:47,340 --> 02:32:49,620
arrows originating from one state and

3713
02:32:49,620 --> 02:32:52,020
pointing to the next state

3714
02:32:52,020 --> 02:32:54,359
the system follows the arrows from state

3715
02:32:54,359 --> 02:32:55,979
to state until it reaches the final

3716
02:32:55,979 --> 02:32:57,240
state

3717
02:32:57,240 --> 02:32:59,880
a transition is taken only if the input

3718
02:32:59,880 --> 02:33:01,620
to the machine matches a trigger

3719
02:33:01,620 --> 02:33:03,660
condition specified next to the

3720
02:33:03,660 --> 02:33:05,340
transition error

3721
02:33:05,340 --> 02:33:06,960
this trigger condition can be

3722
02:33:06,960 --> 02:33:08,520
accompanied by an optional guard

3723
02:33:08,520 --> 02:33:11,100
expression enclosed in square brackets

3724
02:33:11,100 --> 02:33:13,319
in which case the transition will be

3725
02:33:13,319 --> 02:33:15,420
taken only if both the trigger matches

3726
02:33:15,420 --> 02:33:18,180
and the guard expression is true

3727
02:33:18,180 --> 02:33:20,340
after the trigger an optional guard

3728
02:33:20,340 --> 02:33:23,700
expression is placed a slash followed by

3729
02:33:23,700 --> 02:33:26,580
any action to take during the transition

3730
02:33:26,580 --> 02:33:29,340
the slash is always present in the uml

3731
02:33:29,340 --> 02:33:32,100
state diagram even if there is no action

3732
02:33:32,100 --> 02:33:34,580
given

3733
02:33:35,220 --> 02:33:37,560
uml does allow a state with any uml

3734
02:33:37,560 --> 02:33:39,660
state diagram to contain another state

3735
02:33:39,660 --> 02:33:43,020
diagram instead of a list of activities

3736
02:33:43,020 --> 02:33:45,540
these so-called nested State diagrams

3737
02:33:45,540 --> 02:33:47,700
are permitted but they will quickly make

3738
02:33:47,700 --> 02:33:49,920
a uml state diagram difficult to draw

3739
02:33:49,920 --> 02:33:51,359
and read

3740
02:33:51,359 --> 02:33:53,880
instead of nesting State diagrams I

3741
02:33:53,880 --> 02:33:55,500
suggest using a special symbol

3742
02:33:55,500 --> 02:33:57,780
consisting of two empty states joined

3743
02:33:57,780 --> 02:34:00,060
together as a way of indicating that a

3744
02:34:00,060 --> 02:34:02,399
state within the state diagram is itself

3745
02:34:02,399 --> 02:34:05,340
modeled by another state diagram

3746
02:34:05,340 --> 02:34:07,560
then you can draw a second state diagram

3747
02:34:07,560 --> 02:34:10,740
for the complex state

3748
02:34:10,740 --> 02:34:12,479
I will now summarize what we have

3749
02:34:12,479 --> 02:34:14,160
learned by discussing the meaning of

3750
02:34:14,160 --> 02:34:16,979
this simple uml State diagram

3751
02:34:16,979 --> 02:34:19,380
first the state machine starts in the

3752
02:34:19,380 --> 02:34:20,939
initial state

3753
02:34:20,939 --> 02:34:23,280
it transitions to the no decimal state

3754
02:34:23,280 --> 02:34:25,859
only upon receiving a digit in the range

3755
02:34:25,859 --> 02:34:29,100
0 through 9 as input

3756
02:34:29,100 --> 02:34:31,140
upon arriving in the no decimal State

3757
02:34:31,140 --> 02:34:34,439
the machine depends the received input

3758
02:34:34,439 --> 02:34:36,540
digit to the output

3759
02:34:36,540 --> 02:34:38,819
the machine stays in this state until

3760
02:34:38,819 --> 02:34:41,100
one of three types of input is observed

3761
02:34:41,100 --> 02:34:44,340
another digit a period for a decimal

3762
02:34:44,340 --> 02:34:46,859
point or the enter key press

3763
02:34:46,859 --> 02:34:49,319
if another digit is received the machine

3764
02:34:49,319 --> 02:34:52,020
exits then re-enters the no decimal

3765
02:34:52,020 --> 02:34:55,080
state upon re-entry the new digit is

3766
02:34:55,080 --> 02:34:57,240
appended to the output

3767
02:34:57,240 --> 02:34:59,580
if the period key is pressed the machine

3768
02:34:59,580 --> 02:35:01,740
exits the no decimal State and enters

3769
02:35:01,740 --> 02:35:04,020
the have decimal State appending the

3770
02:35:04,020 --> 02:35:05,880
decimal point to the output during the

3771
02:35:05,880 --> 02:35:07,800
transition

3772
02:35:07,800 --> 02:35:09,840
from the half decimal State the system

3773
02:35:09,840 --> 02:35:12,180
will exit and re-enter the have decimal

3774
02:35:12,180 --> 02:35:14,819
State whenever the digits 0 through 9

3775
02:35:14,819 --> 02:35:17,340
are received appending the received

3776
02:35:17,340 --> 02:35:21,780
digit to the output upon the transition

3777
02:35:21,780 --> 02:35:24,120
from either State pressing the enter key

3778
02:35:24,120 --> 02:35:26,220
ends the Machine by moving to the final

3779
02:35:26,220 --> 02:35:27,300
state

3780
02:35:27,300 --> 02:35:30,359
also any invalid data to the machine is

3781
02:35:30,359 --> 02:35:32,819
ignored at all States since no trigger

3782
02:35:32,819 --> 02:35:34,560
is matched

3783
02:35:34,560 --> 02:35:36,540
in short this finite State machine

3784
02:35:36,540 --> 02:35:38,760
implements logic that reads in and

3785
02:35:38,760 --> 02:35:41,220
stores either an integer or a simple

3786
02:35:41,220 --> 02:35:43,859
floating Point number in this lecture I

3787
02:35:43,859 --> 02:35:45,660
will introduce dynamic memory allocation

3788
02:35:45,660 --> 02:35:47,280
at the system level

3789
02:35:47,280 --> 02:35:49,020
this method of memory allocation

3790
02:35:49,020 --> 02:35:51,000
improves the degree of multi-programming

3791
02:35:51,000 --> 02:35:53,280
that A system can provide by allocating

3792
02:35:53,280 --> 02:35:55,740
memory to processes as needed instead of

3793
02:35:55,740 --> 02:35:59,220
ahead of time in fixed size chunks

3794
02:35:59,220 --> 02:36:00,120
yeah

3795
02:36:00,120 --> 02:36:02,640
fixed memory partitioning is fast and

3796
02:36:02,640 --> 02:36:04,859
efficient in terms of overhead but it

3797
02:36:04,859 --> 02:36:06,540
wastes space and limits the number of

3798
02:36:06,540 --> 02:36:08,280
concurrent processes to the number of

3799
02:36:08,280 --> 02:36:10,500
partitions that will fit into RAM

3800
02:36:10,500 --> 02:36:12,780
dynamic memory allocation resolves this

3801
02:36:12,780 --> 02:36:14,819
issue by allocating memory to processes

3802
02:36:14,819 --> 02:36:16,500
as it is needed

3803
02:36:16,500 --> 02:36:18,600
this mechanism increases the degree of

3804
02:36:18,600 --> 02:36:19,859
multi-programming with the current

3805
02:36:19,859 --> 02:36:21,780
office support but this Improvement

3806
02:36:21,780 --> 02:36:24,359
comes at a cost of Greater complexity

3807
02:36:24,359 --> 02:36:26,460
in addition there are trade-offs present

3808
02:36:26,460 --> 02:36:28,200
in dynamic memory allocation that

3809
02:36:28,200 --> 02:36:29,880
directly affect performance of the

3810
02:36:29,880 --> 02:36:30,720
system

3811
02:36:30,720 --> 02:36:33,540
these issues include efficiency methods

3812
02:36:33,540 --> 02:36:36,060
for tracking free space algorithms for

3813
02:36:36,060 --> 02:36:37,319
determining where to make the next

3814
02:36:37,319 --> 02:36:41,479
allocation and memory fragmentation

3815
02:36:42,060 --> 02:36:44,100
the primary issue with dynamic memory

3816
02:36:44,100 --> 02:36:46,200
allocation is fragmentation

3817
02:36:46,200 --> 02:36:48,780
during execution processes allocate in

3818
02:36:48,780 --> 02:36:51,960
free memory in chunks of varying sizes

3819
02:36:51,960 --> 02:36:54,660
over Time regions of free space within

3820
02:36:54,660 --> 02:36:56,880
memory become non-contiguous with

3821
02:36:56,880 --> 02:36:58,620
sections of allocated memory in between

3822
02:36:58,620 --> 02:37:01,020
sections of available memory

3823
02:37:01,020 --> 02:37:03,300
this fragmentation could lead to Serious

3824
02:37:03,300 --> 02:37:05,220
performance issues since program

3825
02:37:05,220 --> 02:37:07,260
execution speed will drop dramatically

3826
02:37:07,260 --> 02:37:09,420
if every data structure must be

3827
02:37:09,420 --> 02:37:11,040
implemented as a linked list of small

3828
02:37:11,040 --> 02:37:12,420
pieces

3829
02:37:12,420 --> 02:37:14,520
furthermore algorithms that try to

3830
02:37:14,520 --> 02:37:15,780
perform on-the-fly memory

3831
02:37:15,780 --> 02:37:17,880
defragmentation are extremely complex to

3832
02:37:17,880 --> 02:37:20,640
implement and would also severely impact

3833
02:37:20,640 --> 02:37:23,720
system performance

3834
02:37:24,180 --> 02:37:26,460
since it is Impractical to avoid or fix

3835
02:37:26,460 --> 02:37:28,740
fragmentation memory fragments are

3836
02:37:28,740 --> 02:37:30,479
significant concern when space is

3837
02:37:30,479 --> 02:37:32,160
dynamically allocated

3838
02:37:32,160 --> 02:37:34,439
small fragments of memory are useless to

3839
02:37:34,439 --> 02:37:36,420
programs particularly CNC plus plus

3840
02:37:36,420 --> 02:37:38,939
programs which require structures and

3841
02:37:38,939 --> 02:37:40,680
objects to be allocated in contiguous

3842
02:37:40,680 --> 02:37:42,540
memory regions

3843
02:37:42,540 --> 02:37:44,460
these structures are likely to be in

3844
02:37:44,460 --> 02:37:46,500
various sizes that are not efficient to

3845
02:37:46,500 --> 02:37:48,420
utilize for memory management purposes

3846
02:37:48,420 --> 02:37:50,939
so the systems will allocate a few more

3847
02:37:50,939 --> 02:37:52,319
bytes than the structures actually

3848
02:37:52,319 --> 02:37:54,540
require in order to improve efficiency

3849
02:37:54,540 --> 02:37:56,880
of the memory tracking systems

3850
02:37:56,880 --> 02:37:58,859
furthermore structures and objects will

3851
02:37:58,859 --> 02:38:00,660
be allocated in freed numerous times

3852
02:38:00,660 --> 02:38:03,000
during program execution further

3853
02:38:03,000 --> 02:38:04,979
fragmenting the ram

3854
02:38:04,979 --> 02:38:07,500
over time fragmentation can waste large

3855
02:38:07,500 --> 02:38:10,020
portions of system memory limiting the

3856
02:38:10,020 --> 02:38:12,000
degree of multi-programming by making it

3857
02:38:12,000 --> 02:38:15,979
impossible for new processes to start

3858
02:38:16,620 --> 02:38:18,479
there are two types of fragmentation

3859
02:38:18,479 --> 02:38:20,819
external and internal

3860
02:38:20,819 --> 02:38:23,220
external fragmentation occurs when free

3861
02:38:23,220 --> 02:38:25,080
space and memory is broken into small

3862
02:38:25,080 --> 02:38:26,280
pieces

3863
02:38:26,280 --> 02:38:28,500
over time as blocks of memory are

3864
02:38:28,500 --> 02:38:30,840
allocated and deallocated this type of

3865
02:38:30,840 --> 02:38:33,479
fragmentation tends to become worse

3866
02:38:33,479 --> 02:38:35,939
external fragmentation is so bad with

3867
02:38:35,939 --> 02:38:38,340
some allocation algorithms that for

3868
02:38:38,340 --> 02:38:40,560
every n blocks of memory that are

3869
02:38:40,560 --> 02:38:43,500
allocated to a process the system wastes

3870
02:38:43,500 --> 02:38:46,200
another half in blocks and fragments

3871
02:38:46,200 --> 02:38:48,479
with these algorithms up to a third of

3872
02:38:48,479 --> 02:38:52,160
system memory becomes unusable

3873
02:38:52,800 --> 02:38:54,600
the other type of fragmentation is

3874
02:38:54,600 --> 02:38:56,819
called internal fragmentation

3875
02:38:56,819 --> 02:38:59,040
internal fragmentation occurs because

3876
02:38:59,040 --> 02:39:00,720
memory is normally allocated to

3877
02:39:00,720 --> 02:39:03,479
processes in some fixed block size

3878
02:39:03,479 --> 02:39:05,640
the block size is normally a power of

3879
02:39:05,640 --> 02:39:07,319
two in order to make the kernel memory

3880
02:39:07,319 --> 02:39:09,960
tracking structures more efficient

3881
02:39:09,960 --> 02:39:12,359
processes tend to request pieces of

3882
02:39:12,359 --> 02:39:14,580
memory and sizes that do not fit neatly

3883
02:39:14,580 --> 02:39:16,260
into these blocks

3884
02:39:16,260 --> 02:39:18,600
thus it is often the case that parts of

3885
02:39:18,600 --> 02:39:21,120
a block are wasted as a result

3886
02:39:21,120 --> 02:39:23,819
for small memory requests large portions

3887
02:39:23,819 --> 02:39:27,380
of the block may be wasted

3888
02:39:27,840 --> 02:39:30,540
when a process requests cheap memory the

3889
02:39:30,540 --> 02:39:32,460
kernel must find a chunk of free space

3890
02:39:32,460 --> 02:39:35,160
large enough to accommodate the request

3891
02:39:35,160 --> 02:39:37,200
this chunk cannot be smaller than the

3892
02:39:37,200 --> 02:39:39,840
requested size since the process expects

3893
02:39:39,840 --> 02:39:42,899
to use all the space it is requesting

3894
02:39:42,899 --> 02:39:45,120
since the memory is divided into blocks

3895
02:39:45,120 --> 02:39:47,220
for efficiency the chunk of memory

3896
02:39:47,220 --> 02:39:49,080
returned to the process is normally

3897
02:39:49,080 --> 02:39:51,420
larger than the amount requested unless

3898
02:39:51,420 --> 02:39:53,280
the process happens to request a whole

3899
02:39:53,280 --> 02:39:55,979
number multiple block size

3900
02:39:55,979 --> 02:39:57,660
I'm now going to introduce four

3901
02:39:57,660 --> 02:39:59,880
classical algorithms for dynamic memory

3902
02:39:59,880 --> 02:40:03,540
allocation best fit worst fit first fit

3903
02:40:03,540 --> 02:40:06,500
and next fit

3904
02:40:06,960 --> 02:40:09,120
the first classic algorithm for dynamic

3905
02:40:09,120 --> 02:40:10,740
memory allocation is the best fed

3906
02:40:10,740 --> 02:40:11,880
algorithm

3907
02:40:11,880 --> 02:40:14,040
in this algorithm the kernel searches

3908
02:40:14,040 --> 02:40:15,600
for the smallest chunk of free space

3909
02:40:15,600 --> 02:40:17,280
that is big enough to accommodate the

3910
02:40:17,280 --> 02:40:18,780
memory requests

3911
02:40:18,780 --> 02:40:21,120
although best fit minimizes internal

3912
02:40:21,120 --> 02:40:23,899
fragmentation by avoiding overallocation

3913
02:40:23,899 --> 02:40:26,160
external fragmentation is a major

3914
02:40:26,160 --> 02:40:27,660
problem

3915
02:40:27,660 --> 02:40:29,700
an attempt to reduce the external

3916
02:40:29,700 --> 02:40:31,680
fragmentation in the best fit algorithm

3917
02:40:31,680 --> 02:40:33,120
is observed in the somewhat

3918
02:40:33,120 --> 02:40:36,240
counterintuitive worst fit algorithm

3919
02:40:36,240 --> 02:40:38,640
using the worst fit algorithm the kernel

3920
02:40:38,640 --> 02:40:40,260
finds and allocates the largest

3921
02:40:40,260 --> 02:40:43,020
available chunk of free space provided

3922
02:40:43,020 --> 02:40:44,760
it is large enough to accommodate the

3923
02:40:44,760 --> 02:40:45,960
request

3924
02:40:45,960 --> 02:40:48,300
in theory this allocation strategy

3925
02:40:48,300 --> 02:40:50,640
leaves larger and thus potentially more

3926
02:40:50,640 --> 02:40:53,580
usable chunks of free space available

3927
02:40:53,580 --> 02:40:56,040
in practice however this algorithm still

3928
02:40:56,040 --> 02:40:58,560
fragments badly both internally and

3929
02:40:58,560 --> 02:41:00,000
externally

3930
02:41:00,000 --> 02:41:02,460
aside from the fragmentation both of

3931
02:41:02,460 --> 02:41:04,380
these algorithms are impractical in

3932
02:41:04,380 --> 02:41:06,540
actual kernel implementations because

3933
02:41:06,540 --> 02:41:08,460
they must perform a search of the entire

3934
02:41:08,460 --> 02:41:10,800
free list to find the smallest or

3935
02:41:10,800 --> 02:41:14,000
largest chunk of memory

3936
02:41:14,160 --> 02:41:16,020
the need to search the free list is

3937
02:41:16,020 --> 02:41:18,000
eliminated using the first fit or next

3938
02:41:18,000 --> 02:41:19,439
fit algorithm

3939
02:41:19,439 --> 02:41:21,479
in the first fit algorithm the kernel

3940
02:41:21,479 --> 02:41:23,280
simply finds and allocates the first

3941
02:41:23,280 --> 02:41:25,140
chunk of memory that is large enough to

3942
02:41:25,140 --> 02:41:27,000
satisfy the requests

3943
02:41:27,000 --> 02:41:30,060
this approach does result in internal

3944
02:41:30,060 --> 02:41:31,319
fragmentation

3945
02:41:31,319 --> 02:41:33,420
and it also tends to create small

3946
02:41:33,420 --> 02:41:35,880
fragments free space that accumulate at

3947
02:41:35,880 --> 02:41:37,979
the start of the free list reducing

3948
02:41:37,979 --> 02:41:40,500
performance over time

3949
02:41:40,500 --> 02:41:42,600
the next fit algorithm avoids the

3950
02:41:42,600 --> 02:41:45,000
external fragment accumulation by

3951
02:41:45,000 --> 02:41:46,620
starting the search for the next chunk

3952
02:41:46,620 --> 02:41:48,060
of memory from the most recent

3953
02:41:48,060 --> 02:41:49,620
allocation

3954
02:41:49,620 --> 02:41:52,140
in practice only the first fit algorithm

3955
02:41:52,140 --> 02:41:54,300
is used in the Linux kernel and then

3956
02:41:54,300 --> 02:41:56,399
only for embedded devices

3957
02:41:56,399 --> 02:41:58,439
this algorithm is called the slob

3958
02:41:58,439 --> 02:42:00,359
allocator which stands for simple list

3959
02:42:00,359 --> 02:42:01,859
of blocks

3960
02:42:01,859 --> 02:42:03,840
for non-embedded systems that have the

3961
02:42:03,840 --> 02:42:05,760
computational power for a more complex

3962
02:42:05,760 --> 02:42:08,460
algorithm slab allocation is used

3963
02:42:08,460 --> 02:42:09,720
instead of any of these simple

3964
02:42:09,720 --> 02:42:12,420
algorithms in this lecture I continued

3965
02:42:12,420 --> 02:42:13,979
the discussion of dynamic memory

3966
02:42:13,979 --> 02:42:15,600
allocation

3967
02:42:15,600 --> 02:42:17,580
I will introduce the power of two

3968
02:42:17,580 --> 02:42:19,140
methods with the buddy system and

3969
02:42:19,140 --> 02:42:21,359
coalescence for allocating memory to

3970
02:42:21,359 --> 02:42:22,680
processes

3971
02:42:22,680 --> 02:42:24,960
then I will introduce slab allocation

3972
02:42:24,960 --> 02:42:26,760
which is used within the kernel to

3973
02:42:26,760 --> 02:42:28,140
allocate kernel data structures

3974
02:42:28,140 --> 02:42:30,420
efficiently

3975
02:42:30,420 --> 02:42:32,580
in the previous lecture I introduced the

3976
02:42:32,580 --> 02:42:34,500
classic algorithms for memory allocation

3977
02:42:34,500 --> 02:42:37,560
best fit worst fit first fit and next

3978
02:42:37,560 --> 02:42:38,700
fit

3979
02:42:38,700 --> 02:42:40,680
now I want to introduce algorithms that

3980
02:42:40,680 --> 02:42:42,840
are actually used within OS kernels to

3981
02:42:42,840 --> 02:42:45,300
perform memory allocations efficiently

3982
02:42:45,300 --> 02:42:47,340
these algorithms are called power of two

3983
02:42:47,340 --> 02:42:49,439
methods and they work by maintaining

3984
02:42:49,439 --> 02:42:51,180
information about allocated and free

3985
02:42:51,180 --> 02:42:53,460
blocks in a binary tree instead of a

3986
02:42:53,460 --> 02:42:54,720
list

3987
02:42:54,720 --> 02:42:57,180
at the top level memory is divided into

3988
02:42:57,180 --> 02:42:59,520
large blocks called super blocks

3989
02:42:59,520 --> 02:43:01,920
as processes request memory these super

3990
02:43:01,920 --> 02:43:03,899
blocks are divided into smaller sub

3991
02:43:03,899 --> 02:43:05,819
blocks from which the memory is

3992
02:43:05,819 --> 02:43:06,899
allocated

3993
02:43:06,899 --> 02:43:08,880
sub blocks can be further divided

3994
02:43:08,880 --> 02:43:12,560
creating a hierarchy of block sizes

3995
02:43:12,560 --> 02:43:14,760
algorithms based on this method are

3996
02:43:14,760 --> 02:43:16,740
relatively fast and scaled to multiple

3997
02:43:16,740 --> 02:43:20,100
parallel CPU cores these algorithms also

3998
02:43:20,100 --> 02:43:22,740
reduce external fragmentation by

3999
02:43:22,740 --> 02:43:24,840
coalescing free blocks as I will discuss

4000
02:43:24,840 --> 02:43:26,460
in a few moments

4001
02:43:26,460 --> 02:43:28,680
some internal fragmentation does still

4002
02:43:28,680 --> 02:43:31,040
occur

4003
02:43:31,200 --> 02:43:33,420
in this diagram we can see three super

4004
02:43:33,420 --> 02:43:36,359
blocks two of which are partially in use

4005
02:43:36,359 --> 02:43:38,700
each of the first two super blocks has

4006
02:43:38,700 --> 02:43:41,399
been divided into three sub blocks and

4007
02:43:41,399 --> 02:43:43,140
the third sub-block of the first Super

4008
02:43:43,140 --> 02:43:46,080
block has been further divided

4009
02:43:46,080 --> 02:43:48,240
when a process requests memory the

4010
02:43:48,240 --> 02:43:50,040
kernel must perform a search of the tree

4011
02:43:50,040 --> 02:43:52,740
to find an appropriately sized block to

4012
02:43:52,740 --> 02:43:55,500
handle the request in performing the

4013
02:43:55,500 --> 02:43:57,479
search the kernel might subdivide an

4014
02:43:57,479 --> 02:43:59,819
existing block into a smaller block to

4015
02:43:59,819 --> 02:44:00,960
reduce the amount of internal

4016
02:44:00,960 --> 02:44:02,460
fragmentation

4017
02:44:02,460 --> 02:44:04,740
since this is a search process a

4018
02:44:04,740 --> 02:44:06,960
reasonably powerful CPU is required to

4019
02:44:06,960 --> 02:44:10,220
make this operation efficient

4020
02:44:11,040 --> 02:44:12,840
another Improvement to memory management

4021
02:44:12,840 --> 02:44:14,939
is to utilize a buddy system in the

4022
02:44:14,939 --> 02:44:16,680
power of two strategy

4023
02:44:16,680 --> 02:44:18,960
in this allocation system two limits are

4024
02:44:18,960 --> 02:44:21,479
chosen to be powers of two the upper

4025
02:44:21,479 --> 02:44:24,420
limit U and the lower limit l

4026
02:44:24,420 --> 02:44:26,640
the super blocks are the blocks of size

4027
02:44:26,640 --> 02:44:29,160
U and these blocks can be subdivided

4028
02:44:29,160 --> 02:44:32,640
into blocks as small as L bytes

4029
02:44:32,640 --> 02:44:34,979
there are trade-offs in picking the size

4030
02:44:34,979 --> 02:44:36,840
to use for l

4031
02:44:36,840 --> 02:44:39,540
a smaller size produces less internal

4032
02:44:39,540 --> 02:44:42,240
fragmentation since the block size more

4033
02:44:42,240 --> 02:44:44,160
closely matches the smallest request

4034
02:44:44,160 --> 02:44:46,319
sizes from the processes

4035
02:44:46,319 --> 02:44:49,080
however a smaller size for l means that

4036
02:44:49,080 --> 02:44:50,520
there are more total blocks to be

4037
02:44:50,520 --> 02:44:52,979
tracked which increases the size of the

4038
02:44:52,979 --> 02:44:55,800
binary tree using more RAM to store the

4039
02:44:55,800 --> 02:44:59,340
tree and increasing the search time

4040
02:44:59,340 --> 02:45:01,859
on the other hand a larger size for L

4041
02:45:01,859 --> 02:45:04,140
reduces the search time and makes the

4042
02:45:04,140 --> 02:45:06,420
tree smaller but the amount of internal

4043
02:45:06,420 --> 02:45:09,180
fragmentation increases

4044
02:45:09,180 --> 02:45:11,520
in addition to the block size limits the

4045
02:45:11,520 --> 02:45:13,439
buddy system also uses a technique

4046
02:45:13,439 --> 02:45:15,180
called coalescence

4047
02:45:15,180 --> 02:45:17,460
whenever a process frees a block the

4048
02:45:17,460 --> 02:45:18,840
kernel checks to see if either

4049
02:45:18,840 --> 02:45:21,300
neighboring blocks is free also

4050
02:45:21,300 --> 02:45:24,120
if one or more neighbors or buddy blocks

4051
02:45:24,120 --> 02:45:26,939
are free the block is coalesced into a

4052
02:45:26,939 --> 02:45:28,859
larger block reducing external

4053
02:45:28,859 --> 02:45:31,200
fragmentation the coalescence algorithm

4054
02:45:31,200 --> 02:45:33,359
is efficient since the maximum number of

4055
02:45:33,359 --> 02:45:35,220
coalescence operations that must be

4056
02:45:35,220 --> 02:45:37,560
performed is equal to the base 2

4057
02:45:37,560 --> 02:45:40,560
logarithm of U divided by L

4058
02:45:40,560 --> 02:45:42,960
by properties of logarithms this value

4059
02:45:42,960 --> 02:45:45,240
is equivalent to the base 2 log of U

4060
02:45:45,240 --> 02:45:48,780
minus the base J log of L

4061
02:45:48,780 --> 02:45:52,319
thus for example a system with a maximum

4062
02:45:52,319 --> 02:45:55,859
block size U of 4096 bytes or 2 to the

4063
02:45:55,859 --> 02:45:59,100
12. and a minimum block size of 512

4064
02:45:59,100 --> 02:46:02,280
bytes or 2 to the 9 will require at most

4065
02:46:02,280 --> 02:46:05,280
three coalescence operations to recreate

4066
02:46:05,280 --> 02:46:07,140
the super block

4067
02:46:07,140 --> 02:46:10,140
returning a single 512 byte block whose

4068
02:46:10,140 --> 02:46:13,200
neighboring 512 byte buddy is free will

4069
02:46:13,200 --> 02:46:15,180
cause the two blocks to be coalesced

4070
02:46:15,180 --> 02:46:18,479
into a single 1024 byte block

4071
02:46:18,479 --> 02:46:21,300
if the neighboring 1024 byte block is

4072
02:46:21,300 --> 02:46:24,359
free the 2024 byte blocks will be

4073
02:46:24,359 --> 02:46:28,080
coalesced into a 2048 byte block

4074
02:46:28,080 --> 02:46:31,859
then if a buddy 2048 byte block is free

4075
02:46:31,859 --> 02:46:34,460
the third coalescence will produce to

4076
02:46:34,460 --> 02:46:36,960
4096 byte super block

4077
02:46:36,960 --> 02:46:39,240
the power of two methods are useful for

4078
02:46:39,240 --> 02:46:41,220
allocating memory to processes where

4079
02:46:41,220 --> 02:46:42,840
some internal fragmentation is

4080
02:46:42,840 --> 02:46:44,100
acceptable

4081
02:46:44,100 --> 02:46:46,140
however within the kernel it is

4082
02:46:46,140 --> 02:46:48,060
preferable to minimize both internal and

4083
02:46:48,060 --> 02:46:50,760
external fragmentation to avoid wasting

4084
02:46:50,760 --> 02:46:51,899
space

4085
02:46:51,899 --> 02:46:53,880
this conservative approach is needed

4086
02:46:53,880 --> 02:46:55,680
since the kernel is always mapped into

4087
02:46:55,680 --> 02:46:58,260
main memory an efficient solution for

4088
02:46:58,260 --> 02:47:00,120
allocating kernel memory is to use a

4089
02:47:00,120 --> 02:47:02,520
slab allocation algorithm in which

4090
02:47:02,520 --> 02:47:04,920
kernel memory is arranged into fixed

4091
02:47:04,920 --> 02:47:06,720
size slabs

4092
02:47:06,720 --> 02:47:09,359
each slab is divided into region size

4093
02:47:09,359 --> 02:47:11,460
for specific types of Kernel objects

4094
02:47:11,460 --> 02:47:14,280
including file descriptors semaphores

4095
02:47:14,280 --> 02:47:16,740
process control structures and other

4096
02:47:16,740 --> 02:47:18,660
internal data structures

4097
02:47:18,660 --> 02:47:20,700
initial layout of these slabs is

4098
02:47:20,700 --> 02:47:23,580
performed at compile time

4099
02:47:23,580 --> 02:47:26,100
at runtime several of each of the

4100
02:47:26,100 --> 02:47:28,260
different slab layouts are pre-allocated

4101
02:47:28,260 --> 02:47:29,819
into caches

4102
02:47:29,819 --> 02:47:32,100
whenever the kernel requires a new data

4103
02:47:32,100 --> 02:47:34,500
structure space for the data structure

4104
02:47:34,500 --> 02:47:36,899
is simply taken from the slab cache

4105
02:47:36,899 --> 02:47:39,600
if the slab cache starts to run out of

4106
02:47:39,600 --> 02:47:42,000
certain Slab layout it automatically

4107
02:47:42,000 --> 02:47:44,040
Provisions extras

4108
02:47:44,040 --> 02:47:46,560
graphically slabs can be represented in

4109
02:47:46,560 --> 02:47:48,060
a manner shown here

4110
02:47:48,060 --> 02:47:49,680
in this example we have two

4111
02:47:49,680 --> 02:47:51,720
pre-allocated copies of the same Slab

4112
02:47:51,720 --> 02:47:54,240
layout in which each slab can hold a

4113
02:47:54,240 --> 02:47:55,800
single instance of each of five

4114
02:47:55,800 --> 02:47:58,020
different kernel objects

4115
02:47:58,020 --> 02:48:00,180
some wasted memory does occur with this

4116
02:48:00,180 --> 02:48:01,800
Arrangement since there might be a

4117
02:48:01,800 --> 02:48:04,080
larger number one type of object than of

4118
02:48:04,080 --> 02:48:05,700
another type of object

4119
02:48:05,700 --> 02:48:08,100
however this approach is generally more

4120
02:48:08,100 --> 02:48:09,600
efficient in terms of Kernel space

4121
02:48:09,600 --> 02:48:11,580
utilization

4122
02:48:11,580 --> 02:48:14,399
slab allocation does require more CPU

4123
02:48:14,399 --> 02:48:16,439
power than does a classical method such

4124
02:48:16,439 --> 02:48:19,260
as first fit thus in some embedded

4125
02:48:19,260 --> 02:48:21,780
environments the slab allocator might be

4126
02:48:21,780 --> 02:48:23,700
preferable

4127
02:48:23,700 --> 02:48:25,260
questions

4128
02:48:25,260 --> 02:48:27,899
if slab allocation is chosen over the

4129
02:48:27,899 --> 02:48:29,939
slab allocator the Linux kernel has two

4130
02:48:29,939 --> 02:48:32,160
choices of slab allocator the first

4131
02:48:32,160 --> 02:48:34,800
choice is the original slab allocator

4132
02:48:34,800 --> 02:48:37,319
which was the default allocator until

4133
02:48:37,319 --> 02:48:40,979
kernel version 2.6.23 this allocator

4134
02:48:40,979 --> 02:48:43,319
performed well on shared memory systems

4135
02:48:43,319 --> 02:48:45,960
with few CPU cores but wasted

4136
02:48:45,960 --> 02:48:47,939
considerable memory space when used on

4137
02:48:47,939 --> 02:48:50,040
extremely large shared memory systems

4138
02:48:50,040 --> 02:48:52,080
such as those found in graphics

4139
02:48:52,080 --> 02:48:54,780
rendering Farms

4140
02:48:54,780 --> 02:48:57,359
to reduce the space waste on large-scale

4141
02:48:57,359 --> 02:49:00,540
SMA systems Kristoff lameter at silicon

4142
02:49:00,540 --> 02:49:02,580
Graphics developed a new allocator

4143
02:49:02,580 --> 02:49:05,340
called slub which reduces the size of

4144
02:49:05,340 --> 02:49:06,840
data structures needed to track

4145
02:49:06,840 --> 02:49:09,479
allocated and free objects

4146
02:49:09,479 --> 02:49:11,640
the initial implementation of the slub

4147
02:49:11,640 --> 02:49:13,380
allocator contained a performance bug

4148
02:49:13,380 --> 02:49:15,420
that affected the results of certain

4149
02:49:15,420 --> 02:49:17,700
memory benchmarking tools

4150
02:49:17,700 --> 02:49:20,220
initially Kristoff leaped the bug was of

4151
02:49:20,220 --> 02:49:22,260
little importance since the conditions

4152
02:49:22,260 --> 02:49:23,819
required to trigger it were fairly

4153
02:49:23,819 --> 02:49:25,680
uncommon in practice

4154
02:49:25,680 --> 02:49:28,140
however Lenas informed Krista that

4155
02:49:28,140 --> 02:49:30,000
either the problem would be fixed or

4156
02:49:30,000 --> 02:49:32,040
slub would be dropped entirely from the

4157
02:49:32,040 --> 02:49:33,840
kernel

4158
02:49:33,840 --> 02:49:35,880
in the end it was determined that the

4159
02:49:35,880 --> 02:49:37,920
bug was caused by adding partially used

4160
02:49:37,920 --> 02:49:40,260
slabs and beginning of a linked list

4161
02:49:40,260 --> 02:49:42,660
instead up to the end of that list

4162
02:49:42,660 --> 02:49:45,120
the fix was a change to one line of code

4163
02:49:45,120 --> 02:49:47,220
and the slub allocator has been the

4164
02:49:47,220 --> 02:49:51,240
default Linux allocator this is 2.6.23

4165
02:49:51,240 --> 02:49:53,580
in this lecture I will introduce memory

4166
02:49:53,580 --> 02:49:56,040
resources and how the system and its

4167
02:49:56,040 --> 02:50:00,260
processes view random access memory

4168
02:50:00,660 --> 02:50:03,180
in order to run any process or instance

4169
02:50:03,180 --> 02:50:06,060
of a program on a computer system we

4170
02:50:06,060 --> 02:50:08,180
need to provide two critical resources

4171
02:50:08,180 --> 02:50:11,819
access to the CPU and access to random

4172
02:50:11,819 --> 02:50:14,819
access memory or RAM for storing and

4173
02:50:14,819 --> 02:50:16,979
manipulating data

4174
02:50:16,979 --> 02:50:19,140
Ram is a type of dedicated Hardware

4175
02:50:19,140 --> 02:50:20,760
memory that is attached to the

4176
02:50:20,760 --> 02:50:21,780
motherboard

4177
02:50:21,780 --> 02:50:23,819
it is separate from persistent storage

4178
02:50:23,819 --> 02:50:25,740
or our disk space

4179
02:50:25,740 --> 02:50:28,560
Ram is also volatile which means that it

4180
02:50:28,560 --> 02:50:30,660
loses its contents whenever power is

4181
02:50:30,660 --> 02:50:33,180
interrupted to the ram modules including

4182
02:50:33,180 --> 02:50:36,780
whenever the computer is turned off

4183
02:50:36,780 --> 02:50:38,819
at a low level the computer hardware

4184
02:50:38,819 --> 02:50:40,800
presents memory to the operating system

4185
02:50:40,800 --> 02:50:43,500
as one large block of space

4186
02:50:43,500 --> 02:50:46,020
this space is divided into bytes and

4187
02:50:46,020 --> 02:50:47,880
each byte in memory has a unique address

4188
02:50:47,880 --> 02:50:50,280
that can be used to access it

4189
02:50:50,280 --> 02:50:52,920
a 32-bit architecture provides enough of

4190
02:50:52,920 --> 02:50:55,439
these byte addresses to utilize up to

4191
02:50:55,439 --> 02:50:57,540
four gigabytes of RAM

4192
02:50:57,540 --> 02:50:59,700
above that amount there is not enough

4193
02:50:59,700 --> 02:51:02,040
space in a 32-bit number to store the

4194
02:51:02,040 --> 02:51:04,439
address of any memory locations in

4195
02:51:04,439 --> 02:51:07,800
access to four gigabytes thus a 64-bit

4196
02:51:07,800 --> 02:51:09,720
architecture is required for systems

4197
02:51:09,720 --> 02:51:13,819
with more than four gigabytes of RAM

4198
02:51:13,859 --> 02:51:16,500
each process or running instance of a

4199
02:51:16,500 --> 02:51:18,479
program on a system uses a different

4200
02:51:18,479 --> 02:51:20,280
view of memory

4201
02:51:20,280 --> 02:51:22,560
process memory is divided into several

4202
02:51:22,560 --> 02:51:26,220
pieces the stack the Heat global

4203
02:51:26,220 --> 02:51:28,979
variables and the text segment

4204
02:51:28,979 --> 02:51:31,140
the stack is used to store automatic

4205
02:51:31,140 --> 02:51:33,180
variables or variables that are local to

4206
02:51:33,180 --> 02:51:36,479
functions in the C programming language

4207
02:51:36,479 --> 02:51:38,819
space on the heat is manually allocated

4208
02:51:38,819 --> 02:51:40,859
and deallocated by the programmer when

4209
02:51:40,859 --> 02:51:43,200
writing C code using the function's

4210
02:51:43,200 --> 02:51:45,960
Malik and free

4211
02:51:45,960 --> 02:51:48,660
space for extra data is located between

4212
02:51:48,660 --> 02:51:50,880
the stack and the Heap and the stack and

4213
02:51:50,880 --> 02:51:53,279
the Heap grow toward one another

4214
02:51:53,279 --> 02:51:55,260
Global variables are provided with their

4215
02:51:55,260 --> 02:51:57,120
own section of memory which is allocated

4216
02:51:57,120 --> 02:51:59,640
between the Heat and text segment

4217
02:51:59,640 --> 02:52:01,680
the text segment is used to store

4218
02:52:01,680 --> 02:52:03,000
program code

4219
02:52:03,000 --> 02:52:05,340
this segment of memory is read-only and

4220
02:52:05,340 --> 02:52:08,359
cannot be changed

4221
02:52:08,760 --> 02:52:10,620
as I mentioned in the previous slide

4222
02:52:10,620 --> 02:52:13,020
automatic variables are placed onto the

4223
02:52:13,020 --> 02:52:13,859
stack

4224
02:52:13,859 --> 02:52:15,899
this placement is performed by the

4225
02:52:15,899 --> 02:52:18,420
compiler when the program is built

4226
02:52:18,420 --> 02:52:20,399
placement of data onto the Heap is

4227
02:52:20,399 --> 02:52:22,260
historically performed by the programmer

4228
02:52:22,260 --> 02:52:24,240
although many of these operations are

4229
02:52:24,240 --> 02:52:26,040
now automated in modern dynamic

4230
02:52:26,040 --> 02:52:27,479
languages

4231
02:52:27,479 --> 02:52:29,700
in the CNC plus plus languages the

4232
02:52:29,700 --> 02:52:31,740
programmer must explicitly request and

4233
02:52:31,740 --> 02:52:34,560
release or allocate and de-allocate keep

4234
02:52:34,560 --> 02:52:35,640
space

4235
02:52:35,640 --> 02:52:38,040
in C these operations are performed

4236
02:52:38,040 --> 02:52:40,439
using the Malik and free functions while

4237
02:52:40,439 --> 02:52:42,300
the new and delete operators are used in

4238
02:52:42,300 --> 02:52:44,040
C plus

4239
02:52:44,040 --> 02:52:46,620
in Java the programmer must explicitly

4240
02:52:46,620 --> 02:52:48,660
allocate space on the Heap using the new

4241
02:52:48,660 --> 02:52:49,620
keyword

4242
02:52:49,620 --> 02:52:52,439
however the Java runtime automatically

4243
02:52:52,439 --> 02:52:54,779
determines which Heap allocations are no

4244
02:52:54,779 --> 02:52:57,240
longer in use and freeze those locations

4245
02:52:57,240 --> 02:52:59,520
automatically this process is called

4246
02:52:59,520 --> 02:53:01,859
garbage collection

4247
02:53:01,859 --> 02:53:03,779
python provides both automatic

4248
02:53:03,779 --> 02:53:06,120
allocation and garbage collection

4249
02:53:06,120 --> 02:53:08,460
whenever a data structure requires Heap

4250
02:53:08,460 --> 02:53:10,380
space the python interpreter allocates

4251
02:53:10,380 --> 02:53:11,760
it automatically

4252
02:53:11,760 --> 02:53:13,680
once the data structure is no longer

4253
02:53:13,680 --> 02:53:15,600
used by the program the garbage

4254
02:53:15,600 --> 02:53:17,220
collector deallocates it without

4255
02:53:17,220 --> 02:53:20,540
programmer intervention

4256
02:53:21,240 --> 02:53:23,340
use of heat memory and processes

4257
02:53:23,340 --> 02:53:25,020
presents a challenge to the operating

4258
02:53:25,020 --> 02:53:27,180
system because these allocations and

4259
02:53:27,180 --> 02:53:29,939
deallocations are not known in advance

4260
02:53:29,939 --> 02:53:32,040
the compiler is able to track and Report

4261
02:53:32,040 --> 02:53:34,260
the amount of Stack space needed since

4262
02:53:34,260 --> 02:53:35,760
the number of local variables in a

4263
02:53:35,760 --> 02:53:37,319
function never changes in a language

4264
02:53:37,319 --> 02:53:38,819
like C

4265
02:53:38,819 --> 02:53:40,859
however the number of Heap allocations

4266
02:53:40,859 --> 02:53:42,840
may vary from program execution to

4267
02:53:42,840 --> 02:53:45,420
program execution making it impossible

4268
02:53:45,420 --> 02:53:47,520
to know exactly how much space should be

4269
02:53:47,520 --> 02:53:49,979
allocated in advance

4270
02:53:49,979 --> 02:53:52,800
worse keep memory allocations tend to be

4271
02:53:52,800 --> 02:53:54,960
small and frequent so the process of

4272
02:53:54,960 --> 02:53:56,640
allocating memory from this section

4273
02:53:56,640 --> 02:53:58,620
needs to be fast

4274
02:53:58,620 --> 02:54:00,899
this speed and dynamic availability

4275
02:54:00,899 --> 02:54:03,120
needs to be maintained while the

4276
02:54:03,120 --> 02:54:04,800
operating system shares the computer's

4277
02:54:04,800 --> 02:54:06,960
Ram among multiple processes at the same

4278
02:54:06,960 --> 02:54:08,460
time

4279
02:54:08,460 --> 02:54:10,319
in addition to sharing memory among

4280
02:54:10,319 --> 02:54:11,880
processes the kernel has memory

4281
02:54:11,880 --> 02:54:13,979
requirements of its own

4282
02:54:13,979 --> 02:54:16,260
aside from the kernel code and its own

4283
02:54:16,260 --> 02:54:18,840
automatic variables the kernel is filled

4284
02:54:18,840 --> 02:54:20,399
with data structures that dynamically

4285
02:54:20,399 --> 02:54:22,020
grow and shrink during the course of

4286
02:54:22,020 --> 02:54:23,640
system operation

4287
02:54:23,640 --> 02:54:25,680
these data structures are numerous and

4288
02:54:25,680 --> 02:54:28,140
include process control blocks the ready

4289
02:54:28,140 --> 02:54:30,960
list scheduling views device access

4290
02:54:30,960 --> 02:54:34,439
tables and many other types of structure

4291
02:54:34,439 --> 02:54:37,500
unlike some processes however all memory

4292
02:54:37,500 --> 02:54:39,240
allocation and deallocation in the

4293
02:54:39,240 --> 02:54:41,160
kernel is performed by the kernel

4294
02:54:41,160 --> 02:54:43,560
programmers in the Linux kernel

4295
02:54:43,560 --> 02:54:45,840
programmers can use one of a number of

4296
02:54:45,840 --> 02:54:49,620
functions including K Malik Casey Alec

4297
02:54:49,620 --> 02:54:54,899
VM Alec K free and V3

4298
02:54:54,899 --> 02:54:57,120
the first issue that must be solved by

4299
02:54:57,120 --> 02:54:58,680
the kernel is sharing memory between

4300
02:54:58,680 --> 02:55:01,680
itself and a user space process

4301
02:55:01,680 --> 02:55:03,720
this sharing is accomplished first by

4302
02:55:03,720 --> 02:55:05,460
dividing the memory into two regions

4303
02:55:05,460 --> 02:55:08,279
kernel memory and user memory

4304
02:55:08,279 --> 02:55:10,200
the kernel keeps its data structures

4305
02:55:10,200 --> 02:55:13,020
program code Global variables and

4306
02:55:13,020 --> 02:55:15,120
automatic variables in kernel memory

4307
02:55:15,120 --> 02:55:17,040
isolating these items from the running

4308
02:55:17,040 --> 02:55:18,899
process

4309
02:55:18,899 --> 02:55:21,120
process memory is placed in a separate

4310
02:55:21,120 --> 02:55:23,460
region from the kernel but the kernel is

4311
02:55:23,460 --> 02:55:25,680
always available in memory

4312
02:55:25,680 --> 02:55:28,020
this mapping is necessary to maintain

4313
02:55:28,020 --> 02:55:30,120
performance whenever an interrupt occurs

4314
02:55:30,120 --> 02:55:32,279
the process makes the system call to the

4315
02:55:32,279 --> 02:55:34,560
kernel or the process experiences a

4316
02:55:34,560 --> 02:55:38,540
fault that must be handled by the kernel

4317
02:55:38,580 --> 02:55:40,680
so how do we go about running multiple

4318
02:55:40,680 --> 02:55:42,840
processes at the same time

4319
02:55:42,840 --> 02:55:44,939
well the first way we can consider which

4320
02:55:44,939 --> 02:55:46,620
is used in some types of embedded

4321
02:55:46,620 --> 02:55:48,899
systems is to divide the memory into

4322
02:55:48,899 --> 02:55:51,779
fixed size chunks called partitions

4323
02:55:51,779 --> 02:55:54,060
a memory partition is a single region of

4324
02:55:54,060 --> 02:55:56,939
ram that is provided to a single process

4325
02:55:56,939 --> 02:55:59,160
both the program code and data

4326
02:55:59,160 --> 02:56:01,200
associated with each process must fit

4327
02:56:01,200 --> 02:56:03,779
within this pre-allocated space

4328
02:56:03,779 --> 02:56:06,720
if a process grows too large it will run

4329
02:56:06,720 --> 02:56:08,760
out of memory and crash

4330
02:56:08,760 --> 02:56:10,740
furthermore the maximum number of

4331
02:56:10,740 --> 02:56:12,660
concurrent processes called the degree

4332
02:56:12,660 --> 02:56:15,300
of multi-programming is limited by the

4333
02:56:15,300 --> 02:56:17,340
number of partitions available

4334
02:56:17,340 --> 02:56:19,920
once all memory partitions are used the

4335
02:56:19,920 --> 02:56:22,560
system cannot start any new processes

4336
02:56:22,560 --> 02:56:25,140
this situation is exacerbated by the

4337
02:56:25,140 --> 02:56:27,060
fact that small processes may not be

4338
02:56:27,060 --> 02:56:29,520
using their entire partitions resulting

4339
02:56:29,520 --> 02:56:31,200
in wasted memory

4340
02:56:31,200 --> 02:56:33,840
in this lecture I will introduce paging

4341
02:56:33,840 --> 02:56:35,939
and related topics including logical

4342
02:56:35,939 --> 02:56:39,000
addressing address translation and the

4343
02:56:39,000 --> 02:56:42,439
translation look aside buffer

4344
02:56:43,740 --> 02:56:46,200
paging provides a mechanism for sharing

4345
02:56:46,200 --> 02:56:47,819
memory among multiple user space

4346
02:56:47,819 --> 02:56:50,340
processes at the same time

4347
02:56:50,340 --> 02:56:52,800
this mechanism improves upon simpler

4348
02:56:52,800 --> 02:56:54,899
algorithms such as static partitioning

4349
02:56:54,899 --> 02:56:57,359
and direct power of two methods by

4350
02:56:57,359 --> 02:56:59,640
allocating fixed size pages of memory to

4351
02:56:59,640 --> 02:57:01,140
processes

4352
02:57:01,140 --> 02:57:03,300
the key to effective memory utilization

4353
02:57:03,300 --> 02:57:05,460
with gauging is that each process is

4354
02:57:05,460 --> 02:57:08,100
given its own logical memory space

4355
02:57:08,100 --> 02:57:10,620
in other words each process has its own

4356
02:57:10,620 --> 02:57:12,300
view of memory with its own address

4357
02:57:12,300 --> 02:57:13,560
space

4358
02:57:13,560 --> 02:57:16,560
the addresses that the process sees are

4359
02:57:16,560 --> 02:57:18,540
called logical addresses

4360
02:57:18,540 --> 02:57:20,880
these logical addresses are divided into

4361
02:57:20,880 --> 02:57:22,800
fixed size pages

4362
02:57:22,800 --> 02:57:25,319
each process in the system receives its

4363
02:57:25,319 --> 02:57:27,600
own private set of pages with private

4364
02:57:27,600 --> 02:57:29,939
memory addresses

4365
02:57:29,939 --> 02:57:32,580
when a process accesses memory using one

4366
02:57:32,580 --> 02:57:34,979
of its logical addresses the CPU

4367
02:57:34,979 --> 02:57:37,020
translates The Logical address into a

4368
02:57:37,020 --> 02:57:38,340
physical address

4369
02:57:38,340 --> 02:57:40,920
physical addresses refer to locations in

4370
02:57:40,920 --> 02:57:43,760
system memory

4371
02:57:45,060 --> 02:57:47,460
for performance reasons translation is

4372
02:57:47,460 --> 02:57:49,680
done in terms of memory frames or fixed

4373
02:57:49,680 --> 02:57:51,660
size regions of ramp

4374
02:57:51,660 --> 02:57:53,819
the base frame size is normally four

4375
02:57:53,819 --> 02:57:56,340
Kitty bytes although this can vary by

4376
02:57:56,340 --> 02:57:58,380
Hardware device and most Hardware can

4377
02:57:58,380 --> 02:58:01,140
support multiple different frame sizes

4378
02:58:01,140 --> 02:58:03,300
operating systems normally use logical

4379
02:58:03,300 --> 02:58:05,460
page sizes that correspond to supported

4380
02:58:05,460 --> 02:58:07,140
Arbor frame sizes

4381
02:58:07,140 --> 02:58:09,540
again four Kibby byte pages are a

4382
02:58:09,540 --> 02:58:11,279
typical base size

4383
02:58:11,279 --> 02:58:15,120
on x86 and x8664 systems the Linux

4384
02:58:15,120 --> 02:58:17,220
kernel can support so-called huge Pages

4385
02:58:17,220 --> 02:58:19,859
which can be as large as one Gibby byte

4386
02:58:19,859 --> 02:58:24,500
when using the newest AMD and Intel CPUs

4387
02:58:25,260 --> 02:58:27,540
the key advantage to paging is that it

4388
02:58:27,540 --> 02:58:29,100
eliminates the issue of external

4389
02:58:29,100 --> 02:58:30,359
fragmentation

4390
02:58:30,359 --> 02:58:32,760
since the CPU is translating logical

4391
02:58:32,760 --> 02:58:34,740
page-based addresses into physical

4392
02:58:34,740 --> 02:58:37,680
frame-based addresses anyway there is no

4393
02:58:37,680 --> 02:58:39,240
need for the physical frames to be

4394
02:58:39,240 --> 02:58:40,620
contiguous

4395
02:58:40,620 --> 02:58:42,779
as a result we can store a data

4396
02:58:42,779 --> 02:58:44,819
structure and process memory using pages

4397
02:58:44,819 --> 02:58:47,399
that are logically contiguous however

4398
02:58:47,399 --> 02:58:49,500
when these logical pages are mapped to

4399
02:58:49,500 --> 02:58:51,540
physical frames the frames may be

4400
02:58:51,540 --> 02:58:53,580
scattered throughout ramp

4401
02:58:53,580 --> 02:58:55,560
notice that the distinction between a

4402
02:58:55,560 --> 02:58:57,000
page and a frame is a matter of

4403
02:58:57,000 --> 02:58:58,140
terminology

4404
02:58:58,140 --> 02:59:00,420
a page refers to a block of logical

4405
02:59:00,420 --> 02:59:02,520
memory while a frame refers to a block

4406
02:59:02,520 --> 02:59:04,080
of physical memory

4407
02:59:04,080 --> 02:59:05,760
for now pretend that there is a

4408
02:59:05,760 --> 02:59:07,140
one-to-one correspondence between

4409
02:59:07,140 --> 02:59:09,720
logical pages and physical frames we'll

4410
02:59:09,720 --> 02:59:13,279
make things more complicated later

4411
02:59:13,680 --> 02:59:15,540
the key to making page translation

4412
02:59:15,540 --> 02:59:17,580
efficient is that the CPU contains

4413
02:59:17,580 --> 02:59:19,560
special Hardware called the memory

4414
02:59:19,560 --> 02:59:22,500
management unit or mmu which performs

4415
02:59:22,500 --> 02:59:24,600
the translation operations

4416
02:59:24,600 --> 02:59:27,180
in this diagram the process accesses

4417
02:59:27,180 --> 02:59:29,279
memory using logical addresses which are

4418
02:59:29,279 --> 02:59:30,779
divided into pages

4419
02:59:30,779 --> 02:59:32,819
when requests are made using these

4420
02:59:32,819 --> 02:59:35,220
addresses the memory management unit on

4421
02:59:35,220 --> 02:59:37,439
the CPU translates The Logical address

4422
02:59:37,439 --> 02:59:40,319
into a corresponding physical address

4423
02:59:40,319 --> 02:59:42,600
the resulting fiscal address will be to

4424
02:59:42,600 --> 02:59:45,600
some point of the physical memory frame

4425
02:59:45,600 --> 02:59:47,640
note that individual memory addresses

4426
02:59:47,640 --> 02:59:49,620
within Pages or frames still remain

4427
02:59:49,620 --> 02:59:53,460
contiguous which is important because

4428
02:59:53,460 --> 02:59:56,040
the mmu translates page numbers to frame

4429
02:59:56,040 --> 02:59:58,620
numbers leaving the offset to the memory

4430
02:59:58,620 --> 03:00:02,720
location within the page unchanged

4431
03:00:03,600 --> 03:00:06,060
as shown in this diagram we can divide a

4432
03:00:06,060 --> 03:00:08,100
logical address from a process into two

4433
03:00:08,100 --> 03:00:11,460
components the page number P and the

4434
03:00:11,460 --> 03:00:13,859
offset d

4435
03:00:13,859 --> 03:00:16,080
when the mmu is asked to perform a

4436
03:00:16,080 --> 03:00:17,880
translation it consults the data

4437
03:00:17,880 --> 03:00:19,920
structure called a page table which

4438
03:00:19,920 --> 03:00:21,840
provides a mapping between page number

4439
03:00:21,840 --> 03:00:23,700
and frame numbers

4440
03:00:23,700 --> 03:00:26,100
using this information the mmu

4441
03:00:26,100 --> 03:00:28,380
constructs the physical address by using

4442
03:00:28,380 --> 03:00:29,779
the corresponding frame number

4443
03:00:29,779 --> 03:00:32,399
represented here about the letter F in

4444
03:00:32,399 --> 03:00:34,080
place of the page number

4445
03:00:34,080 --> 03:00:36,180
once again the offset to the particular

4446
03:00:36,180 --> 03:00:38,340
byte within the page or frame is left

4447
03:00:38,340 --> 03:00:39,899
unchanged

4448
03:00:39,899 --> 03:00:42,359
a particular byte in Ram is actually

4449
03:00:42,359 --> 03:00:44,220
addressed using the frame number and

4450
03:00:44,220 --> 03:00:47,100
offset into the frame however to the

4451
03:00:47,100 --> 03:00:49,979
process this memory access appears to

4452
03:00:49,979 --> 03:00:52,260
occur using a logical memory address

4453
03:00:52,260 --> 03:00:54,479
which is conceptually divided into a

4454
03:00:54,479 --> 03:00:56,279
page number and offset

4455
03:00:56,279 --> 03:00:58,560
the offset component is not changed by

4456
03:00:58,560 --> 03:01:00,899
the mmu but the page number is replaced

4457
03:01:00,899 --> 03:01:03,359
by the physical frame number

4458
03:01:03,359 --> 03:01:05,399
in order to perform the translation from

4459
03:01:05,399 --> 03:01:07,439
page numbers to frame numbers the mmu

4460
03:01:07,439 --> 03:01:09,300
must consult the page table

4461
03:01:09,300 --> 03:01:11,460
the page table is a data structure that

4462
03:01:11,460 --> 03:01:13,680
is itself stored in Ram in the kernel

4463
03:01:13,680 --> 03:01:15,479
memory space

4464
03:01:15,479 --> 03:01:17,880
storing the page table in Ram leads to a

4465
03:01:17,880 --> 03:01:19,800
major problem since every mmu

4466
03:01:19,800 --> 03:01:22,200
translation would require a lookup

4467
03:01:22,200 --> 03:01:24,060
since the lookup requires a memory

4468
03:01:24,060 --> 03:01:26,580
access each process memory request would

4469
03:01:26,580 --> 03:01:28,620
actually require two physical memory

4470
03:01:28,620 --> 03:01:30,180
accesses

4471
03:01:30,180 --> 03:01:32,580
this situation is especially Troublesome

4472
03:01:32,580 --> 03:01:35,100
because a memory access occurs both on

4473
03:01:35,100 --> 03:01:37,560
accessing data and upon reading the next

4474
03:01:37,560 --> 03:01:39,540
instruction to be executed

4475
03:01:39,540 --> 03:01:41,399
without some additional Hardware to

4476
03:01:41,399 --> 03:01:43,260
resolve this problem system memory

4477
03:01:43,260 --> 03:01:45,120
performance would be effectively cut in

4478
03:01:45,120 --> 03:01:47,580
two greatly reducing the overall

4479
03:01:47,580 --> 03:01:50,600
performance of the system

4480
03:01:50,819 --> 03:01:52,680
the solution for eliminating the double

4481
03:01:52,680 --> 03:01:54,540
memory access issue is to add a

4482
03:01:54,540 --> 03:01:56,220
component to the CPU called the

4483
03:01:56,220 --> 03:01:58,380
translation look aside buffer or tlb

4484
03:01:58,380 --> 03:02:02,040
which stores some paged frame mappings

4485
03:02:02,040 --> 03:02:04,620
some tlbs also provide room for address

4486
03:02:04,620 --> 03:02:06,899
space identifiers which Aid in

4487
03:02:06,899 --> 03:02:08,880
implementing memory protection

4488
03:02:08,880 --> 03:02:11,340
the tlb is a piece of associative memory

4489
03:02:11,340 --> 03:02:12,840
meaning that it can perform rapid

4490
03:02:12,840 --> 03:02:15,899
parallel searches resulting in constant

4491
03:02:15,899 --> 03:02:18,420
time lookups for page translation

4492
03:02:18,420 --> 03:02:20,580
this memory is exceptionally fast

4493
03:02:20,580 --> 03:02:23,939
meaning that it is also quite expensive

4494
03:02:23,939 --> 03:02:26,640
as a result tlb sizes are typically

4495
03:02:26,640 --> 03:02:28,620
limited from eight to four thousand

4496
03:02:28,620 --> 03:02:31,520
ninety six entries

4497
03:02:33,300 --> 03:02:35,520
the addition of the tlb provides a

4498
03:02:35,520 --> 03:02:37,140
potential shortcut for performing

4499
03:02:37,140 --> 03:02:38,819
address translation

4500
03:02:38,819 --> 03:02:40,680
instead of immediately searching the

4501
03:02:40,680 --> 03:02:42,899
page table the mmu first searches the

4502
03:02:42,899 --> 03:02:43,979
tlb

4503
03:02:43,979 --> 03:02:45,960
if the page to frame mapping can be

4504
03:02:45,960 --> 03:02:47,880
found in the tlb then it is used to

4505
03:02:47,880 --> 03:02:49,740
perform the translation from page number

4506
03:02:49,740 --> 03:02:52,920
P to frame number F this situation is

4507
03:02:52,920 --> 03:02:55,140
called a tlb it

4508
03:02:55,140 --> 03:02:57,960
a tlb missed occurs whenever the page

4509
03:02:57,960 --> 03:03:00,899
number is not present in the tlb in this

4510
03:03:00,899 --> 03:03:03,000
case the mmu must search the page table

4511
03:03:03,000 --> 03:03:04,920
to locate the appropriate frame number

4512
03:03:04,920 --> 03:03:07,560
the CPU and operating system employ

4513
03:03:07,560 --> 03:03:10,319
various policies to determine when to

4514
03:03:10,319 --> 03:03:13,319
store a page to frame mapping in the tlb

4515
03:03:13,319 --> 03:03:15,600
a simple policy would be to use a first

4516
03:03:15,600 --> 03:03:18,300
in first out policy that replaces the

4517
03:03:18,300 --> 03:03:20,100
earliest entry in the tlb with the

4518
03:03:20,100 --> 03:03:22,380
newest entry upon a tlb miss

4519
03:03:22,380 --> 03:03:24,720
other more complex and potentially

4520
03:03:24,720 --> 03:03:27,420
better policies also exist

4521
03:03:27,420 --> 03:03:29,580
in this lecture I will discuss memory

4522
03:03:29,580 --> 03:03:32,220
protection including segmentation and

4523
03:03:32,220 --> 03:03:36,380
permission bits on page table entries

4524
03:03:38,720 --> 03:03:41,220
remember the operating systems perform

4525
03:03:41,220 --> 03:03:43,800
two functions abstraction and

4526
03:03:43,800 --> 03:03:45,660
arbitration

4527
03:03:45,660 --> 03:03:48,359
mechanisms for accessing memory provide

4528
03:03:48,359 --> 03:03:50,340
abstractions of the underlying memory

4529
03:03:50,340 --> 03:03:51,660
Hardware

4530
03:03:51,660 --> 03:03:54,359
however operating systems must also

4531
03:03:54,359 --> 03:03:57,120
arbitrate access to Ram by ensuring that

4532
03:03:57,120 --> 03:03:59,700
one process cannot access memory that

4533
03:03:59,700 --> 03:04:01,380
does not belong to it

4534
03:04:01,380 --> 03:04:04,080
without this arbitration a process could

4535
03:04:04,080 --> 03:04:05,399
change memory belonging to another

4536
03:04:05,399 --> 03:04:08,880
process or worse it could crash the

4537
03:04:08,880 --> 03:04:10,859
system by changing memory that belongs

4538
03:04:10,859 --> 03:04:12,660
to the kernel

4539
03:04:12,660 --> 03:04:15,060
on systems that utilize simple memory

4540
03:04:15,060 --> 03:04:17,340
management such as power of two methods

4541
03:04:17,340 --> 03:04:19,800
memory access protections are provided

4542
03:04:19,800 --> 03:04:22,439
by a mechanism called segmentation

4543
03:04:22,439 --> 03:04:24,840
on the majority of modern systems which

4544
03:04:24,840 --> 03:04:27,180
employ aging memory protection is

4545
03:04:27,180 --> 03:04:28,859
implemented as part of the paging system

4546
03:04:28,859 --> 03:04:31,620
and memory access permissions are stored

4547
03:04:31,620 --> 03:04:34,340
in the page table

4548
03:04:35,700 --> 03:04:38,160
on any system processed memory is

4549
03:04:38,160 --> 03:04:40,439
divided into logical pieces or segments

4550
03:04:40,439 --> 03:04:42,779
that compile time these segments include

4551
03:04:42,779 --> 03:04:45,000
the text segment a region for Global

4552
03:04:45,000 --> 03:04:47,399
variables a stack region for automatic

4553
03:04:47,399 --> 03:04:49,680
variables and a heap for dynamically

4554
03:04:49,680 --> 03:04:51,840
allocated data structures

4555
03:04:51,840 --> 03:04:54,660
access permissions apply to each segment

4556
03:04:54,660 --> 03:04:57,420
in particular text segment is set to be

4557
03:04:57,420 --> 03:04:59,460
read-only

4558
03:04:59,460 --> 03:05:02,100
outside a single process there must be a

4559
03:05:02,100 --> 03:05:03,899
mechanism to track which segments of

4560
03:05:03,899 --> 03:05:06,240
memory belong to which processes

4561
03:05:06,240 --> 03:05:09,060
when a process is executing its segments

4562
03:05:09,060 --> 03:05:11,220
are marked valid so that it can access

4563
03:05:11,220 --> 03:05:13,920
the corresponding memory locations

4564
03:05:13,920 --> 03:05:15,779
segments of memory belonging to other

4565
03:05:15,779 --> 03:05:18,540
processes are marked invalid and any

4566
03:05:18,540 --> 03:05:20,399
attempt to access those segments results

4567
03:05:20,399 --> 03:05:22,859
in a fault or interrupt called the

4568
03:05:22,859 --> 03:05:24,660
segmentation fault

4569
03:05:24,660 --> 03:05:27,120
typically a segmentation fault causes

4570
03:05:27,120 --> 03:05:29,700
the process to be terminated

4571
03:05:29,700 --> 03:05:31,740
segment memory permissions are

4572
03:05:31,740 --> 03:05:34,500
implemented on non-paging systems using

4573
03:05:34,500 --> 03:05:35,760
a segment table

4574
03:05:35,760 --> 03:05:37,800
the segment table has permission bits

4575
03:05:37,800 --> 03:05:39,479
that can be applied to each region of

4576
03:05:39,479 --> 03:05:42,180
memory when memory is accessed using

4577
03:05:42,180 --> 03:05:44,819
segmentation the segment table must be

4578
03:05:44,819 --> 03:05:46,380
consulted to determine whether or not

4579
03:05:46,380 --> 03:05:49,520
the access is legal

4580
03:05:50,340 --> 03:05:52,800
in this example a process requests

4581
03:05:52,800 --> 03:05:55,500
access to memory using a logical address

4582
03:05:55,500 --> 03:05:57,359
since we do not have paging with the

4583
03:05:57,359 --> 03:05:59,399
system this logical address is not

4584
03:05:59,399 --> 03:06:01,979
translated by a page table mechanism

4585
03:06:01,979 --> 03:06:04,380
however this logical address is divided

4586
03:06:04,380 --> 03:06:06,540
into a segment address and an offset

4587
03:06:06,540 --> 03:06:09,000
into the segment in a manner similar to

4588
03:06:09,000 --> 03:06:11,100
page translation

4589
03:06:11,100 --> 03:06:13,319
the mmu checks the segment table to

4590
03:06:13,319 --> 03:06:14,880
determine if a particular memory access

4591
03:06:14,880 --> 03:06:17,760
is valid in this example the segment

4592
03:06:17,760 --> 03:06:20,100
Table stores up to four permissions and

4593
03:06:20,100 --> 03:06:23,460
up to three bits a valid invalid bit a

4594
03:06:23,460 --> 03:06:26,100
read write bit and an execute bit

4595
03:06:26,100 --> 03:06:28,560
in practice most systems that support

4596
03:06:28,560 --> 03:06:30,479
segmentation without paging normally

4597
03:06:30,479 --> 03:06:33,240
only use two bits valid and valid and

4598
03:06:33,240 --> 03:06:34,920
read write

4599
03:06:34,920 --> 03:06:37,200
if the process tries to read from a

4600
03:06:37,200 --> 03:06:39,420
segment that is marked valid the memory

4601
03:06:39,420 --> 03:06:41,760
access is permitted and occurs normal

4602
03:06:41,760 --> 03:06:43,979
the same thing happens if a process

4603
03:06:43,979 --> 03:06:46,200
tries to write to a memory location that

4604
03:06:46,200 --> 03:06:49,620
is marked both valid and writable

4605
03:06:49,620 --> 03:06:52,319
however if a process tries to write to a

4606
03:06:52,319 --> 03:06:54,840
segment marked read only or if a process

4607
03:06:54,840 --> 03:06:57,899
tries to access an invalid segment the

4608
03:06:57,899 --> 03:07:00,300
CPU triggers a segmentation fault and

4609
03:07:00,300 --> 03:07:02,040
the process is terminated

4610
03:07:02,040 --> 03:07:05,160
for some invalid accesses on a unix-like

4611
03:07:05,160 --> 03:07:07,620
system this segmentation fault may be

4612
03:07:07,620 --> 03:07:10,819
reported as a bus here

4613
03:07:11,100 --> 03:07:13,800
with paging systems which comprise the

4614
03:07:13,800 --> 03:07:15,720
majority of modern systems including

4615
03:07:15,720 --> 03:07:18,300
mobile devices memory protection is

4616
03:07:18,300 --> 03:07:20,160
accomplished by adding permission bits

4617
03:07:20,160 --> 03:07:22,260
to the page table entries

4618
03:07:22,260 --> 03:07:24,720
in general page table entries will have

4619
03:07:24,720 --> 03:07:28,020
a valid invalid bit and a read write bit

4620
03:07:28,020 --> 03:07:30,359
the valid invalid bit is used in the

4621
03:07:30,359 --> 03:07:32,939
same way as it is for segmentation pages

4622
03:07:32,939 --> 03:07:35,100
that a process is allowed to access are

4623
03:07:35,100 --> 03:07:37,920
marked valid other pages and any

4624
03:07:37,920 --> 03:07:41,279
non-existent pages are marked invalid

4625
03:07:41,279 --> 03:07:43,500
if a process attempts to access an

4626
03:07:43,500 --> 03:07:46,800
invalid page a CPU fault is raised which

4627
03:07:46,800 --> 03:07:48,540
functions like an interrupt to trap into

4628
03:07:48,540 --> 03:07:49,859
the kernel

4629
03:07:49,859 --> 03:07:52,800
a Linux kernel will send a six Sig V or

4630
03:07:52,800 --> 03:07:55,380
sigbus signal to the process depending

4631
03:07:55,380 --> 03:07:57,120
on the location and memory the process

4632
03:07:57,120 --> 03:07:58,859
tried to access

4633
03:07:58,859 --> 03:08:01,260
in practice the signal is normally not

4634
03:08:01,260 --> 03:08:03,960
caught and the process terminates

4635
03:08:03,960 --> 03:08:06,120
for historical reasons this event is

4636
03:08:06,120 --> 03:08:08,340
called the segmentation fault or seg

4637
03:08:08,340 --> 03:08:11,060
fault for short

4638
03:08:12,000 --> 03:08:14,580
the read write bit used to mark the text

4639
03:08:14,580 --> 03:08:16,740
segment of a process can be used to

4640
03:08:16,740 --> 03:08:18,420
allow pages of memory to be shared

4641
03:08:18,420 --> 03:08:20,160
between processes

4642
03:08:20,160 --> 03:08:22,920
pages that are re-entrant or read-only

4643
03:08:22,920 --> 03:08:25,680
can be accessed by multiple instances of

4644
03:08:25,680 --> 03:08:28,439
multiple programs simultaneously

4645
03:08:28,439 --> 03:08:30,479
this capability is useful on Modern

4646
03:08:30,479 --> 03:08:32,399
systems since multiple instances of

4647
03:08:32,399 --> 03:08:34,140
programs are typically run at the same

4648
03:08:34,140 --> 03:08:35,340
time

4649
03:08:35,340 --> 03:08:37,560
in the case of a web browser for example

4650
03:08:37,560 --> 03:08:40,080
it is only necessary to load one copy of

4651
03:08:40,080 --> 03:08:42,540
the browser program code into memory

4652
03:08:42,540 --> 03:08:44,700
several copies of the browser can be run

4653
03:08:44,700 --> 03:08:47,160
as several different processes sharing

4654
03:08:47,160 --> 03:08:50,520
the program code and thus saving memory

4655
03:08:50,520 --> 03:08:53,160
the open source Chromium browser and its

4656
03:08:53,160 --> 03:08:55,920
Google Chrome derivative allow each tab

4657
03:08:55,920 --> 03:08:58,140
to run in a separate process

4658
03:08:58,140 --> 03:09:00,420
shared memory Pages allow the code for

4659
03:09:00,420 --> 03:09:02,760
the browser any extensions and any

4660
03:09:02,760 --> 03:09:05,340
plugins to be loaded only once saving

4661
03:09:05,340 --> 03:09:07,700
memory

4662
03:09:08,640 --> 03:09:10,620
this diagram illustrates how two

4663
03:09:10,620 --> 03:09:13,680
processes can share a single page in Ram

4664
03:09:13,680 --> 03:09:16,140
each process sees a handful of valid

4665
03:09:16,140 --> 03:09:19,319
frames one of which is marked read only

4666
03:09:19,319 --> 03:09:21,840
if this memory frame contains code or

4667
03:09:21,840 --> 03:09:23,640
other information that can be shared

4668
03:09:23,640 --> 03:09:26,100
between the processes then the two frame

4669
03:09:26,100 --> 03:09:27,720
numbers will be identical within the

4670
03:09:27,720 --> 03:09:29,399
separate processes

4671
03:09:29,399 --> 03:09:31,560
each process may use a different page

4672
03:09:31,560 --> 03:09:33,479
number to represent this memory location

4673
03:09:33,479 --> 03:09:36,359
however since each process has its own

4674
03:09:36,359 --> 03:09:40,819
independent logical view of memory

4675
03:09:41,000 --> 03:09:43,620
incidentally this diagram is a

4676
03:09:43,620 --> 03:09:46,140
conceptual diagram only it does not

4677
03:09:46,140 --> 03:09:48,000
directly map to any particular data

4678
03:09:48,000 --> 03:09:49,460
structure in the operating system

4679
03:09:49,460 --> 03:09:52,140
instead the two tables illustrate how

4680
03:09:52,140 --> 03:09:56,300
each process might see page two

4681
03:09:56,580 --> 03:09:59,640
newer AMD and Intel CPUs support an

4682
03:09:59,640 --> 03:10:01,319
additional permission bit for setting

4683
03:10:01,319 --> 03:10:04,020
execute permissions this bit called the

4684
03:10:04,020 --> 03:10:07,080
no execute or NX bit is actually an

4685
03:10:07,080 --> 03:10:09,300
inverted permission it is set to 1

4686
03:10:09,300 --> 03:10:11,460
whenever execution of data found on a

4687
03:10:11,460 --> 03:10:13,500
memory page is forbidden

4688
03:10:13,500 --> 03:10:16,200
originally the NX bit was implemented by

4689
03:10:16,200 --> 03:10:18,960
AMD on its 64-bit capable processors

4690
03:10:18,960 --> 03:10:21,120
using the marketing name of enhanced

4691
03:10:21,120 --> 03:10:22,859
virus protection

4692
03:10:22,859 --> 03:10:25,020
Intel followed suit and added this

4693
03:10:25,020 --> 03:10:27,899
mechanism as the execute disable or XD

4694
03:10:27,899 --> 03:10:28,800
bit

4695
03:10:28,800 --> 03:10:30,660
the concept behind the bit was to

4696
03:10:30,660 --> 03:10:32,399
provide a mechanism that could be used

4697
03:10:32,399 --> 03:10:34,260
to prevent execution of native machine

4698
03:10:34,260 --> 03:10:36,899
instructions from memory space used for

4699
03:10:36,899 --> 03:10:38,460
regular data

4700
03:10:38,460 --> 03:10:40,680
although the primary beneficiary of this

4701
03:10:40,680 --> 03:10:42,779
feature was a certain virus prone system

4702
03:10:42,779 --> 03:10:45,779
that is not a Unix variant Linux kernel

4703
03:10:45,779 --> 03:10:47,580
does support the nxbit as a guard

4704
03:10:47,580 --> 03:10:49,859
against buffer overflow and similar

4705
03:10:49,859 --> 03:10:51,840
exploits

4706
03:10:51,840 --> 03:10:53,580
in the example presented in the

4707
03:10:53,580 --> 03:10:55,740
hypothetical page table here I'll leave

4708
03:10:55,740 --> 03:10:59,640
the page with hex numbers 0 4 A4 allows

4709
03:10:59,640 --> 03:11:01,319
code execution

4710
03:11:01,319 --> 03:11:03,600
in the event of an exploit attempt a

4711
03:11:03,600 --> 03:11:05,520
malicious application could try to load

4712
03:11:05,520 --> 03:11:09,359
code at another page perhaps 0 for A1

4713
03:11:09,359 --> 03:11:11,640
however since the NX bit is set on that

4714
03:11:11,640 --> 03:11:14,220
page any attempt to execute the code

4715
03:11:14,220 --> 03:11:16,620
loaded by the exploit will trigger CPU

4716
03:11:16,620 --> 03:11:19,439
fault and the process will be terminated

4717
03:11:19,439 --> 03:11:21,840
this mechanism increases the security of

4718
03:11:21,840 --> 03:11:24,180
the system against certain types of

4719
03:11:24,180 --> 03:11:25,439
attacks

4720
03:11:25,439 --> 03:11:27,359
in this lecture I will introduce test

4721
03:11:27,359 --> 03:11:28,740
driven design

4722
03:11:28,740 --> 03:11:30,479
I will Begin by discussing the

4723
03:11:30,479 --> 03:11:32,399
importance of testing then I will

4724
03:11:32,399 --> 03:11:34,560
introduce unit testing followed by an

4725
03:11:34,560 --> 03:11:38,240
overview of the test driven process

4726
03:11:39,300 --> 03:11:41,399
ing computer software serves two

4727
03:11:41,399 --> 03:11:42,479
purposes

4728
03:11:42,479 --> 03:11:44,760
first it provides a way to detect and

4729
03:11:44,760 --> 03:11:47,279
isolate buds in the application

4730
03:11:47,279 --> 03:11:49,620
any application less trivial than hello

4731
03:11:49,620 --> 03:11:52,380
world generally contains multiple bugs

4732
03:11:52,380 --> 03:11:54,540
as software matures through its life

4733
03:11:54,540 --> 03:11:56,760
cycle we expect the number of bugs in an

4734
03:11:56,760 --> 03:11:59,100
application to decrease as issues are

4735
03:11:59,100 --> 03:12:01,319
found and fixed although the number of

4736
03:12:01,319 --> 03:12:03,180
bugs in an application May decline over

4737
03:12:03,180 --> 03:12:05,580
time it is not good practice to release

4738
03:12:05,580 --> 03:12:07,859
an initial version of a program with

4739
03:12:07,859 --> 03:12:10,439
obvious and or major defects

4740
03:12:10,439 --> 03:12:13,140
thus testing should be a major component

4741
03:12:13,140 --> 03:12:14,939
of the initial software design process

4742
03:12:14,939 --> 03:12:17,040
as well as an ongoing activity

4743
03:12:17,040 --> 03:12:19,920
throughout the software life cycle

4744
03:12:19,920 --> 03:12:22,260
although we often associate testing with

4745
03:12:22,260 --> 03:12:23,939
finding and eliminating bugs in the code

4746
03:12:23,939 --> 03:12:26,460
testing serves a second purpose that is

4747
03:12:26,460 --> 03:12:28,260
at least as important

4748
03:12:28,260 --> 03:12:30,840
that is testing verifies that an

4749
03:12:30,840 --> 03:12:33,180
application actually satisfies its

4750
03:12:33,180 --> 03:12:35,160
requirements and carries out the

4751
03:12:35,160 --> 03:12:38,160
operations it is designed to perform

4752
03:12:38,160 --> 03:12:40,439
testing demonstrates that our software

4753
03:12:40,439 --> 03:12:42,359
is ultimately correct

4754
03:12:42,359 --> 03:12:44,580
in fact one principle of software

4755
03:12:44,580 --> 03:12:46,920
development is that a working program as

4756
03:12:46,920 --> 03:12:49,380
evidenced by successful testing is a

4757
03:12:49,380 --> 03:12:51,120
proof of a solution to some kind of

4758
03:12:51,120 --> 03:12:52,080
problem

4759
03:12:52,080 --> 03:12:54,240
just as mathematicians use proofs to

4760
03:12:54,240 --> 03:12:55,920
verify that steps in solving a problem

4761
03:12:55,920 --> 03:12:58,620
are correct we can treat each program as

4762
03:12:58,620 --> 03:13:00,600
approved the steps in an algorithm are

4763
03:13:00,600 --> 03:13:04,040
correct for solving a problem

4764
03:13:04,200 --> 03:13:06,359
I should emphasize here that despite the

4765
03:13:06,359 --> 03:13:08,279
recent marketing of mathematical methods

4766
03:13:08,279 --> 03:13:10,920
for software analysis in a number of

4767
03:13:10,920 --> 03:13:12,800
Professional Publications in our field

4768
03:13:12,800 --> 03:13:15,840
testing Remains the one and only way to

4769
03:13:15,840 --> 03:13:17,460
verify that a program is ultimately

4770
03:13:17,460 --> 03:13:18,600
correct

4771
03:13:18,600 --> 03:13:20,399
while mathematical methods such as

4772
03:13:20,399 --> 03:13:22,200
formal verification and design by

4773
03:13:22,200 --> 03:13:24,960
contract do have useful properties such

4774
03:13:24,960 --> 03:13:26,880
as ensuring that our specifications are

4775
03:13:26,880 --> 03:13:29,760
not internally inconsistent they do not

4776
03:13:29,760 --> 03:13:32,760
replace testing in fact showing that a

4777
03:13:32,760 --> 03:13:34,620
mathematical model correctly represents

4778
03:13:34,620 --> 03:13:36,300
a solution to a problem is

4779
03:13:36,300 --> 03:13:37,979
mathematically equivalent to writing the

4780
03:13:37,979 --> 03:13:39,359
correct program

4781
03:13:39,359 --> 03:13:41,580
furthermore we have already stated that

4782
03:13:41,580 --> 03:13:44,700
a correct program is approved

4783
03:13:44,700 --> 03:13:46,319
so how can these tools truly

4784
03:13:46,319 --> 03:13:48,540
revolutionize the way we programmed to

4785
03:13:48,540 --> 03:13:50,040
the point where programming as we know

4786
03:13:50,040 --> 03:13:52,800
it becomes extinct in other words can we

4787
03:13:52,800 --> 03:13:54,600
use the formal methods effectively and

4788
03:13:54,600 --> 03:13:56,700
efficiently to replace good programming

4789
03:13:56,700 --> 03:13:58,080
techniques

4790
03:13:58,080 --> 03:13:59,819
well the first problem is that it takes

4791
03:13:59,819 --> 03:14:01,800
roughly three times as many symbols to

4792
03:14:01,800 --> 03:14:03,720
model a program as it does to implement

4793
03:14:03,720 --> 03:14:04,859
the program

4794
03:14:04,859 --> 03:14:07,740
as Peregrine Hansen once noted how can

4795
03:14:07,740 --> 03:14:09,720
you expect to get the formal approaches

4796
03:14:09,720 --> 03:14:11,640
working correctly with three ensembles

4797
03:14:11,640 --> 03:14:13,560
if you can't write a correct program

4798
03:14:13,560 --> 03:14:16,680
with n symbols the larger issue however

4799
03:14:16,680 --> 03:14:18,840
is that all the formal approaches are

4800
03:14:18,840 --> 03:14:20,880
effectively applying various algorithms

4801
03:14:20,880 --> 03:14:23,399
to the process perhaps these algorithms

4802
03:14:23,399 --> 03:14:25,080
could save us some time by figuring out

4803
03:14:25,080 --> 03:14:26,939
whether or not our program design will

4804
03:14:26,939 --> 03:14:29,460
be correct in advance or to put it

4805
03:14:29,460 --> 03:14:31,620
mathematically perhaps these methods

4806
03:14:31,620 --> 03:14:33,359
could determine in advance if our proof

4807
03:14:33,359 --> 03:14:34,979
will work before we actually do the

4808
03:14:34,979 --> 03:14:37,140
proof by writing the program

4809
03:14:37,140 --> 03:14:39,120
turns out that David Hilbert had the

4810
03:14:39,120 --> 03:14:40,920
same question about mathematical proofs

4811
03:14:40,920 --> 03:14:42,660
back in 1928

4812
03:14:42,660 --> 03:14:44,279
the question which he called the

4813
03:14:44,279 --> 03:14:46,680
insightens problem asked if it is

4814
03:14:46,680 --> 03:14:48,420
possible for an algorithm to determine

4815
03:14:48,420 --> 03:14:49,800
whether or not a proof would be

4816
03:14:49,800 --> 03:14:51,779
successful before actually doing the

4817
03:14:51,779 --> 03:14:52,680
proof

4818
03:14:52,680 --> 03:14:55,200
within a decade Alan Turing proved that

4819
03:14:55,200 --> 03:14:57,060
the halting problem was reducible to the

4820
03:14:57,060 --> 03:14:59,819
insurance problem and he also proved the

4821
03:14:59,819 --> 03:15:01,319
halting problem is not solvable

4822
03:15:01,319 --> 03:15:02,760
algorithmically

4823
03:15:02,760 --> 03:15:05,100
thus the answer is no

4824
03:15:05,100 --> 03:15:07,260
or to put it succinctly there is no

4825
03:15:07,260 --> 03:15:10,520
substitute for testing

4826
03:15:10,560 --> 03:15:12,240
there are a number of different ways

4827
03:15:12,240 --> 03:15:14,100
that we could test a program and these

4828
03:15:14,100 --> 03:15:15,840
methods correspond to different types of

4829
03:15:15,840 --> 03:15:16,859
testing

4830
03:15:16,859 --> 03:15:19,260
for test driven design we are primarily

4831
03:15:19,260 --> 03:15:20,819
concerned with the type of testing

4832
03:15:20,819 --> 03:15:22,620
called unit testing

4833
03:15:22,620 --> 03:15:24,840
unit testing involves testing each

4834
03:15:24,840 --> 03:15:26,340
component of the application in

4835
03:15:26,340 --> 03:15:28,800
isolation ensuring that every component

4836
03:15:28,800 --> 03:15:31,080
works by itself before trying to

4837
03:15:31,080 --> 03:15:33,359
integrate it with other components

4838
03:15:33,359 --> 03:15:35,220
in an object-oriented programming

4839
03:15:35,220 --> 03:15:37,319
Paradigm a component of the program is

4840
03:15:37,319 --> 03:15:39,899
typically a single class

4841
03:15:39,899 --> 03:15:42,660
we write unit tests as assertions or

4842
03:15:42,660 --> 03:15:44,460
conditions that will be either true or

4843
03:15:44,460 --> 03:15:47,220
false we say that a unit test passes

4844
03:15:47,220 --> 03:15:49,260
whenever the result of a test matches

4845
03:15:49,260 --> 03:15:50,819
its expected result

4846
03:15:50,819 --> 03:15:53,220
when a test result does not match its

4847
03:15:53,220 --> 03:15:56,340
expected result the test fails

4848
03:15:56,340 --> 03:15:58,680
in performing unit testing we normally

4849
03:15:58,680 --> 03:16:00,359
use a combination of positive and

4850
03:16:00,359 --> 03:16:02,100
negative test cases

4851
03:16:02,100 --> 03:16:04,680
positive test cases expect the result to

4852
03:16:04,680 --> 03:16:06,899
have a value of true while negative test

4853
03:16:06,899 --> 03:16:10,819
cases expect a false answer

4854
03:16:11,160 --> 03:16:13,319
we normally automate unit testing by

4855
03:16:13,319 --> 03:16:15,540
using some kind of unit testing tool

4856
03:16:15,540 --> 03:16:17,520
that runs the test cases for us and

4857
03:16:17,520 --> 03:16:19,380
produces a report

4858
03:16:19,380 --> 03:16:22,020
a large number of automated unit testing

4859
03:16:22,020 --> 03:16:23,760
tools exist

4860
03:16:23,760 --> 03:16:26,520
one popular class of unit testing tools

4861
03:16:26,520 --> 03:16:28,979
is called X unit these are technically

4862
03:16:28,979 --> 03:16:30,840
completely different tools implemented

4863
03:16:30,840 --> 03:16:32,399
for testing components written in

4864
03:16:32,399 --> 03:16:34,439
completely different languages these

4865
03:16:34,439 --> 03:16:37,140
tools tend to operate in a similar way

4866
03:16:37,140 --> 03:16:39,479
among the different x-unit tools we have

4867
03:16:39,479 --> 03:16:42,660
junit for Java applications Pi unit for

4868
03:16:42,660 --> 03:16:46,080
python applications PHP unit for PHP

4869
03:16:46,080 --> 03:16:48,899
code in-unit for c-sharp applications

4870
03:16:48,899 --> 03:16:53,660
and CPP unit for C plus code

4871
03:16:54,240 --> 03:16:56,279
the process of using a test driven

4872
03:16:56,279 --> 03:16:58,200
design with unit testing is Illustrated

4873
03:16:58,200 --> 03:17:00,600
in this uml activity diagram

4874
03:17:00,600 --> 03:17:02,939
this diagram shows a single iteration of

4875
03:17:02,939 --> 03:17:04,800
a test driven process

4876
03:17:04,800 --> 03:17:06,899
test driven techniques are examples of

4877
03:17:06,899 --> 03:17:08,460
iterative and incremental development

4878
03:17:08,460 --> 03:17:09,899
models

4879
03:17:09,899 --> 03:17:12,420
We Begin by designing a test case which

4880
03:17:12,420 --> 03:17:14,640
must initially fail as I will discuss in

4881
03:17:14,640 --> 03:17:16,979
a moment if the test case does not

4882
03:17:16,979 --> 03:17:18,899
initially fail we continue the design

4883
03:17:18,899 --> 03:17:21,060
step until we develop a test case that

4884
03:17:21,060 --> 03:17:22,439
does fail

4885
03:17:22,439 --> 03:17:24,840
once the test case fails we write code

4886
03:17:24,840 --> 03:17:26,960
for the application until the test case

4887
03:17:26,960 --> 03:17:29,520
passes when we run the application

4888
03:17:29,520 --> 03:17:31,560
against the test case

4889
03:17:31,560 --> 03:17:33,420
we run the test as many times as

4890
03:17:33,420 --> 03:17:36,479
necessary until the test passes

4891
03:17:36,479 --> 03:17:39,180
after the test passes we refactor the

4892
03:17:39,180 --> 03:17:41,460
code to make it readable and clean

4893
03:17:41,460 --> 03:17:43,920
we then run all the test cases we've

4894
03:17:43,920 --> 03:17:45,899
ever written for the system and verify

4895
03:17:45,899 --> 03:17:48,000
that all the test cases pass

4896
03:17:48,000 --> 03:17:50,700
if not all the test cases pass we still

4897
03:17:50,700 --> 03:17:53,040
have work to do on our new code

4898
03:17:53,040 --> 03:17:55,740
once all the test cases do pass our

4899
03:17:55,740 --> 03:17:58,939
iteration is complete

4900
03:17:59,520 --> 03:18:01,680
as I mentioned a moment ago the first

4901
03:18:01,680 --> 03:18:03,720
step in an iteration using a test driven

4902
03:18:03,720 --> 03:18:05,700
process is to create a test case that

4903
03:18:05,700 --> 03:18:06,720
fails

4904
03:18:06,720 --> 03:18:08,939
at first this may seem counter-intuitive

4905
03:18:08,939 --> 03:18:12,120
why do we want a test case that fails

4906
03:18:12,120 --> 03:18:14,100
well remember that we haven't yet

4907
03:18:14,100 --> 03:18:16,080
written any code from our test driven

4908
03:18:16,080 --> 03:18:17,040
design

4909
03:18:17,040 --> 03:18:19,020
if we design a test case that

4910
03:18:19,020 --> 03:18:21,479
immediately passes we've made one of two

4911
03:18:21,479 --> 03:18:22,680
mistakes

4912
03:18:22,680 --> 03:18:25,020
either the test case is wrong

4913
03:18:25,020 --> 03:18:27,600
or the program already does whatever the

4914
03:18:27,600 --> 03:18:29,100
test is checking

4915
03:18:29,100 --> 03:18:31,260
if the test is wrong we need to fix it

4916
03:18:31,260 --> 03:18:34,020
so that we don't go to an incorrect test

4917
03:18:34,020 --> 03:18:36,120
on the other hand if the test is correct

4918
03:18:36,120 --> 03:18:38,100
and the software already passes the test

4919
03:18:38,100 --> 03:18:40,319
case then we have no new code to write

4920
03:18:40,319 --> 03:18:42,240
since the feature is already present in

4921
03:18:42,240 --> 03:18:44,840
the application

4922
03:18:45,180 --> 03:18:47,460
once we have a test case that fails we

4923
03:18:47,460 --> 03:18:49,380
write code that extends the application

4924
03:18:49,380 --> 03:18:51,720
to pass the new test case

4925
03:18:51,720 --> 03:18:53,640
this code should be as simple as

4926
03:18:53,640 --> 03:18:55,620
possible and it should be written to the

4927
03:18:55,620 --> 03:18:58,260
test it should make the application pass

4928
03:18:58,260 --> 03:19:00,720
the test nothing more

4929
03:19:00,720 --> 03:19:03,540
also this initial code does not need to

4930
03:19:03,540 --> 03:19:06,180
be pretty have correct styling except in

4931
03:19:06,180 --> 03:19:09,060
python or be especially readable at

4932
03:19:09,060 --> 03:19:13,880
first the goal here is to pass the test

4933
03:19:14,220 --> 03:19:16,979
once the test passes we refactor the

4934
03:19:16,979 --> 03:19:18,840
code to meet Style Guidelines and make

4935
03:19:18,840 --> 03:19:20,000
it readable

4936
03:19:20,000 --> 03:19:22,140
refactoring means that we change the

4937
03:19:22,140 --> 03:19:24,660
code and perhaps the design to make the

4938
03:19:24,660 --> 03:19:26,580
implementation cleaner without changing

4939
03:19:26,580 --> 03:19:28,800
the functional behavior of the program

4940
03:19:28,800 --> 03:19:30,720
we need to ensure that our refactoring

4941
03:19:30,720 --> 03:19:32,939
process has not broken The Code by

4942
03:19:32,939 --> 03:19:36,800
ensuring that the test case still access

4943
03:19:37,920 --> 03:19:40,140
once we finish the refactoring process

4944
03:19:40,140 --> 03:19:42,359
we know that the application passes the

4945
03:19:42,359 --> 03:19:43,680
new test case

4946
03:19:43,680 --> 03:19:46,260
however our new code may have introduced

4947
03:19:46,260 --> 03:19:47,880
one or more regressions in the

4948
03:19:47,880 --> 03:19:50,160
application meaning that our new code

4949
03:19:50,160 --> 03:19:52,080
may have broken something that used to

4950
03:19:52,080 --> 03:19:53,160
work

4951
03:19:53,160 --> 03:19:55,260
to check for these regressions we must

4952
03:19:55,260 --> 03:19:57,420
rerun every single test case that we

4953
03:19:57,420 --> 03:19:59,580
have ever written for the application

4954
03:19:59,580 --> 03:20:01,979
it is for this reason that it is highly

4955
03:20:01,979 --> 03:20:03,660
useful to be able to automate the

4956
03:20:03,660 --> 03:20:05,100
testing

4957
03:20:05,100 --> 03:20:07,800
if our testing finds no regressions then

4958
03:20:07,800 --> 03:20:09,960
our iteration is complete and we can

4959
03:20:09,960 --> 03:20:11,640
move on to the next iteration in the

4960
03:20:11,640 --> 03:20:13,680
process by designing a new failing test

4961
03:20:13,680 --> 03:20:16,620
case for a new feature to be implemented

4962
03:20:16,620 --> 03:20:18,840
however if regressions are present we

4963
03:20:18,840 --> 03:20:21,060
must fix the regressions

4964
03:20:21,060 --> 03:20:23,100
if the code cannot be fixed in a

4965
03:20:23,100 --> 03:20:25,140
reasonable time period we revert the

4966
03:20:25,140 --> 03:20:27,000
code to the previous version and try the

4967
03:20:27,000 --> 03:20:28,200
process again

4968
03:20:28,200 --> 03:20:30,420
in other words we throw out the code we

4969
03:20:30,420 --> 03:20:32,460
just wrote and try again

4970
03:20:32,460 --> 03:20:34,439
while throwing out the code may seem

4971
03:20:34,439 --> 03:20:37,020
like a waste it is sometimes faster to

4972
03:20:37,020 --> 03:20:38,819
try the implementation again instead of

4973
03:20:38,819 --> 03:20:41,279
becoming bogged down and debugging this

4974
03:20:41,279 --> 03:20:43,439
economy of speed is especially valued

4975
03:20:43,439 --> 03:20:45,899
when using agile methods such as extreme

4976
03:20:45,899 --> 03:20:48,180
programming

4977
03:20:48,180 --> 03:20:50,460
one final thing to consider about test

4978
03:20:50,460 --> 03:20:52,859
driven design is that like any other

4979
03:20:52,859 --> 03:20:55,200
development technique it is not the

4980
03:20:55,200 --> 03:20:57,540
perfect solution to every problem on the

4981
03:20:57,540 --> 03:20:58,260
planet

4982
03:20:58,260 --> 03:21:00,600
always be wary of claims that any

4983
03:21:00,600 --> 03:21:02,640
process or technique including test

4984
03:21:02,640 --> 03:21:05,040
driven design can somehow revolutionize

4985
03:21:05,040 --> 03:21:07,500
software development like every other

4986
03:21:07,500 --> 03:21:09,180
technique this approach has its

4987
03:21:09,180 --> 03:21:10,740
limitations

4988
03:21:10,740 --> 03:21:12,960
one limitation is the test driven design

4989
03:21:12,960 --> 03:21:15,359
depends upon unit testing and unit

4990
03:21:15,359 --> 03:21:17,580
testing has the same power as using

4991
03:21:17,580 --> 03:21:19,620
assertions in code

4992
03:21:19,620 --> 03:21:21,960
everything we test with the unit test

4993
03:21:21,960 --> 03:21:24,180
needs to be reducible to a true false

4994
03:21:24,180 --> 03:21:26,460
decision which means that we cannot unit

4995
03:21:26,460 --> 03:21:28,859
test some aspects of the system such as

4996
03:21:28,859 --> 03:21:31,740
the graphical user interface

4997
03:21:31,740 --> 03:21:33,840
another limitation of test driven design

4998
03:21:33,840 --> 03:21:36,000
is the same limitation that we have with

4999
03:21:36,000 --> 03:21:38,100
software engineering in general

5000
03:21:38,100 --> 03:21:40,020
if the specification or high level

5001
03:21:40,020 --> 03:21:42,479
design is wrong test driven design

5002
03:21:42,479 --> 03:21:44,220
cannot fix it

5003
03:21:44,220 --> 03:21:46,380
if you implement a test case using an

5004
03:21:46,380 --> 03:21:49,080
incorrect specification that test case

5005
03:21:49,080 --> 03:21:51,120
will itself be wrong

5006
03:21:51,120 --> 03:21:53,460
writing code that passes an incorrect

5007
03:21:53,460 --> 03:21:55,979
test case will Implement a non-feature

5008
03:21:55,979 --> 03:21:58,560
and the program will be wrong

5009
03:21:58,560 --> 03:22:00,899
finally the test cases must be

5010
03:22:00,899 --> 03:22:02,760
maintained over the life of the software

5011
03:22:02,760 --> 03:22:04,979
since we need to be able to regression

5012
03:22:04,979 --> 03:22:06,960
test after every change

5013
03:22:06,960 --> 03:22:09,359
if the test cases are not well written

5014
03:22:09,359 --> 03:22:11,160
so that they are themselves maintainable

5015
03:22:11,160 --> 03:22:13,859
the test cases may become useless as the

5016
03:22:13,859 --> 03:22:15,359
software evolves

5017
03:22:15,359 --> 03:22:17,279
should this happen we will lose the

5018
03:22:17,279 --> 03:22:19,500
ability to test for regressions and

5019
03:22:19,500 --> 03:22:21,359
future changes could easily break the

5020
03:22:21,359 --> 03:22:22,680
application

5021
03:22:22,680 --> 03:22:24,600
in this lecture I will discuss page

5022
03:22:24,600 --> 03:22:25,920
tables

5023
03:22:25,920 --> 03:22:28,020
age tables are data structures that

5024
03:22:28,020 --> 03:22:30,180
store mappings between logical pages and

5025
03:22:30,180 --> 03:22:32,340
process memory and physical frames and

5026
03:22:32,340 --> 03:22:33,300
ramp

5027
03:22:33,300 --> 03:22:35,580
these structures are used and managed in

5028
03:22:35,580 --> 03:22:37,080
different ways on different systems

5029
03:22:37,080 --> 03:22:40,439
often with assistance from the hardware

5030
03:22:40,439 --> 03:22:42,120
at the end of this lecture I will

5031
03:22:42,120 --> 03:22:44,220
discuss extended page tables which are

5032
03:22:44,220 --> 03:22:46,200
useful for allowing Hardware to support

5033
03:22:46,200 --> 03:22:48,479
multiple simultaneous operating systems

5034
03:22:48,479 --> 03:22:50,960
at once

5035
03:22:52,200 --> 03:22:54,180
recall from the previous lecture that

5036
03:22:54,180 --> 03:22:56,040
the page Table stores mappings between

5037
03:22:56,040 --> 03:22:58,319
age numbers and frame numbers

5038
03:22:58,319 --> 03:23:00,840
whenever a tlb Miss occurs the page

5039
03:23:00,840 --> 03:23:02,520
table must be searched to find the

5040
03:23:02,520 --> 03:23:04,080
appropriate mapping

5041
03:23:04,080 --> 03:23:06,420
CPUs have differing levels of support

5042
03:23:06,420 --> 03:23:08,040
for managing and searching the page

5043
03:23:08,040 --> 03:23:10,680
tables automatically on most modern

5044
03:23:10,680 --> 03:23:14,520
systems including x8664 and armed CPUs

5045
03:23:14,520 --> 03:23:16,739
page tables are managed and searched by

5046
03:23:16,739 --> 03:23:20,040
the CPU automatically upon tlbms

5047
03:23:20,040 --> 03:23:22,020
this search increases the memory access

5048
03:23:22,020 --> 03:23:24,479
time but no fault or interrupt is

5049
03:23:24,479 --> 03:23:25,439
generated

5050
03:23:25,439 --> 03:23:27,660
as a result the CPU does not have to

5051
03:23:27,660 --> 03:23:29,939
perform a context switch

5052
03:23:29,939 --> 03:23:32,340
among a few other CPUs the mips

5053
03:23:32,340 --> 03:23:34,260
architecture requires the operating

5054
03:23:34,260 --> 03:23:36,300
system to manage and search the page

5055
03:23:36,300 --> 03:23:37,140
table

5056
03:23:37,140 --> 03:23:39,779
whenever a tlb Miss occurs the CPU

5057
03:23:39,779 --> 03:23:41,279
triggers a fault which is a type of

5058
03:23:41,279 --> 03:23:43,859
interrupt the CPU must make a context

5059
03:23:43,859 --> 03:23:45,600
switch away from whatever tasks

5060
03:23:45,600 --> 03:23:47,700
currently being executed in order to

5061
03:23:47,700 --> 03:23:49,140
execute the interrupt Handler for

5062
03:23:49,140 --> 03:23:50,160
default

5063
03:23:50,160 --> 03:23:52,200
software managed page tables are

5064
03:23:52,200 --> 03:23:54,300
becoming increasingly uncommon even on

5065
03:23:54,300 --> 03:23:57,239
embedded systems as the popular arm CPU

5066
03:23:57,239 --> 03:23:59,040
supports Hardware management

5067
03:23:59,040 --> 03:24:01,620
the mips CPU is typically used in lower

5068
03:24:01,620 --> 03:24:04,260
end consumer devices such as inexpensive

5069
03:24:04,260 --> 03:24:06,000
e-readers and the least expensive

5070
03:24:06,000 --> 03:24:08,600
tablets

5071
03:24:10,260 --> 03:24:12,420
one approach to reducing the page table

5072
03:24:12,420 --> 03:24:14,819
search time whenever a tlb Miss occurs

5073
03:24:14,819 --> 03:24:16,739
is to store the page table as a tree

5074
03:24:16,739 --> 03:24:18,420
instead of a list

5075
03:24:18,420 --> 03:24:20,340
this technique of hierarchical page

5076
03:24:20,340 --> 03:24:22,319
tables divides the page tables into

5077
03:24:22,319 --> 03:24:23,700
pages

5078
03:24:23,700 --> 03:24:26,340
each logical address in process memory

5079
03:24:26,340 --> 03:24:28,920
is divided into an outer page table a

5080
03:24:28,920 --> 03:24:30,899
set of offsets into various levels of

5081
03:24:30,899 --> 03:24:33,420
subtables and a final offset to the

5082
03:24:33,420 --> 03:24:35,760
specific byte of memory to be accessed

5083
03:24:35,760 --> 03:24:37,859
this technique can be generalized to any

5084
03:24:37,859 --> 03:24:40,140
number of levels in the hierarchy but I

5085
03:24:40,140 --> 03:24:41,760
will present here a simple system that

5086
03:24:41,760 --> 03:24:44,100
uses only two levels

5087
03:24:44,100 --> 03:24:46,800
as Illustrated in this diagram

5088
03:24:46,800 --> 03:24:48,960
the data structure is arranged so that

5089
03:24:48,960 --> 03:24:51,120
an outer page table provides a mapping

5090
03:24:51,120 --> 03:24:52,979
between outer page numbers and Page

5091
03:24:52,979 --> 03:24:54,479
table pages

5092
03:24:54,479 --> 03:24:56,939
once the proper page table page is

5093
03:24:56,939 --> 03:24:59,460
located the translation from page number

5094
03:24:59,460 --> 03:25:01,380
to frame number can be completed quickly

5095
03:25:01,380 --> 03:25:03,840
since the page of the inner page table

5096
03:25:03,840 --> 03:25:07,100
is relatively small

5097
03:25:08,580 --> 03:25:10,979
the address translation mechanism used

5098
03:25:10,979 --> 03:25:12,960
with hierarchical page tables is more

5099
03:25:12,960 --> 03:25:14,760
complex than that used with a simple

5100
03:25:14,760 --> 03:25:16,500
linear page table

5101
03:25:16,500 --> 03:25:18,359
The Logical address is divided into

5102
03:25:18,359 --> 03:25:20,399
additional components

5103
03:25:20,399 --> 03:25:22,800
in this example with two levels in the

5104
03:25:22,800 --> 03:25:25,020
page table The Logical address is

5105
03:25:25,020 --> 03:25:27,239
divided into an outer page table entry

5106
03:25:27,239 --> 03:25:30,899
number T which specifies the location in

5107
03:25:30,899 --> 03:25:32,760
the outer page table in which to find

5108
03:25:32,760 --> 03:25:34,979
the proper inner page table

5109
03:25:34,979 --> 03:25:38,460
the next component of the address p is

5110
03:25:38,460 --> 03:25:40,739
the offset into the inner page table at

5111
03:25:40,739 --> 03:25:42,540
which the mapping can be found

5112
03:25:42,540 --> 03:25:45,300
in this example we have a single page to

5113
03:25:45,300 --> 03:25:47,279
frame mapping in each inner page table

5114
03:25:47,279 --> 03:25:49,500
entry so we can obtain the frame number

5115
03:25:49,500 --> 03:25:51,120
from that entry

5116
03:25:51,120 --> 03:25:53,520
a real system will be more complex and

5117
03:25:53,520 --> 03:25:55,439
likely will require a short linear

5118
03:25:55,439 --> 03:25:58,620
search at some level of H2

5119
03:25:58,620 --> 03:26:01,080
once the frame number is determined Ram

5120
03:26:01,080 --> 03:26:03,120
is accessed in exactly the same way as

5121
03:26:03,120 --> 03:26:05,399
it is in simpler designs with the final

5122
03:26:05,399 --> 03:26:07,859
address join a frame number and offset

5123
03:26:07,859 --> 03:26:12,200
into the physical address

5124
03:26:13,140 --> 03:26:15,060
storing the page table in a tree

5125
03:26:15,060 --> 03:26:17,340
improves access performance

5126
03:26:17,340 --> 03:26:19,260
however as the total amount of system

5127
03:26:19,260 --> 03:26:21,660
Ram continues to increase with newer and

5128
03:26:21,660 --> 03:26:24,060
newer generations of computers the size

5129
03:26:24,060 --> 03:26:26,580
of the page table also increases

5130
03:26:26,580 --> 03:26:29,340
moreover the address spaces on 64-bit

5131
03:26:29,340 --> 03:26:31,859
architectures are much larger than the

5132
03:26:31,859 --> 03:26:33,479
amount of memory that the mmu actually

5133
03:26:33,479 --> 03:26:34,920
supports

5134
03:26:34,920 --> 03:26:37,080
current 64-bit systems have True

5135
03:26:37,080 --> 03:26:39,600
Hardware address sizes in the range of

5136
03:26:39,600 --> 03:26:41,580
34 to 48 bits

5137
03:26:41,580 --> 03:26:43,920
if we were to store a mapping to handle

5138
03:26:43,920 --> 03:26:45,720
every logical page number in such a

5139
03:26:45,720 --> 03:26:47,640
system the mapping would be large and

5140
03:26:47,640 --> 03:26:49,920
inefficient since the address space is

5141
03:26:49,920 --> 03:26:53,399
sparse that is not every 64-bit logical

5142
03:26:53,399 --> 03:26:55,560
address can map to a physical location

5143
03:26:55,560 --> 03:26:58,260
in Ram since the physical addresses are

5144
03:26:58,260 --> 03:27:00,060
at most 48 bits

5145
03:27:00,060 --> 03:27:02,939
as a result many of the possible 64-bit

5146
03:27:02,939 --> 03:27:05,520
dresses are unused

5147
03:27:05,520 --> 03:27:07,680
a solution to this problem which both

5148
03:27:07,680 --> 03:27:10,140
reduces page table storage size and

5149
03:27:10,140 --> 03:27:12,420
increases search speed is to use a hash

5150
03:27:12,420 --> 03:27:15,180
table or dictionary structure to store

5151
03:27:15,180 --> 03:27:17,700
the outer page table since several

5152
03:27:17,700 --> 03:27:20,180
addresses May hash to the same value

5153
03:27:20,180 --> 03:27:23,760
each entry in the hash table is an inner

5154
03:27:23,760 --> 03:27:26,640
linear page table which allows the hash

5155
03:27:26,640 --> 03:27:28,260
collisions to be resolved through

5156
03:27:28,260 --> 03:27:30,800
chaining

5157
03:27:31,580 --> 03:27:33,960
translating a logical address to a

5158
03:27:33,960 --> 03:27:35,640
physical address with a hashed page

5159
03:27:35,640 --> 03:27:37,800
table Begins by hashing the page number

5160
03:27:37,800 --> 03:27:38,880
P

5161
03:27:38,880 --> 03:27:40,859
ashing is accomplished using a hash

5162
03:27:40,859 --> 03:27:42,960
function which may be implemented in

5163
03:27:42,960 --> 03:27:45,000
hardware for high performance

5164
03:27:45,000 --> 03:27:46,920
the hash value returned by the function

5165
03:27:46,920 --> 03:27:48,840
gives the location in the hash table

5166
03:27:48,840 --> 03:27:51,439
where the inner page table may be found

5167
03:27:51,439 --> 03:27:54,239
a linear search of the inner page table

5168
03:27:54,239 --> 03:27:57,060
is performed to locate the frame number

5169
03:27:57,060 --> 03:28:00,479
once the frame number f is obtained it

5170
03:28:00,479 --> 03:28:03,120
is joined with the offset D to give the

5171
03:28:03,120 --> 03:28:05,720
hardware address

5172
03:28:05,939 --> 03:28:09,000
Sun architectures notably power PC and

5173
03:28:09,000 --> 03:28:11,700
intelitanium store their page tables

5174
03:28:11,700 --> 03:28:12,720
backwards

5175
03:28:12,720 --> 03:28:14,880
that is the system stores a data

5176
03:28:14,880 --> 03:28:17,520
structure with one entry per frame and

5177
03:28:17,520 --> 03:28:19,380
the entry stores the corresponding page

5178
03:28:19,380 --> 03:28:21,899
number along with the process ID of the

5179
03:28:21,899 --> 03:28:23,880
process owning the page

5180
03:28:23,880 --> 03:28:25,979
this approach called an inverted page

5181
03:28:25,979 --> 03:28:28,319
table is efficient in terms of page

5182
03:28:28,319 --> 03:28:30,180
table storage size

5183
03:28:30,180 --> 03:28:32,640
however inverted page tables are

5184
03:28:32,640 --> 03:28:34,920
inefficient in terms of performance and

5185
03:28:34,920 --> 03:28:36,660
these structures are not used on a

5186
03:28:36,660 --> 03:28:39,620
majority of systems

5187
03:28:40,439 --> 03:28:43,319
a newer x8664 systems with

5188
03:28:43,319 --> 03:28:45,479
virtualization extensions Hardware

5189
03:28:45,479 --> 03:28:48,060
support exists for extended page tables

5190
03:28:48,060 --> 03:28:49,620
or EPT

5191
03:28:49,620 --> 03:28:52,080
AMD and Intel each brand this technique

5192
03:28:52,080 --> 03:28:53,580
with a different name

5193
03:28:53,580 --> 03:28:56,100
AMD uses the term rapid virtualization

5194
03:28:56,100 --> 03:29:00,180
indexing or rvi on newer CPUs they used

5195
03:29:00,180 --> 03:29:01,739
to call this technique nested page

5196
03:29:01,739 --> 03:29:03,840
tables or npt

5197
03:29:03,840 --> 03:29:06,300
Intel uses the extended page tables

5198
03:29:06,300 --> 03:29:07,680
terminology

5199
03:29:07,680 --> 03:29:11,040
EPT adds a level of paging to the system

5200
03:29:11,040 --> 03:29:13,439
at the outer level each virtual machine

5201
03:29:13,439 --> 03:29:16,920
or guest running on the CPU sees its own

5202
03:29:16,920 --> 03:29:20,040
set of memory frames isolated from and

5203
03:29:20,040 --> 03:29:22,560
independent of the actual Hardware

5204
03:29:22,560 --> 03:29:25,500
the CPU translates page numbers to frame

5205
03:29:25,500 --> 03:29:27,600
numbers first by translating the page

5206
03:29:27,600 --> 03:29:29,880
number to a guest frame number

5207
03:29:29,880 --> 03:29:31,739
the guest frame number is then

5208
03:29:31,739 --> 03:29:34,020
translated to a host frame number which

5209
03:29:34,020 --> 03:29:36,359
is the physical frame Nook

5210
03:29:36,359 --> 03:29:38,819
EPT technology is important for virtual

5211
03:29:38,819 --> 03:29:41,220
machine performance since it allows each

5212
03:29:41,220 --> 03:29:42,840
guest to manage its own memory

5213
03:29:42,840 --> 03:29:44,040
efficiently

5214
03:29:44,040 --> 03:29:46,500
moreover guests can access memory

5215
03:29:46,500 --> 03:29:48,359
without having to switch the CPU into

5216
03:29:48,359 --> 03:29:50,340
hypervisor mode which can be an

5217
03:29:50,340 --> 03:29:53,180
expensive operation

5218
03:29:54,420 --> 03:29:56,220
the downside to logical address

5219
03:29:56,220 --> 03:29:58,560
translation with extended page tables is

5220
03:29:58,560 --> 03:29:59,939
that it becomes conceptually more

5221
03:29:59,939 --> 03:30:01,920
difficult to understand as illustrated

5222
03:30:01,920 --> 03:30:04,620
by the complexity of this diagram

5223
03:30:04,620 --> 03:30:06,600
a process running in a guest operating

5224
03:30:06,600 --> 03:30:09,060
system makes a memory request just as it

5225
03:30:09,060 --> 03:30:11,640
would if no virtualization or present

5226
03:30:11,640 --> 03:30:13,800
this memory request is divided into a

5227
03:30:13,800 --> 03:30:17,580
page number and an offset as usual

5228
03:30:17,580 --> 03:30:20,160
the CPU then performs translation of

5229
03:30:20,160 --> 03:30:23,279
this page number P to a frame number F

5230
03:30:23,279 --> 03:30:25,380
also as usual

5231
03:30:25,380 --> 03:30:27,479
furthermore as far as the guest

5232
03:30:27,479 --> 03:30:29,460
operating system is concerned the

5233
03:30:29,460 --> 03:30:32,100
translation is complete the guest OS

5234
03:30:32,100 --> 03:30:33,960
sees the memory region provided by the

5235
03:30:33,960 --> 03:30:36,420
host system as if that memory were

5236
03:30:36,420 --> 03:30:38,760
physical memory in other words the guest

5237
03:30:38,760 --> 03:30:41,040
OS has no idea that is running in a

5238
03:30:41,040 --> 03:30:42,180
virtual machine

5239
03:30:42,180 --> 03:30:44,100
to the guest OS the virtual machine

5240
03:30:44,100 --> 03:30:47,640
looks just like a physical system

5241
03:30:47,640 --> 03:30:50,700
however in reality the guest's physical

5242
03:30:50,700 --> 03:30:53,040
memory is actually an illusion provided

5243
03:30:53,040 --> 03:30:54,300
by The Host

5244
03:30:54,300 --> 03:30:56,640
to make the solution work the host must

5245
03:30:56,640 --> 03:30:59,399
translate the frame number F in guest

5246
03:30:59,399 --> 03:31:01,920
memory to an actual physical frame

5247
03:31:01,920 --> 03:31:03,540
number G

5248
03:31:03,540 --> 03:31:06,060
this translation is performed by the CPU

5249
03:31:06,060 --> 03:31:08,220
without any context remote switches

5250
03:31:08,220 --> 03:31:10,800
using the EPT table

5251
03:31:10,800 --> 03:31:13,319
once this translation is performed the

5252
03:31:13,319 --> 03:31:15,720
physical memory address is generated by

5253
03:31:15,720 --> 03:31:18,540
combining G and D where D is the

5254
03:31:18,540 --> 03:31:22,140
original unchanged offset into the page

5255
03:31:22,140 --> 03:31:24,060
it is important to note that this entire

5256
03:31:24,060 --> 03:31:26,880
process is performed by the CPU without

5257
03:31:26,880 --> 03:31:30,779
switching to the host Os or hypervisor

5258
03:31:30,779 --> 03:31:33,180
in this lecture I will introduce basic

5259
03:31:33,180 --> 03:31:35,160
uml class diagrams

5260
03:31:35,160 --> 03:31:36,779
this introduction will be language

5261
03:31:36,779 --> 03:31:38,640
independent and will focus on the

5262
03:31:38,640 --> 03:31:40,380
diagrams themselves

5263
03:31:40,380 --> 03:31:42,840
I will cover language specific uses of

5264
03:31:42,840 --> 03:31:46,819
class diagrams in later lectures

5265
03:31:49,080 --> 03:31:51,300
uml class diagrams provide a graphical

5266
03:31:51,300 --> 03:31:53,340
way to illustrate relationships between

5267
03:31:53,340 --> 03:31:55,380
classes and an object-oriented system

5268
03:31:55,380 --> 03:31:57,540
they also provide a way to draw an

5269
03:31:57,540 --> 03:32:00,239
abstract diagram of a class so that we

5270
03:32:00,239 --> 03:32:02,220
can inspect features visually without

5271
03:32:02,220 --> 03:32:04,800
having to resort to looking at code

5272
03:32:04,800 --> 03:32:07,500
although class diagrams are uml standard

5273
03:32:07,500 --> 03:32:09,420
in practice there are differences

5274
03:32:09,420 --> 03:32:11,160
between the diagrams produced by

5275
03:32:11,160 --> 03:32:12,600
different tools

5276
03:32:12,600 --> 03:32:15,300
not all tools support all uml features

5277
03:32:15,300 --> 03:32:18,660
some tools add extra features and the

5278
03:32:18,660 --> 03:32:20,760
final appearance of diagrams drawn by

5279
03:32:20,760 --> 03:32:23,520
different tools varies

5280
03:32:23,520 --> 03:32:25,739
certain uml tools are capable of

5281
03:32:25,739 --> 03:32:28,020
round-trip engineering which means they

5282
03:32:28,020 --> 03:32:30,120
can draw uml-class diagrams from

5283
03:32:30,120 --> 03:32:32,819
existing code and generate program code

5284
03:32:32,819 --> 03:32:34,800
from uml models

5285
03:32:34,800 --> 03:32:36,960
generated code provides templates

5286
03:32:36,960 --> 03:32:39,540
classes that programmers can finish

5287
03:32:39,540 --> 03:32:41,460
the ability to perform round-trip

5288
03:32:41,460 --> 03:32:43,080
engineering depends upon having a

5289
03:32:43,080 --> 03:32:44,819
programming language the tool can parse

5290
03:32:44,819 --> 03:32:47,939
or upon having a uml class diagram model

5291
03:32:47,939 --> 03:32:51,739
in a format the tool can use

5292
03:32:52,739 --> 03:32:54,840
the basic entity in the uml class

5293
03:32:54,840 --> 03:32:56,819
diagram is a class

5294
03:32:56,819 --> 03:32:59,279
Es are represented in the simplest Case

5295
03:32:59,279 --> 03:33:02,640
by boxes containing the class name

5296
03:33:02,640 --> 03:33:04,800
here we have a sample class named hello

5297
03:33:04,800 --> 03:33:06,840
world represented by a rather

5298
03:33:06,840 --> 03:33:09,859
underwhelming box

5299
03:33:10,979 --> 03:33:14,040
in object-oriented designs the data

5300
03:33:14,040 --> 03:33:16,020
members of a class are often called

5301
03:33:16,020 --> 03:33:17,399
fields

5302
03:33:17,399 --> 03:33:20,160
class fields are listed in a uml diagram

5303
03:33:20,160 --> 03:33:22,680
between two horizontal lines under the

5304
03:33:22,680 --> 03:33:25,620
class name Inside the Box representing

5305
03:33:25,620 --> 03:33:27,180
the class

5306
03:33:27,180 --> 03:33:29,340
the first character in the field name

5307
03:33:29,340 --> 03:33:32,520
gives the field scope a plus sign for

5308
03:33:32,520 --> 03:33:34,680
public scope and a minus sign for

5309
03:33:34,680 --> 03:33:36,120
private scope

5310
03:33:36,120 --> 03:33:38,040
there are other Scopes which are

5311
03:33:38,040 --> 03:33:40,200
represented by other symbols but

5312
03:33:40,200 --> 03:33:41,640
remember that different implementation

5313
03:33:41,640 --> 03:33:45,060
languages support different scopes

5314
03:33:45,060 --> 03:33:47,460
different programming languages also use

5315
03:33:47,460 --> 03:33:49,260
different type systems

5316
03:33:49,260 --> 03:33:52,200
in the pure case uml class diagrams can

5317
03:33:52,200 --> 03:33:54,540
be drawn to be language independent

5318
03:33:54,540 --> 03:33:57,180
in practice however most uml class

5319
03:33:57,180 --> 03:33:59,040
diagrams have language dependent

5320
03:33:59,040 --> 03:34:01,500
semantics which include the type system

5321
03:34:01,500 --> 03:34:04,680
used in the target language

5322
03:34:04,680 --> 03:34:06,899
in this example the hello world class

5323
03:34:06,899 --> 03:34:08,399
has one field

5324
03:34:08,399 --> 03:34:10,979
a private member named message which is

5325
03:34:10,979 --> 03:34:13,859
of type message with a capital m

5326
03:34:13,859 --> 03:34:16,260
the capitalized message refers to

5327
03:34:16,260 --> 03:34:19,080
another class named message of which

5328
03:34:19,080 --> 03:34:21,359
message with the lowercase m is an

5329
03:34:21,359 --> 03:34:23,720
instance

5330
03:34:24,540 --> 03:34:27,239
methods or member functions in C plus

5331
03:34:27,239 --> 03:34:30,359
speak go below the class fields in the

5332
03:34:30,359 --> 03:34:32,700
bottom section of a Class Bus

5333
03:34:32,700 --> 03:34:34,620
these methods are functions that are

5334
03:34:34,620 --> 03:34:37,020
members of the class which can be called

5335
03:34:37,020 --> 03:34:39,899
to operate on instances of objects

5336
03:34:39,899 --> 03:34:42,300
static methods or methods that can stand

5337
03:34:42,300 --> 03:34:44,160
alone without having to be called from

5338
03:34:44,160 --> 03:34:47,460
an instance of a class are underlined

5339
03:34:47,460 --> 03:34:49,680
the same scoping and typing conventions

5340
03:34:49,680 --> 03:34:51,660
are used for methods as are used for

5341
03:34:51,660 --> 03:34:54,420
Fields as with Fields the exact

5342
03:34:54,420 --> 03:34:56,700
semantics tend to vary from tool to tool

5343
03:34:56,700 --> 03:34:58,500
with each tool using a slightly

5344
03:34:58,500 --> 03:35:00,180
different format

5345
03:35:00,180 --> 03:35:02,220
in this example we have added five

5346
03:35:02,220 --> 03:35:05,160
methods to our class all of them public

5347
03:35:05,160 --> 03:35:07,439
we have Setter and getter methods for

5348
03:35:07,439 --> 03:35:10,020
the underlying message set message and

5349
03:35:10,020 --> 03:35:13,439
get message respectively the class also

5350
03:35:13,439 --> 03:35:15,359
has a mechanism to display the messages

5351
03:35:15,359 --> 03:35:17,939
using the speak method

5352
03:35:17,939 --> 03:35:20,220
two of the methods are special

5353
03:35:20,220 --> 03:35:22,020
the first of these is the hello world

5354
03:35:22,020 --> 03:35:23,819
method which represents the class

5355
03:35:23,819 --> 03:35:25,200
Constructor

5356
03:35:25,200 --> 03:35:27,779
the second is the underlined main method

5357
03:35:27,779 --> 03:35:29,880
which is a static method that implements

5358
03:35:29,880 --> 03:35:31,739
a main driver program for the

5359
03:35:31,739 --> 03:35:34,819
object-oriented system

5360
03:35:35,840 --> 03:35:38,460
relationships between classes in uml

5361
03:35:38,460 --> 03:35:40,859
class diagrams are represented by lines

5362
03:35:40,859 --> 03:35:42,840
connecting the classes together

5363
03:35:42,840 --> 03:35:45,000
these relationships fall into two

5364
03:35:45,000 --> 03:35:47,460
general categories generalization

5365
03:35:47,460 --> 03:35:49,560
relationships which show inheritance

5366
03:35:49,560 --> 03:35:51,840
between classes and Association

5367
03:35:51,840 --> 03:35:54,000
relationships which show how instances

5368
03:35:54,000 --> 03:35:56,580
of classes relate to each other

5369
03:35:56,580 --> 03:35:59,279
each relationship in a class diagram can

5370
03:35:59,279 --> 03:36:01,439
have multiplicity numbers assigned one

5371
03:36:01,439 --> 03:36:03,720
or both ends of line connecting the

5372
03:36:03,720 --> 03:36:04,859
glasses

5373
03:36:04,859 --> 03:36:07,080
multiplicities can consist of a single

5374
03:36:07,080 --> 03:36:09,840
number such as the number one or a range

5375
03:36:09,840 --> 03:36:12,660
of numbers separated by two dots

5376
03:36:12,660 --> 03:36:14,880
if the range is unbounded the second

5377
03:36:14,880 --> 03:36:17,399
value after the dots is a star instead

5378
03:36:17,399 --> 03:36:18,500
of a number

5379
03:36:18,500 --> 03:36:21,120
multiplicity values specify how many

5380
03:36:21,120 --> 03:36:23,279
instances of a class are involved in a

5381
03:36:23,279 --> 03:36:24,479
relationship

5382
03:36:24,479 --> 03:36:26,760
as an example if a relationship between

5383
03:36:26,760 --> 03:36:29,819
class is Foo and bar has a multiplicity

5384
03:36:29,819 --> 03:36:33,600
of one on the food side and zero dot dot

5385
03:36:33,600 --> 03:36:37,020
star or just a single Star by itself on

5386
03:36:37,020 --> 03:36:38,279
the bar side

5387
03:36:38,279 --> 03:36:40,680
that relationship specifies that for

5388
03:36:40,680 --> 03:36:43,020
every single instance of Foo there can

5389
03:36:43,020 --> 03:36:45,540
be zero or more instances of bar in the

5390
03:36:45,540 --> 03:36:48,020
relationship

5391
03:36:48,120 --> 03:36:50,640
as I mentioned before one of the two

5392
03:36:50,640 --> 03:36:52,800
categories of relationship in a uml

5393
03:36:52,800 --> 03:36:54,660
class diagram is the generalization

5394
03:36:54,660 --> 03:36:57,359
which expresses the is a relationship

5395
03:36:57,359 --> 03:36:59,220
between classes

5396
03:36:59,220 --> 03:37:01,260
this relationship corresponds to

5397
03:37:01,260 --> 03:37:03,120
inheritance in an object-oriented

5398
03:37:03,120 --> 03:37:04,979
programming language

5399
03:37:04,979 --> 03:37:07,800
in this example the simple message is a

5400
03:37:07,800 --> 03:37:10,260
type of message in other words the

5401
03:37:10,260 --> 03:37:12,720
simple message class is a child class of

5402
03:37:12,720 --> 03:37:14,819
the message parent class

5403
03:37:14,819 --> 03:37:17,040
this relationship is drawn by connecting

5404
03:37:17,040 --> 03:37:19,260
a line from the simple message class to

5405
03:37:19,260 --> 03:37:22,140
the message class with a hollow Arrow at

5406
03:37:22,140 --> 03:37:24,000
the message end pointing to the parent

5407
03:37:24,000 --> 03:37:25,380
class

5408
03:37:25,380 --> 03:37:27,840
we leave off multiplicity on this type

5409
03:37:27,840 --> 03:37:29,880
of relationship since generalizations

5410
03:37:29,880 --> 03:37:32,220
are between classes themselves and not

5411
03:37:32,220 --> 03:37:35,779
between instances of classes

5412
03:37:36,300 --> 03:37:38,100
the first type of Association

5413
03:37:38,100 --> 03:37:40,260
relationship that I will describe is the

5414
03:37:40,260 --> 03:37:42,120
aggregation relationship

5415
03:37:42,120 --> 03:37:44,880
an aggregation is a weak type of Hazard

5416
03:37:44,880 --> 03:37:47,880
relationship between Class instances in

5417
03:37:47,880 --> 03:37:50,100
which an instance of one class provides

5418
03:37:50,100 --> 03:37:51,840
a collection of instances of other

5419
03:37:51,840 --> 03:37:53,160
classes

5420
03:37:53,160 --> 03:37:55,380
it is important to note that aggregation

5421
03:37:55,380 --> 03:37:58,020
relationships are considered weak Hazard

5422
03:37:58,020 --> 03:38:00,600
relationships because the instances that

5423
03:38:00,600 --> 03:38:02,340
are collected by the collecting class

5424
03:38:02,340 --> 03:38:04,380
can exist independently from the

5425
03:38:04,380 --> 03:38:05,880
collecting class

5426
03:38:05,880 --> 03:38:08,220
in practice this means that we create

5427
03:38:08,220 --> 03:38:11,399
instances of various classes and then

5428
03:38:11,399 --> 03:38:13,620
add those instances to the collection

5429
03:38:13,620 --> 03:38:16,200
typically with a dedicated method in The

5430
03:38:16,200 --> 03:38:17,460
Collector

5431
03:38:17,460 --> 03:38:20,100
for example here we have a multi-message

5432
03:38:20,100 --> 03:38:22,080
class that acts as a collection of

5433
03:38:22,080 --> 03:38:24,660
message instances as indicated by the

5434
03:38:24,660 --> 03:38:26,520
relationship with the hollow Diamond at

5435
03:38:26,520 --> 03:38:28,319
the multi-message end

5436
03:38:28,319 --> 03:38:31,080
multi-message provides a method add

5437
03:38:31,080 --> 03:38:33,479
message to add an instance of a message

5438
03:38:33,479 --> 03:38:35,100
to the collection

5439
03:38:35,100 --> 03:38:37,200
this instance is already created

5440
03:38:37,200 --> 03:38:39,300
elsewhere in the code before the add

5441
03:38:39,300 --> 03:38:41,220
message method is called to add it to

5442
03:38:41,220 --> 03:38:43,620
the collection

5443
03:38:43,620 --> 03:38:45,899
if we want a class to contain instances

5444
03:38:45,899 --> 03:38:47,819
of other classes without having to

5445
03:38:47,819 --> 03:38:49,620
manage collections we can use a

5446
03:38:49,620 --> 03:38:51,420
composition relationship

5447
03:38:51,420 --> 03:38:53,760
a composition is a Titan Association

5448
03:38:53,760 --> 03:38:55,859
that expresses a strong Hazard

5449
03:38:55,859 --> 03:38:58,020
relationship between classes

5450
03:38:58,020 --> 03:39:00,120
in a composition a class instance

5451
03:39:00,120 --> 03:39:02,040
contains one or more instances of

5452
03:39:02,040 --> 03:39:04,560
another class and those instances are

5453
03:39:04,560 --> 03:39:06,540
created or destroyed by the containing

5454
03:39:06,540 --> 03:39:07,739
class

5455
03:39:07,739 --> 03:39:09,660
it is important to understand this key

5456
03:39:09,660 --> 03:39:11,760
distinction between an aggregation and a

5457
03:39:11,760 --> 03:39:12,899
composition

5458
03:39:12,899 --> 03:39:15,479
with an aggregation we create instances

5459
03:39:15,479 --> 03:39:18,359
to add to the collection then add them

5460
03:39:18,359 --> 03:39:19,800
to the collection

5461
03:39:19,800 --> 03:39:22,439
for the composition the instances are

5462
03:39:22,439 --> 03:39:23,819
normally created in the class

5463
03:39:23,819 --> 03:39:26,460
Constructor for the composing class and

5464
03:39:26,460 --> 03:39:28,500
destroyed by the destructor of the

5465
03:39:28,500 --> 03:39:30,060
composing class

5466
03:39:30,060 --> 03:39:32,279
there are no methods to manage the

5467
03:39:32,279 --> 03:39:35,340
collection of composed instances

5468
03:39:35,340 --> 03:39:37,620
graphically the composition relationship

5469
03:39:37,620 --> 03:39:40,140
is represented by a filled Diamond at

5470
03:39:40,140 --> 03:39:41,939
the composing instance end of the

5471
03:39:41,939 --> 03:39:44,100
relationship as shown in this example

5472
03:39:44,100 --> 03:39:46,979
here we have a double message composing

5473
03:39:46,979 --> 03:39:49,680
instance that contains two instances of

5474
03:39:49,680 --> 03:39:51,180
simple message

5475
03:39:51,180 --> 03:39:53,220
as shown by the multiplicity of the

5476
03:39:53,220 --> 03:39:55,260
relationship each instance of double

5477
03:39:55,260 --> 03:39:57,660
message has exactly two simple message

5478
03:39:57,660 --> 03:40:00,180
instances contained within it

5479
03:40:00,180 --> 03:40:02,520
these simple message instances will be

5480
03:40:02,520 --> 03:40:04,140
created whenever an instance of the

5481
03:40:04,140 --> 03:40:06,840
double message class is created and both

5482
03:40:06,840 --> 03:40:09,000
simple message instances will be

5483
03:40:09,000 --> 03:40:11,939
destroyed with the double message

5484
03:40:11,939 --> 03:40:14,279
in this lecture I will begin discussing

5485
03:40:14,279 --> 03:40:15,960
virtual memory

5486
03:40:15,960 --> 03:40:17,700
due to the complexity of the virtual

5487
03:40:17,700 --> 03:40:19,920
memory subsystem the second part of this

5488
03:40:19,920 --> 03:40:21,660
introduction will be given as a second

5489
03:40:21,660 --> 03:40:24,140
lecture

5490
03:40:24,960 --> 03:40:26,939
we have previously seen that each

5491
03:40:26,939 --> 03:40:29,040
process in the system can be given its

5492
03:40:29,040 --> 03:40:31,200
own logical memory space

5493
03:40:31,200 --> 03:40:33,899
this Arrangement allows logical pages to

5494
03:40:33,899 --> 03:40:36,180
be mapped to physical frames without the

5495
03:40:36,180 --> 03:40:37,739
need for physical frames to be

5496
03:40:37,739 --> 03:40:40,140
contiguous eliminating external

5497
03:40:40,140 --> 03:40:42,180
fragmentation and increasing the degree

5498
03:40:42,180 --> 03:40:44,460
of multi-programming that A system can

5499
03:40:44,460 --> 03:40:46,020
support

5500
03:40:46,020 --> 03:40:48,180
we can further increase the degree of

5501
03:40:48,180 --> 03:40:49,979
multi-programming in a system by

5502
03:40:49,979 --> 03:40:51,899
recognizing that processes do not

5503
03:40:51,899 --> 03:40:54,540
actually use all the memory in their

5504
03:40:54,540 --> 03:40:57,720
logical address spaces at any given time

5505
03:40:57,720 --> 03:40:59,819
parts of the program code including

5506
03:40:59,819 --> 03:41:01,620
error handlers and infrequently called

5507
03:41:01,620 --> 03:41:05,220
functions are not utilized often

5508
03:41:05,220 --> 03:41:07,500
furthermore arrays and other data

5509
03:41:07,500 --> 03:41:09,840
structures are often oversized and used

5510
03:41:09,840 --> 03:41:13,140
in sections instead of all at once

5511
03:41:13,140 --> 03:41:15,899
if we can swap unused pages out of

5512
03:41:15,899 --> 03:41:18,420
memory and onto a backing store such as

5513
03:41:18,420 --> 03:41:21,420
a hard disk we can fit more processes

5514
03:41:21,420 --> 03:41:23,880
into memory at once increasing our

5515
03:41:23,880 --> 03:41:26,040
degree of multi-programming

5516
03:41:26,040 --> 03:41:28,680
furthermore we can give each process its

5517
03:41:28,680 --> 03:41:31,920
own large logical memory space which can

5518
03:41:31,920 --> 03:41:33,960
in fact be larger than the amount of

5519
03:41:33,960 --> 03:41:37,220
physical RAM on the system

5520
03:41:38,160 --> 03:41:40,380
when we add a backing store the general

5521
03:41:40,380 --> 03:41:43,080
address translation process Remains the

5522
03:41:43,080 --> 03:41:44,000
Same

5523
03:41:44,000 --> 03:41:46,680
processes Access Memory using logical

5524
03:41:46,680 --> 03:41:48,779
addresses which are translated into

5525
03:41:48,779 --> 03:41:51,479
physical addresses by the mmu

5526
03:41:51,479 --> 03:41:53,819
the page table was still utilized to

5527
03:41:53,819 --> 03:41:56,340
store the page-to-frame mappings

5528
03:41:56,340 --> 03:41:59,040
however we do add some complexity in

5529
03:41:59,040 --> 03:42:00,840
that a frame could be swapped out to

5530
03:42:00,840 --> 03:42:03,060
disk at the time when it is needed

5531
03:42:03,060 --> 03:42:05,580
the CPU must provide a mechanism to

5532
03:42:05,580 --> 03:42:07,859
detect the situation and generate a

5533
03:42:07,859 --> 03:42:09,420
fault that the operating system can

5534
03:42:09,420 --> 03:42:11,760
handle to bring the required page back

5535
03:42:11,760 --> 03:42:14,779
into physical memory

5536
03:42:16,140 --> 03:42:19,260
the process of moving Pages or frames of

5537
03:42:19,260 --> 03:42:21,600
memory back and forth between RAM and

5538
03:42:21,600 --> 03:42:23,880
the backing store is known either as

5539
03:42:23,880 --> 03:42:26,160
swapping or as paging

5540
03:42:26,160 --> 03:42:28,800
historically the term swapping referred

5541
03:42:28,800 --> 03:42:30,600
to the movement of entire logical

5542
03:42:30,600 --> 03:42:33,540
address spaces or entire processes

5543
03:42:33,540 --> 03:42:36,120
between RAM and disk

5544
03:42:36,120 --> 03:42:39,540
moving single Pages or frames of data

5545
03:42:39,540 --> 03:42:41,279
between RAM and the disk was called

5546
03:42:41,279 --> 03:42:42,840
paging

5547
03:42:42,840 --> 03:42:45,359
in modern practice both terms are used

5548
03:42:45,359 --> 03:42:47,700
interchangeably in the Linux kernel

5549
03:42:47,700 --> 03:42:49,680
component that performs page movements

5550
03:42:49,680 --> 03:42:52,260
is called swapper

5551
03:42:52,260 --> 03:42:54,899
a single movement of a single page frame

5552
03:42:54,899 --> 03:42:57,300
into or out of physical memory is called

5553
03:42:57,300 --> 03:42:58,880
a page swap

5554
03:42:58,880 --> 03:43:01,380
historically Linux machines use the

5555
03:43:01,380 --> 03:43:03,479
dedicated hard disk partition to store

5556
03:43:03,479 --> 03:43:06,720
the pages that were swapped out to disk

5557
03:43:06,720 --> 03:43:09,120
modern versions of Linux are just as

5558
03:43:09,120 --> 03:43:11,760
efficient using a swap file which is a

5559
03:43:11,760 --> 03:43:14,160
regular file stored alongside other data

5560
03:43:14,160 --> 03:43:16,260
in the file system

5561
03:43:16,260 --> 03:43:18,540
it should be noted that swapping is an

5562
03:43:18,540 --> 03:43:21,239
optional feature and it is possible and

5563
03:43:21,239 --> 03:43:24,120
even quite common to run systems without

5564
03:43:24,120 --> 03:43:27,300
any backing store or swapping capability

5565
03:43:27,300 --> 03:43:29,580
most embedded Linux systems such as

5566
03:43:29,580 --> 03:43:31,979
Android devices do not use a backing

5567
03:43:31,979 --> 03:43:32,939
store

5568
03:43:32,939 --> 03:43:35,160
if memory cannot be allocated to a

5569
03:43:35,160 --> 03:43:37,319
process on such a system the process

5570
03:43:37,319 --> 03:43:40,399
typically crashes

5571
03:43:41,100 --> 03:43:44,100
now page swaps are implemented by the

5572
03:43:44,100 --> 03:43:45,660
operating system

5573
03:43:45,660 --> 03:43:47,640
some assistance from Hardware is

5574
03:43:47,640 --> 03:43:49,680
required to determine when a page swap

5575
03:43:49,680 --> 03:43:51,660
needs to be performed

5576
03:43:51,660 --> 03:43:53,760
when translating a page number to a

5577
03:43:53,760 --> 03:43:55,979
frame number the mmu checks to see if

5578
03:43:55,979 --> 03:43:58,560
the corresponding frame is resident or

5579
03:43:58,560 --> 03:44:00,840
loaded in Ram

5580
03:44:00,840 --> 03:44:03,000
if the frame is present the memory

5581
03:44:03,000 --> 03:44:05,880
access proceeds as normal

5582
03:44:05,880 --> 03:44:08,040
if the frame is not present in Ram

5583
03:44:08,040 --> 03:44:11,100
however the mmu generates a page fold

5584
03:44:11,100 --> 03:44:13,920
which is a CPU exception that is similar

5585
03:44:13,920 --> 03:44:16,620
in concept to an interrupt a specific

5586
03:44:16,620 --> 03:44:18,660
page fault handling routine is

5587
03:44:18,660 --> 03:44:20,880
registered with the system either as

5588
03:44:20,880 --> 03:44:22,800
part of the interrupt Vector table or

5589
03:44:22,800 --> 03:44:24,600
using a separate structure for fault

5590
03:44:24,600 --> 03:44:25,859
handlers

5591
03:44:25,859 --> 03:44:28,680
a page fault causes this routine known

5592
03:44:28,680 --> 03:44:31,859
as the swapper in Linux to be invoked

5593
03:44:31,859 --> 03:44:33,960
it is then the responsibility of the

5594
03:44:33,960 --> 03:44:36,000
swapper to locate the missing page on

5595
03:44:36,000 --> 03:44:38,239
the backing store and load it into RAM

5596
03:44:38,239 --> 03:44:41,580
possibly moving some other page frame to

5597
03:44:41,580 --> 03:44:45,500
the backing store in the process

5598
03:44:46,500 --> 03:44:49,380
the address translation process gains a

5599
03:44:49,380 --> 03:44:52,260
few steps when paging is utilized

5600
03:44:52,260 --> 03:44:55,200
a process makes a memory request using a

5601
03:44:55,200 --> 03:44:57,180
logical address in its private address

5602
03:44:57,180 --> 03:44:59,640
space as usual

5603
03:44:59,640 --> 03:45:01,979
the mmu first checks the translation

5604
03:45:01,979 --> 03:45:04,380
look aside buffer to determine if the

5605
03:45:04,380 --> 03:45:06,600
page to frame mapping is present

5606
03:45:06,600 --> 03:45:09,960
in the case of a tlb miss the mmu must

5607
03:45:09,960 --> 03:45:11,760
consult the page table to find the

5608
03:45:11,760 --> 03:45:13,080
mapping

5609
03:45:13,080 --> 03:45:15,060
once the mapping from page number to

5610
03:45:15,060 --> 03:45:17,819
frame number is known the mmu must next

5611
03:45:17,819 --> 03:45:20,220
verify that the page is actually loaded

5612
03:45:20,220 --> 03:45:21,840
in physical RAM

5613
03:45:21,840 --> 03:45:23,880
if the corresponding frame is available

5614
03:45:23,880 --> 03:45:26,460
in Ram the memory access proceeds as

5615
03:45:26,460 --> 03:45:27,479
normal

5616
03:45:27,479 --> 03:45:29,939
however if the corresponding frame is

5617
03:45:29,939 --> 03:45:32,520
not in memory the mmu generates a page

5618
03:45:32,520 --> 03:45:34,140
fault which is essentially a type of

5619
03:45:34,140 --> 03:45:35,220
interrupt

5620
03:45:35,220 --> 03:45:37,859
if generated the page fault causes the

5621
03:45:37,859 --> 03:45:40,560
operating system to switch context to

5622
03:45:40,560 --> 03:45:43,080
the page fault handling routine which

5623
03:45:43,080 --> 03:45:44,760
retrieves the corresponding memory

5624
03:45:44,760 --> 03:45:46,920
contents from the backing store

5625
03:45:46,920 --> 03:45:49,620
once this process is complete the OS

5626
03:45:49,620 --> 03:45:52,080
changes the CPU context back to the

5627
03:45:52,080 --> 03:45:54,239
original process and the memory access

5628
03:45:54,239 --> 03:45:57,319
proceeds as normal

5629
03:45:58,080 --> 03:46:00,180
in order for the mmu to be able to

5630
03:46:00,180 --> 03:46:01,859
detect situations in which your

5631
03:46:01,859 --> 03:46:03,840
requested memory frame is not physically

5632
03:46:03,840 --> 03:46:06,840
present in Ram an extra bit must be

5633
03:46:06,840 --> 03:46:08,819
added to the page table

5634
03:46:08,819 --> 03:46:11,399
this bit is set to 1 whenever the

5635
03:46:11,399 --> 03:46:13,500
contents of a logical page are present

5636
03:46:13,500 --> 03:46:15,300
in a memory frame

5637
03:46:15,300 --> 03:46:17,939
if the present bit is zero the page has

5638
03:46:17,939 --> 03:46:20,520
been swapped out to the backing store

5639
03:46:20,520 --> 03:46:23,100
for efficiency reasons the tlb entry

5640
03:46:23,100 --> 03:46:25,080
corresponding to a row in the page table

5641
03:46:25,080 --> 03:46:28,979
must also store the present bit

5642
03:46:28,979 --> 03:46:30,840
you might have noticed the terminology

5643
03:46:30,840 --> 03:46:33,359
between page and frame is starting to

5644
03:46:33,359 --> 03:46:35,340
become a bit blurry here

5645
03:46:35,340 --> 03:46:38,220
in general we refer to pages of memory

5646
03:46:38,220 --> 03:46:40,620
being swapped out to disk even though

5647
03:46:40,620 --> 03:46:43,200
the swap operation is actually moving

5648
03:46:43,200 --> 03:46:46,800
physical memory frame contents

5649
03:46:46,800 --> 03:46:49,560
this fuzzy terminology is a result of

5650
03:46:49,560 --> 03:46:51,899
historical evolution of the virtual

5651
03:46:51,899 --> 03:46:54,800
memory subsystem

5652
03:46:55,200 --> 03:46:57,180
now I'd like to take a moment to discuss

5653
03:46:57,180 --> 03:46:59,220
the nature of backing stores as

5654
03:46:59,220 --> 03:47:02,180
technology is changing in this area

5655
03:47:02,180 --> 03:47:04,560
historically the backing store was a

5656
03:47:04,560 --> 03:47:07,020
mechanical hard disk drive and a number

5657
03:47:07,020 --> 03:47:08,760
of design decisions in the virtual

5658
03:47:08,760 --> 03:47:10,620
memory subsystem still use this

5659
03:47:10,620 --> 03:47:12,300
assumption

5660
03:47:12,300 --> 03:47:15,359
however many systems now especially

5661
03:47:15,359 --> 03:47:18,359
embedded systems have only solid-state

5662
03:47:18,359 --> 03:47:19,560
storage

5663
03:47:19,560 --> 03:47:22,140
since each block on a solid-state drive

5664
03:47:22,140 --> 03:47:24,899
can be erased and written only a finite

5665
03:47:24,899 --> 03:47:27,479
number of times there is some question

5666
03:47:27,479 --> 03:47:29,520
as to whether it is a good idea to use

5667
03:47:29,520 --> 03:47:31,920
an SSD as a backing store for virtual

5668
03:47:31,920 --> 03:47:33,060
memory

5669
03:47:33,060 --> 03:47:36,239
many embedded devices do not use paging

5670
03:47:36,239 --> 03:47:38,279
for this reason

5671
03:47:38,279 --> 03:47:40,620
another issue with the backing store is

5672
03:47:40,620 --> 03:47:42,359
that it is subject to attack via

5673
03:47:42,359 --> 03:47:44,939
forensic disk analysis methods in the

5674
03:47:44,939 --> 03:47:47,760
event the device is lost or stolen

5675
03:47:47,760 --> 03:47:50,279
sensitive information such as cached

5676
03:47:50,279 --> 03:47:52,800
passwords and other credentials might

5677
03:47:52,800 --> 03:47:54,540
have been swapped out to the backing

5678
03:47:54,540 --> 03:47:56,760
store and these pieces of information

5679
03:47:56,760 --> 03:47:59,040
could be recovered

5680
03:47:59,040 --> 03:48:01,620
one solution to this problem which is

5681
03:48:01,620 --> 03:48:03,840
available as an easy to enable option in

5682
03:48:03,840 --> 03:48:07,380
Mac OS 10 is to encrypt the contents of

5683
03:48:07,380 --> 03:48:08,640
virtual memory

5684
03:48:08,640 --> 03:48:10,859
the downside to this approach is the

5685
03:48:10,859 --> 03:48:14,160
addition of CPU overhead on top of the

5686
03:48:14,160 --> 03:48:16,080
generally slow nature of the backing

5687
03:48:16,080 --> 03:48:18,680
store hardware

5688
03:48:19,200 --> 03:48:21,660
another approach to avoiding the issues

5689
03:48:21,660 --> 03:48:24,060
of right limits and post-mortem forensic

5690
03:48:24,060 --> 03:48:26,880
recovery of sensitive memory data is to

5691
03:48:26,880 --> 03:48:29,880
use the Linux compressed caching or comp

5692
03:48:29,880 --> 03:48:33,660
cache mechanism as a backing store

5693
03:48:33,660 --> 03:48:36,120
with this approach a section of RAM is

5694
03:48:36,120 --> 03:48:38,160
reserved ahead of time to create a

5695
03:48:38,160 --> 03:48:42,060
compressed Ram disk or zram disk when a

5696
03:48:42,060 --> 03:48:45,300
page is swapped out to the cram disk it

5697
03:48:45,300 --> 03:48:47,819
is compressed on the fly to fit into a

5698
03:48:47,819 --> 03:48:49,920
smaller amount of memory

5699
03:48:49,920 --> 03:48:52,319
whenever a page needs to be swapped in

5700
03:48:52,319 --> 03:48:54,960
from the backing store the page is read

5701
03:48:54,960 --> 03:48:58,500
from the xeram disk and decompressed

5702
03:48:58,500 --> 03:49:00,060
although the compression and

5703
03:49:00,060 --> 03:49:02,580
decompression steps do result in CPU

5704
03:49:02,580 --> 03:49:05,399
overhead the comp cache system is still

5705
03:49:05,399 --> 03:49:07,620
generally faster than using a disk or

5706
03:49:07,620 --> 03:49:10,319
SSD as a backing store

5707
03:49:10,319 --> 03:49:13,200
furthermore comp cache is as secure as

5708
03:49:13,200 --> 03:49:15,500
RAM against forensic analysis

5709
03:49:15,500 --> 03:49:17,640
particularly against recovering

5710
03:49:17,640 --> 03:49:20,100
sensitive information from A system that

5711
03:49:20,100 --> 03:49:21,840
has been powered off for a period of

5712
03:49:21,840 --> 03:49:23,340
time

5713
03:49:23,340 --> 03:49:25,520
in this lecture I'm going to discuss

5714
03:49:25,520 --> 03:49:28,200
object-oriented design

5715
03:49:28,200 --> 03:49:30,420
the general purpose of object-oriented

5716
03:49:30,420 --> 03:49:32,700
design is to increase the modularity of

5717
03:49:32,700 --> 03:49:34,800
software by breaking large software

5718
03:49:34,800 --> 03:49:37,500
systems into smaller pieces

5719
03:49:37,500 --> 03:49:39,300
this approach to software engineering

5720
03:49:39,300 --> 03:49:41,939
improves code maintainability by

5721
03:49:41,939 --> 03:49:43,920
separating application components from

5722
03:49:43,920 --> 03:49:45,000
each other

5723
03:49:45,000 --> 03:49:47,640
these components may also be reused in

5724
03:49:47,640 --> 03:49:50,580
other software applications

5725
03:49:50,580 --> 03:49:52,979
objects in software are modeled after

5726
03:49:52,979 --> 03:49:55,140
real-world processes

5727
03:49:55,140 --> 03:49:57,720
for example consider the process of

5728
03:49:57,720 --> 03:49:59,279
playing a song

5729
03:49:59,279 --> 03:50:01,560
in the earliest history of music playing

5730
03:50:01,560 --> 03:50:03,660
a song required assembling instruments

5731
03:50:03,660 --> 03:50:06,899
and musicians for a live performance

5732
03:50:06,899 --> 03:50:10,140
fixed recordings on wire vinyl magnetic

5733
03:50:10,140 --> 03:50:12,359
tape and Optical disk made songs

5734
03:50:12,359 --> 03:50:15,359
reproducible by a physical machine

5735
03:50:15,359 --> 03:50:17,520
with the Advent of digital music this

5736
03:50:17,520 --> 03:50:19,620
process is moved to Software

5737
03:50:19,620 --> 03:50:22,399
however the basic operations of playing

5738
03:50:22,399 --> 03:50:25,920
pausing stopping and moving around the

5739
03:50:25,920 --> 03:50:28,439
song remain the same

5740
03:50:28,439 --> 03:50:31,200
in an object-oriented design both the

5741
03:50:31,200 --> 03:50:33,300
data required to produce the sounds that

5742
03:50:33,300 --> 03:50:35,760
comprise the song and the behaviors

5743
03:50:35,760 --> 03:50:37,979
required to implement the song listening

5744
03:50:37,979 --> 03:50:40,620
process are grouped together in a

5745
03:50:40,620 --> 03:50:42,239
logical unit

5746
03:50:42,239 --> 03:50:44,760
this logical unit is what we call an

5747
03:50:44,760 --> 03:50:46,800
object in a software system

5748
03:50:46,800 --> 03:50:49,500
in this case we might call this object a

5749
03:50:49,500 --> 03:50:52,100
song player

5750
03:50:52,200 --> 03:50:55,020
a common misconception widely held among

5751
03:50:55,020 --> 03:50:57,720
students software developers and even

5752
03:50:57,720 --> 03:51:00,239
computer science professors is that an

5753
03:51:00,239 --> 03:51:02,399
object-oriented language such as C plus

5754
03:51:02,399 --> 03:51:05,160
or Java is required to implement an

5755
03:51:05,160 --> 03:51:06,779
object-oriented design

5756
03:51:06,779 --> 03:51:09,500
this is not the case

5757
03:51:09,500 --> 03:51:11,520
object-oriented designs are

5758
03:51:11,520 --> 03:51:13,080
theoretically independent of the

5759
03:51:13,080 --> 03:51:14,880
implementation language

5760
03:51:14,880 --> 03:51:17,520
a traditional procedural language such

5761
03:51:17,520 --> 03:51:20,399
as C can be used to implement an

5762
03:51:20,399 --> 03:51:22,920
object-oriented program as long as the

5763
03:51:22,920 --> 03:51:24,899
programmers are disciplined

5764
03:51:24,899 --> 03:51:27,359
of course object-oriented languages do

5765
03:51:27,359 --> 03:51:29,340
try to make the implementations of

5766
03:51:29,340 --> 03:51:31,979
object-oriented designs easier and less

5767
03:51:31,979 --> 03:51:33,000
ugly

5768
03:51:33,000 --> 03:51:35,580
that said it is possible to implement a

5769
03:51:35,580 --> 03:51:37,859
regular procedural program in an

5770
03:51:37,859 --> 03:51:40,200
object-oriented language just Implement

5771
03:51:40,200 --> 03:51:43,399
everything in one object

5772
03:51:43,859 --> 03:51:46,500
the key concept behind an object is that

5773
03:51:46,500 --> 03:51:48,720
it combines a representation of data in

5774
03:51:48,720 --> 03:51:51,560
a system along with algorithms to access

5775
03:51:51,560 --> 03:51:54,540
manipulate and perform operations on

5776
03:51:54,540 --> 03:51:57,420
that data the data are encoded in an

5777
03:51:57,420 --> 03:52:00,660
object using properties or fields in the

5778
03:52:00,660 --> 03:52:01,859
object

5779
03:52:01,859 --> 03:52:04,200
the combination of the values of these

5780
03:52:04,200 --> 03:52:06,300
properties is collectively called the

5781
03:52:06,300 --> 03:52:08,760
state of the object

5782
03:52:08,760 --> 03:52:10,979
an object's behaviors are implemented as

5783
03:52:10,979 --> 03:52:12,899
functions that are bound to the object

5784
03:52:12,899 --> 03:52:14,460
itself

5785
03:52:14,460 --> 03:52:16,800
in object-oriented terminology these

5786
03:52:16,800 --> 03:52:19,080
functions are called Methods although C

5787
03:52:19,080 --> 03:52:20,939
plus plus retains the older terminology

5788
03:52:20,939 --> 03:52:23,640
of member functions methods perform

5789
03:52:23,640 --> 03:52:26,640
operations on objects objects are

5790
03:52:26,640 --> 03:52:28,439
created in software systems by

5791
03:52:28,439 --> 03:52:30,540
instantiating classes

5792
03:52:30,540 --> 03:52:33,239
thus another definition of an object is

5793
03:52:33,239 --> 03:52:36,180
that an object is an instance of a class

5794
03:52:36,180 --> 03:52:38,460
Es are programming language structures

5795
03:52:38,460 --> 03:52:40,859
that provide templates that specify how

5796
03:52:40,859 --> 03:52:42,960
objects are to be constructed

5797
03:52:42,960 --> 03:52:45,359
these classes Define what properties and

5798
03:52:45,359 --> 03:52:47,580
behaviors an object will have once it is

5799
03:52:47,580 --> 03:52:50,180
instantiated

5800
03:52:50,279 --> 03:52:52,200
an issue with dividing a system into

5801
03:52:52,200 --> 03:52:54,239
objects is that the developers must

5802
03:52:54,239 --> 03:52:56,520
decide how data and behaviors are

5803
03:52:56,520 --> 03:52:58,560
divided among objects

5804
03:52:58,560 --> 03:53:00,720
the level at which this division occurs

5805
03:53:00,720 --> 03:53:03,120
is called granularity and there is a

5806
03:53:03,120 --> 03:53:04,800
direct relationship between higher

5807
03:53:04,800 --> 03:53:06,540
granularity and the total number of

5808
03:53:06,540 --> 03:53:08,640
objects in assistant

5809
03:53:08,640 --> 03:53:10,439
achieving the correct amount of

5810
03:53:10,439 --> 03:53:12,180
granularity in an object-oriented design

5811
03:53:12,180 --> 03:53:14,220
is a balancing act

5812
03:53:14,220 --> 03:53:16,319
at the extreme of having too much

5813
03:53:16,319 --> 03:53:18,600
granularity the system is comprised of

5814
03:53:18,600 --> 03:53:20,460
many small objects

5815
03:53:20,460 --> 03:53:22,560
this type of software project becomes

5816
03:53:22,560 --> 03:53:24,359
quite complex to develop and rather

5817
03:53:24,359 --> 03:53:26,580
difficult to maintain

5818
03:53:26,580 --> 03:53:28,739
furthermore due to the nature of the

5819
03:53:28,739 --> 03:53:30,800
underlying operations needed to create

5820
03:53:30,800 --> 03:53:34,439
manage and Destroy objects the execution

5821
03:53:34,439 --> 03:53:36,120
performance of an object-oriented

5822
03:53:36,120 --> 03:53:38,760
application will decrease as granularity

5823
03:53:38,760 --> 03:53:41,540
increases

5824
03:53:41,580 --> 03:53:43,439
at the opposite extreme is an

5825
03:53:43,439 --> 03:53:45,060
object-oriented system that is

5826
03:53:45,060 --> 03:53:47,000
essentially a procedural application

5827
03:53:47,000 --> 03:53:49,800
since all its data and behavior are

5828
03:53:49,800 --> 03:53:51,720
implemented in a small number of huge

5829
03:53:51,720 --> 03:53:54,479
objects perhaps even a single ginormous

5830
03:53:54,479 --> 03:53:56,040
object

5831
03:53:56,040 --> 03:53:58,640
this extreme has all the drawbacks of a

5832
03:53:58,640 --> 03:54:00,840
non-object-oriented system in that the

5833
03:54:00,840 --> 03:54:03,420
code is not modular is more difficult to

5834
03:54:03,420 --> 03:54:07,020
debug and is more difficult to maintain

5835
03:54:07,020 --> 03:54:09,120
notice that maintenance tends to become

5836
03:54:09,120 --> 03:54:11,520
a nightmare at either extreme

5837
03:54:11,520 --> 03:54:13,859
a good object oriented design is

5838
03:54:13,859 --> 03:54:15,479
somewhere in the middle of these two

5839
03:54:15,479 --> 03:54:18,020
extremes

5840
03:54:18,120 --> 03:54:20,220
the benefits of object-oriented design

5841
03:54:20,220 --> 03:54:22,460
are widely celebrated among different

5842
03:54:22,460 --> 03:54:24,600
object-oriented Developers

5843
03:54:24,600 --> 03:54:27,479
however no one can ever seem to agree on

5844
03:54:27,479 --> 03:54:29,520
a concise set of objectives for an

5845
03:54:29,520 --> 03:54:31,380
object-oriented assistant

5846
03:54:31,380 --> 03:54:33,180
I have followed the approach of cave

5847
03:54:33,180 --> 03:54:35,699
Horseman and Gary Cornell in providing

5848
03:54:35,699 --> 03:54:37,260
the objectives of encapsulation

5849
03:54:37,260 --> 03:54:41,040
information hiding polymorphism and

5850
03:54:41,040 --> 03:54:42,920
reuse

5851
03:54:42,920 --> 03:54:45,779
encapsulation simply means the data and

5852
03:54:45,779 --> 03:54:48,359
methods operate upon the data are stored

5853
03:54:48,359 --> 03:54:50,279
together in an object

5854
03:54:50,279 --> 03:54:52,620
these elements are accessed via

5855
03:54:52,620 --> 03:54:56,880
well-defined interfaces to the object

5856
03:54:56,880 --> 03:54:59,460
information hiding is another desirable

5857
03:54:59,460 --> 03:55:02,040
property of an object-oriented system

5858
03:55:02,040 --> 03:55:04,680
with information hiding code that uses

5859
03:55:04,680 --> 03:55:06,600
an object knows nothing about how the

5860
03:55:06,600 --> 03:55:08,760
object Works internally

5861
03:55:08,760 --> 03:55:11,279
more importantly other programmers can

5862
03:55:11,279 --> 03:55:12,960
be given an interface to an object

5863
03:55:12,960 --> 03:55:14,460
without revealing any of the

5864
03:55:14,460 --> 03:55:16,739
implementation code preventing them from

5865
03:55:16,739 --> 03:55:18,540
using shortcuts or making assumptions

5866
03:55:18,540 --> 03:55:20,399
that may later break when the object is

5867
03:55:20,399 --> 03:55:21,899
updated

5868
03:55:21,899 --> 03:55:25,439
in a sense the object is a black box it

5869
03:55:25,439 --> 03:55:27,960
has behaviors but its internal workings

5870
03:55:27,960 --> 03:55:31,640
are a mystery to Outsiders

5871
03:55:31,699 --> 03:55:33,960
object-oriented designs provide the

5872
03:55:33,960 --> 03:55:36,899
opportunity for polymorphic interfaces

5873
03:55:36,899 --> 03:55:39,359
this means that different objects can

5874
03:55:39,359 --> 03:55:42,060
expose compatible interfaces allowing

5875
03:55:42,060 --> 03:55:44,640
them to be used interchangeable

5876
03:55:44,640 --> 03:55:47,340
finally well-designed tightly

5877
03:55:47,340 --> 03:55:49,859
encapsulated objects can be reused later

5878
03:55:49,859 --> 03:55:52,260
either in the same program or in another

5879
03:55:52,260 --> 03:55:54,120
application

5880
03:55:54,120 --> 03:55:57,239
in theory over time a collection of

5881
03:55:57,239 --> 03:55:59,220
well-tested objects will provide a

5882
03:55:59,220 --> 03:56:00,960
development team with a library of

5883
03:56:00,960 --> 03:56:03,060
useful components that can speed the

5884
03:56:03,060 --> 03:56:06,500
development of new applications

5885
03:56:06,660 --> 03:56:09,000
in practice of course there is a

5886
03:56:09,000 --> 03:56:11,220
downside to any development approach an

5887
03:56:11,220 --> 03:56:12,840
object-oriented development is no

5888
03:56:12,840 --> 03:56:14,220
exception

5889
03:56:14,220 --> 03:56:16,439
developers working on object-oriented

5890
03:56:16,439 --> 03:56:18,479
systems have a tendency to run amok with

5891
03:56:18,479 --> 03:56:20,760
the design creating a terribly over

5892
03:56:20,760 --> 03:56:22,920
engineered mess of code that is

5893
03:56:22,920 --> 03:56:25,920
needlessly complex and overly granular

5894
03:56:25,920 --> 03:56:27,420
I have been guilty of this design

5895
03:56:27,420 --> 03:56:29,279
mistake myself

5896
03:56:29,279 --> 03:56:31,380
feature creep and the realization that

5897
03:56:31,380 --> 03:56:33,600
more features can be supported with just

5898
03:56:33,600 --> 03:56:37,620
a few tweaks are tempting forces

5899
03:56:37,620 --> 03:56:39,660
another issue with the theory of

5900
03:56:39,660 --> 03:56:41,939
object-oriented design is that objects

5901
03:56:41,939 --> 03:56:44,600
may be difficult to reuse in practice

5902
03:56:44,600 --> 03:56:47,880
object designs often wind up being tied

5903
03:56:47,880 --> 03:56:49,800
to the underlying business process

5904
03:56:49,800 --> 03:56:52,560
making reuse difficult in new problem

5905
03:56:52,560 --> 03:56:53,939
domains

5906
03:56:53,939 --> 03:56:56,220
of course one could argue that if the

5907
03:56:56,220 --> 03:56:57,840
objects are designed to be sufficiently

5908
03:56:57,840 --> 03:57:00,060
generic they should be more easily

5909
03:57:00,060 --> 03:57:01,319
reused

5910
03:57:01,319 --> 03:57:04,020
however making the objects too generic

5911
03:57:04,020 --> 03:57:05,640
tends to result in the first problem

5912
03:57:05,640 --> 03:57:08,880
with the designer and a muck

5913
03:57:08,880 --> 03:57:11,399
finally one major disadvantage of

5914
03:57:11,399 --> 03:57:13,560
object-oriented designs is that they are

5915
03:57:13,560 --> 03:57:15,359
slower to execute than comparable

5916
03:57:15,359 --> 03:57:17,340
procedural Solutions

5917
03:57:17,340 --> 03:57:19,319
a major cause of this performance

5918
03:57:19,319 --> 03:57:21,180
degradation is that objects are

5919
03:57:21,180 --> 03:57:23,420
dynamically allocated and deallocated

5920
03:57:23,420 --> 03:57:26,880
using heat memory in a process which is

5921
03:57:26,880 --> 03:57:29,460
a relatively slow operation

5922
03:57:29,460 --> 03:57:31,859
I once saw a software engineer complain

5923
03:57:31,859 --> 03:57:33,600
about the fact that the Linux kernel

5924
03:57:33,600 --> 03:57:36,000
uses a procedural design with go-to

5925
03:57:36,000 --> 03:57:37,739
statements in the code

5926
03:57:37,739 --> 03:57:40,500
such as design is a necessity in a

5927
03:57:40,500 --> 03:57:42,120
performance critical program like an

5928
03:57:42,120 --> 03:57:43,680
operating system kernel an

5929
03:57:43,680 --> 03:57:46,020
object-oriented design would simply be

5930
03:57:46,020 --> 03:57:48,180
too slow to execute

5931
03:57:48,180 --> 03:57:50,279
in this lecture I will discuss the

5932
03:57:50,279 --> 03:57:52,260
implementations of object-oriented

5933
03:57:52,260 --> 03:57:53,880
designs

5934
03:57:53,880 --> 03:57:56,340
by way of example I will present the

5935
03:57:56,340 --> 03:57:58,620
same object oriented design in four

5936
03:57:58,620 --> 03:58:03,239
different languages Java C plus plus C

5937
03:58:03,239 --> 03:58:06,180
and python

5938
03:58:06,180 --> 03:58:08,520
I will begin with a reminder about the

5939
03:58:08,520 --> 03:58:10,439
distinction between an object-oriented

5940
03:58:10,439 --> 03:58:13,500
design and an object-oriented language

5941
03:58:13,500 --> 03:58:15,960
it is a common misconception that an

5942
03:58:15,960 --> 03:58:18,420
object-oriented language such as C plus

5943
03:58:18,420 --> 03:58:21,479
or Java is required to implement an

5944
03:58:21,479 --> 03:58:23,460
object-oriented design

5945
03:58:23,460 --> 03:58:25,939
this is not the case

5946
03:58:25,939 --> 03:58:27,840
object-oriented designs are

5947
03:58:27,840 --> 03:58:29,279
theoretically independent of the

5948
03:58:29,279 --> 03:58:31,979
implementation language as long as the

5949
03:58:31,979 --> 03:58:33,560
programmers are disciplined

5950
03:58:33,560 --> 03:58:35,399
object-oriented designs can be

5951
03:58:35,399 --> 03:58:37,439
successfully implemented in procedural

5952
03:58:37,439 --> 03:58:39,840
languages such as C

5953
03:58:39,840 --> 03:58:41,880
the primary benefit to an

5954
03:58:41,880 --> 03:58:43,920
object-oriented language is that it

5955
03:58:43,920 --> 03:58:45,359
sometimes makes object-oriented

5956
03:58:45,359 --> 03:58:47,399
implementations easier

5957
03:58:47,399 --> 03:58:49,620
some languages are better at ease of

5958
03:58:49,620 --> 03:58:52,620
writing than are others

5959
03:58:52,620 --> 03:58:55,020
my design for this example is utterly

5960
03:58:55,020 --> 03:58:57,540
simple I have a single class which for

5961
03:58:57,540 --> 03:59:00,359
whatever reason I named forward

5962
03:59:00,359 --> 03:59:02,520
this class has a single private field

5963
03:59:02,520 --> 03:59:05,279
which is a string named message

5964
03:59:05,279 --> 03:59:07,800
the design also specifies a single

5965
03:59:07,800 --> 03:59:10,739
public method named screen when the

5966
03:59:10,739 --> 03:59:12,960
screen method is invoked the message

5967
03:59:12,960 --> 03:59:15,000
stored in the class field will be

5968
03:59:15,000 --> 03:59:17,160
printed to standard output

5969
03:59:17,160 --> 03:59:19,800
for Simplicity this message will be set

5970
03:59:19,800 --> 03:59:23,340
to hello world in the class Constructor

5971
03:59:23,340 --> 03:59:25,439
note that I have deliberately omitted

5972
03:59:25,439 --> 03:59:27,479
Constructor and Destructor methods from

5973
03:59:27,479 --> 03:59:29,760
the design since the syntax and

5974
03:59:29,760 --> 03:59:31,920
semantics of these methods are tightly

5975
03:59:31,920 --> 03:59:35,840
bound to the implementation language

5976
03:59:35,939 --> 03:59:38,340
let's begin with the Java language which

5977
03:59:38,340 --> 03:59:40,199
is a canonical example of an

5978
03:59:40,199 --> 03:59:42,720
object-oriented language

5979
03:59:42,720 --> 03:59:45,120
here I have a class named horror which

5980
03:59:45,120 --> 03:59:46,920
has a single private field of type

5981
03:59:46,920 --> 03:59:49,500
string named message

5982
03:59:49,500 --> 03:59:52,560
a public method named screen returns no

5983
03:59:52,560 --> 03:59:56,279
value since it is of the Void type

5984
03:59:56,279 --> 03:59:58,800
however it does have the side effect of

5985
03:59:58,800 --> 04:00:00,660
printing the message stored in the

5986
04:00:00,660 --> 04:00:03,300
object to standard output

5987
04:00:03,300 --> 04:00:05,460
The Constructor is the final method in

5988
04:00:05,460 --> 04:00:07,380
the class with the signature public

5989
04:00:07,380 --> 04:00:10,319
horror left brand right paren

5990
04:00:10,319 --> 04:00:12,540
this is a special method that runs

5991
04:00:12,540 --> 04:00:14,699
whenever new objects are instantiated

5992
04:00:14,699 --> 04:00:18,239
using this horror class as a template in

5993
04:00:18,239 --> 04:00:20,340
this Example The Constructor sets the

5994
04:00:20,340 --> 04:00:22,620
message for each object created from

5995
04:00:22,620 --> 04:00:26,880
this class to a value of hello world

5996
04:00:26,880 --> 04:00:30,779
I can use or reuse or objects in another

5997
04:00:30,779 --> 04:00:32,160
class

5998
04:00:32,160 --> 04:00:34,439
here I have a public class named driver

5999
04:00:34,439 --> 04:00:37,859
which has a single method named Main

6000
04:00:37,859 --> 04:00:40,140
this main method takes an array of

6001
04:00:40,140 --> 04:00:42,000
strings corresponding to any command

6002
04:00:42,000 --> 04:00:44,160
line arguments to the program

6003
04:00:44,160 --> 04:00:46,680
this main method returns no value as

6004
04:00:46,680 --> 04:00:49,260
noted by its void type

6005
04:00:49,260 --> 04:00:52,020
furthermore main is a static method in

6006
04:00:52,020 --> 04:00:54,479
Java meaning that it can be invoked by

6007
04:00:54,479 --> 04:00:56,279
itself directly from the class code

6008
04:00:56,279 --> 04:00:58,620
without having to create an instance of

6009
04:00:58,620 --> 04:01:00,120
the driver class

6010
04:01:00,120 --> 04:01:02,819
in other words main is a procedural

6011
04:01:02,819 --> 04:01:05,040
function in a language with mandatory

6012
04:01:05,040 --> 04:01:06,899
objects

6013
04:01:06,899 --> 04:01:09,899
when main executes it instantiates a new

6014
04:01:09,899 --> 04:01:12,420
instance of the horror glass creating a

6015
04:01:12,420 --> 04:01:14,399
new or object

6016
04:01:14,399 --> 04:01:17,279
after this is created main invokes the

6017
04:01:17,279 --> 04:01:20,779
screen method on the horror object H

6018
04:01:20,779 --> 04:01:23,760
which will cause a message to be printed

6019
04:01:23,760 --> 04:01:26,279
to standard output

6020
04:01:26,279 --> 04:01:28,620
another example of an object-oriented

6021
04:01:28,620 --> 04:01:30,960
language is C plus plus

6022
04:01:30,960 --> 04:01:33,120
in this first part of my C plus plus

6023
04:01:33,120 --> 04:01:34,920
implementation of the horror class

6024
04:01:34,920 --> 04:01:38,100
design I Define the class

6025
04:01:38,100 --> 04:01:40,680
since I must manage the allocation and

6026
04:01:40,680 --> 04:01:42,660
deallocation of memory for the message

6027
04:01:42,660 --> 04:01:46,140
string manually in C plus I have added

6028
04:01:46,140 --> 04:01:48,600
both Constructor and Destructor member

6029
04:01:48,600 --> 04:01:51,239
functions to the class

6030
04:01:51,239 --> 04:01:54,000
C plus plus has a few major problems in

6031
04:01:54,000 --> 04:01:56,160
terms of object support

6032
04:01:56,160 --> 04:01:58,800
first although data and member functions

6033
04:01:58,800 --> 04:02:00,840
are encapsulated together in runtime

6034
04:02:00,840 --> 04:02:03,899
object instances the implementation of

6035
04:02:03,899 --> 04:02:06,000
the member functions is not encapsulated

6036
04:02:06,000 --> 04:02:08,580
inside the class definition as it is

6037
04:02:08,580 --> 04:02:10,080
with Java

6038
04:02:10,080 --> 04:02:12,779
thus C plus plus requires the use of the

6039
04:02:12,779 --> 04:02:15,300
scope operator or the double colons

6040
04:02:15,300 --> 04:02:18,359
which I find less easy to read

6041
04:02:18,359 --> 04:02:20,760
C plus plus also introduces pointer

6042
04:02:20,760 --> 04:02:23,760
notation that is not present in Java

6043
04:02:23,760 --> 04:02:26,760
worst C plus plus class definitions

6044
04:02:26,760 --> 04:02:29,580
break information hiding by requiring

6045
04:02:29,580 --> 04:02:31,800
private members to be disclosed in the

6046
04:02:31,800 --> 04:02:33,420
class interface

6047
04:02:33,420 --> 04:02:35,520
avoiding this issue requires the

6048
04:02:35,520 --> 04:02:38,279
inconvenient use of a void typed pointer

6049
04:02:38,279 --> 04:02:41,279
to a private implementation class

6050
04:02:41,279 --> 04:02:44,520
unlike Java which is garbage collected C

6051
04:02:44,520 --> 04:02:46,680
plus plus requires the programmer to

6052
04:02:46,680 --> 04:02:49,020
return dynamically allocated heat memory

6053
04:02:49,020 --> 04:02:50,880
to the system manually

6054
04:02:50,880 --> 04:02:53,520
thus a Destructor is needed in the class

6055
04:02:53,520 --> 04:02:55,920
for this particular example

6056
04:02:55,920 --> 04:02:58,080
whenever a new instance of horror is

6057
04:02:58,080 --> 04:03:00,720
created The Constructor will allocate a

6058
04:03:00,720 --> 04:03:02,580
new string on the Heap containing the

6059
04:03:02,580 --> 04:03:04,260
message hello world

6060
04:03:04,260 --> 04:03:07,260
if I omit the destructor the memory

6061
04:03:07,260 --> 04:03:09,239
containing the string will be leaked

6062
04:03:09,239 --> 04:03:11,819
away whenever the horror instance is

6063
04:03:11,819 --> 04:03:13,380
deleted

6064
04:03:13,380 --> 04:03:16,380
to avoid this memory leak I need to add

6065
04:03:16,380 --> 04:03:18,060
a Destructor that deletes the

6066
04:03:18,060 --> 04:03:20,760
dynamically allocated string before the

6067
04:03:20,760 --> 04:03:22,979
horror instance is deleted

6068
04:03:22,979 --> 04:03:25,560
in a more complex object which might

6069
04:03:25,560 --> 04:03:27,720
dynamically allocate memory in several

6070
04:03:27,720 --> 04:03:29,640
different member functions the

6071
04:03:29,640 --> 04:03:31,800
destructor would require careful coding

6072
04:03:31,800 --> 04:03:34,500
to ensure that all utilized memory is

6073
04:03:34,500 --> 04:03:36,300
returned to the system upon object

6074
04:03:36,300 --> 04:03:38,279
deletion

6075
04:03:38,279 --> 04:03:40,640
a simple C plus driver program

6076
04:03:40,640 --> 04:03:43,260
demonstrating the use of horror objects

6077
04:03:43,260 --> 04:03:45,180
is presented here

6078
04:03:45,180 --> 04:03:47,760
first I allocate a new horror instance

6079
04:03:47,760 --> 04:03:50,580
on the Heap then I invoke the screen

6080
04:03:50,580 --> 04:03:52,800
method to print the message to standard

6081
04:03:52,800 --> 04:03:54,120
output

6082
04:03:54,120 --> 04:03:56,580
finally before I return from the main

6083
04:03:56,580 --> 04:03:59,220
function I must remember to delete the

6084
04:03:59,220 --> 04:04:01,020
instance I created

6085
04:04:01,020 --> 04:04:03,180
to be technical if I failed to call

6086
04:04:03,180 --> 04:04:05,220
delete the operating system would

6087
04:04:05,220 --> 04:04:07,500
reclaim the Lost memory for me whenever

6088
04:04:07,500 --> 04:04:09,359
the program exits

6089
04:04:09,359 --> 04:04:11,880
however Reliance on the operating system

6090
04:04:11,880 --> 04:04:14,520
to perform such a memory cleanup is

6091
04:04:14,520 --> 04:04:17,819
considered bad coding practice

6092
04:04:17,819 --> 04:04:20,040
Okay so we've seen that we can Implement

6093
04:04:20,040 --> 04:04:21,960
an object-oriented program in an

6094
04:04:21,960 --> 04:04:24,180
object-oriented language like Java or C

6095
04:04:24,180 --> 04:04:25,500
plus plus

6096
04:04:25,500 --> 04:04:27,600
but remember that I previously said that

6097
04:04:27,600 --> 04:04:29,279
we can Implement an object-oriented

6098
04:04:29,279 --> 04:04:32,580
design using a procedural language

6099
04:04:32,580 --> 04:04:35,160
in this example I implement the exact

6100
04:04:35,160 --> 04:04:38,580
same object-oriented design using C

6101
04:04:38,580 --> 04:04:40,500
it isn't pretty but it is an

6102
04:04:40,500 --> 04:04:42,479
object-oriented design

6103
04:04:42,479 --> 04:04:44,699
the first step to implementing an

6104
04:04:44,699 --> 04:04:47,580
object-oriented design in C is to find a

6105
04:04:47,580 --> 04:04:50,279
way to encapsulate the properties of or

6106
04:04:50,279 --> 04:04:53,580
data associated with an object along

6107
04:04:53,580 --> 04:04:55,380
with the methods that operate on the

6108
04:04:55,380 --> 04:04:56,580
object

6109
04:04:56,580 --> 04:04:59,399
in C we can use a struct to accomplish

6110
04:04:59,399 --> 04:05:00,660
this action

6111
04:05:00,660 --> 04:05:03,479
since C does not have true strings my

6112
04:05:03,479 --> 04:05:05,520
message will be a pointer to an array of

6113
04:05:05,520 --> 04:05:07,020
characters

6114
04:05:07,020 --> 04:05:09,239
associating the screen method with

6115
04:05:09,239 --> 04:05:10,979
horror objects requires a bit of

6116
04:05:10,979 --> 04:05:12,180
trickery

6117
04:05:12,180 --> 04:05:15,300
here I am using a c function pointer or

6118
04:05:15,300 --> 04:05:16,979
a pointer to a function in the text

6119
04:05:16,979 --> 04:05:19,680
segment of the program to allow object

6120
04:05:19,680 --> 04:05:21,779
instances to be associated with a

6121
04:05:21,779 --> 04:05:24,120
particular C function it will serve as

6122
04:05:24,120 --> 04:05:26,040
my object method

6123
04:05:26,040 --> 04:05:28,439
this function will not return any data

6124
04:05:28,439 --> 04:05:30,779
so the function pointer is given a void

6125
04:05:30,779 --> 04:05:31,859
type

6126
04:05:31,859 --> 04:05:34,260
since the C function cannot be defined

6127
04:05:34,260 --> 04:05:37,140
right here inside the struct I must pass

6128
04:05:37,140 --> 04:05:39,420
the instance of the object to the

6129
04:05:39,420 --> 04:05:41,399
function as its argument

6130
04:05:41,399 --> 04:05:43,800
thus my function will have one parameter

6131
04:05:43,800 --> 04:05:46,080
which will be a pointer to an instance

6132
04:05:46,080 --> 04:05:48,779
of struct order

6133
04:05:48,779 --> 04:05:50,939
since C is not an object-oriented

6134
04:05:50,939 --> 04:05:53,520
language it does not have a notion of a

6135
04:05:53,520 --> 04:05:54,840
Constructor

6136
04:05:54,840 --> 04:05:57,000
however I can use a factory function

6137
04:05:57,000 --> 04:05:58,439
instead

6138
04:05:58,439 --> 04:06:00,479
a factory function creates a new

6139
04:06:00,479 --> 04:06:02,580
instance of an object and returns that

6140
04:06:02,580 --> 04:06:04,080
instance

6141
04:06:04,080 --> 04:06:06,000
here I have the new horror Factory

6142
04:06:06,000 --> 04:06:08,760
function which first allocates a struct

6143
04:06:08,760 --> 04:06:10,979
horror data structure on the heat using

6144
04:06:10,979 --> 04:06:12,899
the malloc function

6145
04:06:12,899 --> 04:06:15,239
next I allocate space for the message

6146
04:06:15,239 --> 04:06:18,060
using a predefined constant to determine

6147
04:06:18,060 --> 04:06:20,340
how long the message can be

6148
04:06:20,340 --> 04:06:23,160
I then use Stir copy to copy the literal

6149
04:06:23,160 --> 04:06:25,920
string hello world into the message

6150
04:06:25,920 --> 04:06:28,680
field of the new object instance

6151
04:06:28,680 --> 04:06:31,439
finally I set the screen function

6152
04:06:31,439 --> 04:06:34,800
pointer in the new object instance to

6153
04:06:34,800 --> 04:06:36,779
the address of the horror screen

6154
04:06:36,779 --> 04:06:38,399
function

6155
04:06:38,399 --> 04:06:41,520
this step binds the function or screen

6156
04:06:41,520 --> 04:06:45,180
as the new objects screen method

6157
04:06:45,180 --> 04:06:48,060
to facilitate reclaiming the Heap memory

6158
04:06:48,060 --> 04:06:50,640
which I must do manually since C has no

6159
04:06:50,640 --> 04:06:53,160
garbage collection I have added a second

6160
04:06:53,160 --> 04:06:56,699
function named delete horror this

6161
04:06:56,699 --> 04:06:59,279
function first frees the memory used for

6162
04:06:59,279 --> 04:07:01,680
the message then it frees the memory

6163
04:07:01,680 --> 04:07:04,439
used for the horror instance itself

6164
04:07:04,439 --> 04:07:07,800
note here that order is important I must

6165
04:07:07,800 --> 04:07:11,100
free the message memory first before I

6166
04:07:11,100 --> 04:07:13,680
destroy the instance

6167
04:07:13,680 --> 04:07:17,040
to test my c-based horror code I have a

6168
04:07:17,040 --> 04:07:18,960
simple driver implemented as a main

6169
04:07:18,960 --> 04:07:20,220
function

6170
04:07:20,220 --> 04:07:22,800
my first task inside the driver is to

6171
04:07:22,800 --> 04:07:24,779
call my factory function to make a new

6172
04:07:24,779 --> 04:07:27,779
instance of Horror then I invoke the

6173
04:07:27,779 --> 04:07:29,699
screen method

6174
04:07:29,699 --> 04:07:31,680
notice that the screen method invocation

6175
04:07:31,680 --> 04:07:35,399
looks a bit strange H Arrow screen left

6176
04:07:35,399 --> 04:07:38,399
paren H right parent

6177
04:07:38,399 --> 04:07:40,680
in order for scream to have a reference

6178
04:07:40,680 --> 04:07:43,439
to the object on which to work I must

6179
04:07:43,439 --> 04:07:45,779
pass a pointer to that object as the

6180
04:07:45,779 --> 04:07:47,880
first argument to screen

6181
04:07:47,880 --> 04:07:50,160
since C is not an object-oriented

6182
04:07:50,160 --> 04:07:52,500
language it does not have the built-in

6183
04:07:52,500 --> 04:07:54,899
syntax features for automatically

6184
04:07:54,899 --> 04:07:57,300
mapping the object on the left side of

6185
04:07:57,300 --> 04:07:59,880
the arrow into the method on the right

6186
04:07:59,880 --> 04:08:01,439
side of the arrow

6187
04:08:01,439 --> 04:08:03,600
the programmer must perform this step

6188
04:08:03,600 --> 04:08:05,220
manually with an extra function

6189
04:08:05,220 --> 04:08:06,359
parameter

6190
04:08:06,359 --> 04:08:09,180
as with C plus plus I must reclaim the

6191
04:08:09,180 --> 04:08:12,120
heat memory manually using my delete or

6192
04:08:12,120 --> 04:08:13,920
function

6193
04:08:13,920 --> 04:08:16,080
if you compare the C code to the

6194
04:08:16,080 --> 04:08:18,540
previous C plus code you will notice

6195
04:08:18,540 --> 04:08:20,399
quite a few similarities in the steps

6196
04:08:20,399 --> 04:08:23,160
required to utilize the horror design

6197
04:08:23,160 --> 04:08:24,960
you might also notice that the

6198
04:08:24,960 --> 04:08:27,000
implementations are approximately the

6199
04:08:27,000 --> 04:08:28,920
same length

6200
04:08:28,920 --> 04:08:30,899
if I had to pick a favorite among

6201
04:08:30,899 --> 04:08:33,300
object-oriented languages python would

6202
04:08:33,300 --> 04:08:34,920
be the winner at least for single

6203
04:08:34,920 --> 04:08:37,439
threaded code as you can see from this

6204
04:08:37,439 --> 04:08:39,960
complete example which fits on one slide

6205
04:08:39,960 --> 04:08:42,600
the python code is exceptionally Compact

6206
04:08:42,600 --> 04:08:45,300
and relatively easy to read

6207
04:08:45,300 --> 04:08:47,819
the horror class explicitly subclasses

6208
04:08:47,819 --> 04:08:49,859
object to create a new style class

6209
04:08:49,859 --> 04:08:52,319
instead of a classic class which is a

6210
04:08:52,319 --> 04:08:54,239
python-specific issue

6211
04:08:54,239 --> 04:08:57,060
class Constructors in Python are always

6212
04:08:57,060 --> 04:09:00,239
named Double underscore init double

6213
04:09:00,239 --> 04:09:01,680
underscore

6214
04:09:01,680 --> 04:09:04,140
notice that the first formal parameter

6215
04:09:04,140 --> 04:09:06,660
to any method in a class is always self

6216
04:09:06,660 --> 04:09:08,880
which will be a reference to the current

6217
04:09:08,880 --> 04:09:10,800
class instance

6218
04:09:10,800 --> 04:09:13,620
internally python is operating much like

6219
04:09:13,620 --> 04:09:16,560
C and passing the instance as the first

6220
04:09:16,560 --> 04:09:18,540
parameter to the method

6221
04:09:18,540 --> 04:09:22,680
however unlike C python has syntactic

6222
04:09:22,680 --> 04:09:24,960
sugar for accomplishing this task

6223
04:09:24,960 --> 04:09:27,720
when I call H dot scream in the driver

6224
04:09:27,720 --> 04:09:30,660
code I do not need to pass the instance

6225
04:09:30,660 --> 04:09:32,699
to the method explicitly

6226
04:09:32,699 --> 04:09:34,560
the other item to note in this

6227
04:09:34,560 --> 04:09:36,720
implementation is the double underscore

6228
04:09:36,720 --> 04:09:39,000
before the message field name

6229
04:09:39,000 --> 04:09:41,040
these underscores are Python's

6230
04:09:41,040 --> 04:09:43,080
approximate implementation of private

6231
04:09:43,080 --> 04:09:45,300
scope which uses a technique known as

6232
04:09:45,300 --> 04:09:47,399
name mangling

6233
04:09:47,399 --> 04:09:49,859
another feature of python is that it is

6234
04:09:49,859 --> 04:09:52,080
duct typed which means that any two

6235
04:09:52,080 --> 04:09:54,180
objects that have the same interface can

6236
04:09:54,180 --> 04:09:56,100
be used interchangeably

6237
04:09:56,100 --> 04:09:58,380
furthermore since python is background

6238
04:09:58,380 --> 04:10:00,840
compiled on the fly as it is executed

6239
04:10:00,840 --> 04:10:03,420
the interfaces are not checked until

6240
04:10:03,420 --> 04:10:05,040
runtime

6241
04:10:05,040 --> 04:10:07,680
thus if I were to reuse my horror class

6242
04:10:07,680 --> 04:10:10,080
from the previous slide and add a happy

6243
04:10:10,080 --> 04:10:12,359
class with an identical interface but a

6244
04:10:12,359 --> 04:10:14,819
different message I could use horror and

6245
04:10:14,819 --> 04:10:16,920
happy interchangeably

6246
04:10:16,920 --> 04:10:19,319
in my driver code I instantiate an

6247
04:10:19,319 --> 04:10:21,600
instance of horror named H in an

6248
04:10:21,600 --> 04:10:23,580
instance of happy named I

6249
04:10:23,580 --> 04:10:26,399
I then Loop over both objects collected

6250
04:10:26,399 --> 04:10:29,460
in a tuple calling the screen method on

6251
04:10:29,460 --> 04:10:30,779
each object

6252
04:10:30,779 --> 04:10:33,420
this is an ideal example of polymorphism

6253
04:10:33,420 --> 04:10:35,699
the same code can be written to work

6254
04:10:35,699 --> 04:10:38,699
with two different types of objects

6255
04:10:38,699 --> 04:10:41,220
the duct typing used in Python means

6256
04:10:41,220 --> 04:10:43,080
that I can distribute my class in

6257
04:10:43,080 --> 04:10:46,260
compiled bytecode form along with some

6258
04:10:46,260 --> 04:10:49,080
documentation explaining the interface

6259
04:10:49,080 --> 04:10:52,080
I thus maintain information hiding

6260
04:10:52,080 --> 04:10:54,479
since both the implementation and the

6261
04:10:54,479 --> 04:10:56,540
instances are tightly encapsulated

6262
04:10:56,540 --> 04:11:00,720
python classes can be easy to reuse

6263
04:11:00,720 --> 04:11:03,840
of course nothing is free so there is a

6264
04:11:03,840 --> 04:11:06,540
downside which is that python execution

6265
04:11:06,540 --> 04:11:09,439
is slower than C in almost all cases

6266
04:11:09,439 --> 04:11:12,420
comparison to C plus plus and Java is

6267
04:11:12,420 --> 04:11:14,880
more difficult

6268
04:11:14,880 --> 04:11:16,680
finally I'd like to demonstrate

6269
04:11:16,680 --> 04:11:18,920
procedural programming in a supposedly

6270
04:11:18,920 --> 04:11:21,420
object-only language

6271
04:11:21,420 --> 04:11:23,880
Java is sometimes criticized for making

6272
04:11:23,880 --> 04:11:25,819
it impossible to design

6273
04:11:25,819 --> 04:11:28,080
non-object-oriented systems and while

6274
04:11:28,080 --> 04:11:30,660
this might technically be true it is not

6275
04:11:30,660 --> 04:11:32,640
a practical issue

6276
04:11:32,640 --> 04:11:35,160
by implementing an application using a

6277
04:11:35,160 --> 04:11:37,199
single class in which each method is

6278
04:11:37,199 --> 04:11:39,779
static I can write a procedural Java

6279
04:11:39,779 --> 04:11:40,979
program

6280
04:11:40,979 --> 04:11:43,979
here I have a static add procedure that

6281
04:11:43,979 --> 04:11:46,319
adds two integers together and returns

6282
04:11:46,319 --> 04:11:47,460
an integer

6283
04:11:47,460 --> 04:11:50,460
in my main method which incidentally is

6284
04:11:50,460 --> 04:11:53,520
always static in Java I initialize two

6285
04:11:53,520 --> 04:11:56,580
primitive integer variables X and Y

6286
04:11:56,580 --> 04:11:58,920
I then call the add function and print

6287
04:11:58,920 --> 04:12:01,560
the result the standard output

6288
04:12:01,560 --> 04:12:03,960
nowhere in this code do I ever

6289
04:12:03,960 --> 04:12:06,300
instantiate any objects with the new

6290
04:12:06,300 --> 04:12:07,500
keyword

6291
04:12:07,500 --> 04:12:10,739
the system.out object already exists and

6292
04:12:10,739 --> 04:12:12,840
is provided by the Java virtual machine

6293
04:12:12,840 --> 04:12:14,939
automatically

6294
04:12:14,939 --> 04:12:17,100
I can make Java code even more

6295
04:12:17,100 --> 04:12:19,260
procedural by removing the main method

6296
04:12:19,260 --> 04:12:21,300
and placing my code in a static

6297
04:12:21,300 --> 04:12:22,920
initializer block

6298
04:12:22,920 --> 04:12:25,439
the only catch to this implementation is

6299
04:12:25,439 --> 04:12:27,600
that I must call system.exit at the end

6300
04:12:27,600 --> 04:12:30,300
of the block otherwise the Java program

6301
04:12:30,300 --> 04:12:33,120
would print my Hello World message then

6302
04:12:33,120 --> 04:12:35,699
immediately crash with a no such method

6303
04:12:35,699 --> 04:12:38,220
error exception informing me that I have

6304
04:12:38,220 --> 04:12:39,300
no main

6305
04:12:39,300 --> 04:12:41,520
so to summarize I would like you to come

6306
04:12:41,520 --> 04:12:43,140
away from this comparative languages

6307
04:12:43,140 --> 04:12:45,180
discussion with an understanding that

6308
04:12:45,180 --> 04:12:47,760
object-oriented designs are independent

6309
04:12:47,760 --> 04:12:50,040
of the implementation language

6310
04:12:50,040 --> 04:12:52,080
you can Implement an object-oriented

6311
04:12:52,080 --> 04:12:54,720
design in a procedural language though

6312
04:12:54,720 --> 04:12:56,819
it does require a little bit of work and

6313
04:12:56,819 --> 04:12:58,500
a lot of discipline

6314
04:12:58,500 --> 04:13:00,779
you can also Implement a procedural

6315
04:13:00,779 --> 04:13:03,239
program in a mandatory object-oriented

6316
04:13:03,239 --> 04:13:05,160
language though you might need to

6317
04:13:05,160 --> 04:13:07,140
violate the spirit of the language to do

6318
04:13:07,140 --> 04:13:08,279
so

6319
04:13:08,279 --> 04:13:10,620
in this lecture I will discuss page

6320
04:13:10,620 --> 04:13:12,779
replacement as it is used in the virtual

6321
04:13:12,779 --> 04:13:14,460
memory subsystem

6322
04:13:14,460 --> 04:13:16,859
I will discuss Global and local page

6323
04:13:16,859 --> 04:13:19,560
replacement page table entries that

6324
04:13:19,560 --> 04:13:22,140
support page replacement and a number of

6325
04:13:22,140 --> 04:13:26,399
classical page replacement algorithms

6326
04:13:27,060 --> 04:13:29,220
Whenever there is a demand for memory

6327
04:13:29,220 --> 04:13:31,080
that is greater than the actual amount

6328
04:13:31,080 --> 04:13:32,939
of physical RAM installed on the system

6329
04:13:32,939 --> 04:13:35,340
the operating system must determine

6330
04:13:35,340 --> 04:13:37,800
which pages will be kept in memory and

6331
04:13:37,800 --> 04:13:40,380
which pages will be swapped out to disk

6332
04:13:40,380 --> 04:13:42,720
when memory frame contents are swapped

6333
04:13:42,720 --> 04:13:45,239
out to disk the operating system needs

6334
04:13:45,239 --> 04:13:46,979
to find a page of memory that is not

6335
04:13:46,979 --> 04:13:48,540
currently in use

6336
04:13:48,540 --> 04:13:51,060
furthermore in an ideal case the

6337
04:13:51,060 --> 04:13:53,160
operating system should also pick a page

6338
04:13:53,160 --> 04:13:55,979
that will not be used for some time so

6339
04:13:55,979 --> 04:13:57,600
as to reduce the total number of page

6340
04:13:57,600 --> 04:13:59,819
swaps

6341
04:13:59,819 --> 04:14:02,160
in order for the page swapper to operate

6342
04:14:02,160 --> 04:14:04,199
some additional data must be kept about

6343
04:14:04,199 --> 04:14:06,720
each page including whether or not the

6344
04:14:06,720 --> 04:14:08,580
page has been referenced and whether or

6345
04:14:08,580 --> 04:14:10,319
not the page has been altered since it

6346
04:14:10,319 --> 04:14:13,760
was last swapped in Durant

6347
04:14:14,760 --> 04:14:17,460
decisions regarding page swaps can be

6348
04:14:17,460 --> 04:14:19,439
made globally or locally

6349
04:14:19,439 --> 04:14:22,020
with global replacement any page in the

6350
04:14:22,020 --> 04:14:23,819
system is a potential candidate to be

6351
04:14:23,819 --> 04:14:26,279
swapped out in favor of another page

6352
04:14:26,279 --> 04:14:28,560
while simpler to implement Global page

6353
04:14:28,560 --> 04:14:30,660
replacement does allow processes to

6354
04:14:30,660 --> 04:14:33,300
steal memory frames from each other

6355
04:14:33,300 --> 04:14:35,279
on the other hand local replacement

6356
04:14:35,279 --> 04:14:37,800
policies allocate a limited number of

6357
04:14:37,800 --> 04:14:39,779
frames to each process

6358
04:14:39,779 --> 04:14:41,760
when a process exceeds its frame

6359
04:14:41,760 --> 04:14:44,699
allocation only frames belonging to that

6360
04:14:44,699 --> 04:14:48,500
process are selected for replacement

6361
04:14:49,260 --> 04:14:51,180
implementing a local page replacement

6362
04:14:51,180 --> 04:14:53,699
algorithm is more complex than it seems

6363
04:14:53,699 --> 04:14:56,399
on the surface largely due to abelities

6364
04:14:56,399 --> 04:14:57,840
anomaly

6365
04:14:57,840 --> 04:15:00,540
allocating more frames to a process does

6366
04:15:00,540 --> 04:15:02,580
not necessarily reduce the number of

6367
04:15:02,580 --> 04:15:04,620
page faults that occur as a result of

6368
04:15:04,620 --> 04:15:06,180
that process

6369
04:15:06,180 --> 04:15:08,899
in fact with some replacement algorithms

6370
04:15:08,899 --> 04:15:10,739
increasing the number of available

6371
04:15:10,739 --> 04:15:13,560
frames actually increases the number of

6372
04:15:13,560 --> 04:15:15,899
page faults that occur

6373
04:15:15,899 --> 04:15:18,600
at the opposite extreme allocation of

6374
04:15:18,600 --> 04:15:21,420
too few memory frames to a process also

6375
04:15:21,420 --> 04:15:23,939
increases the number of page faults

6376
04:15:23,939 --> 04:15:26,760
without enough physical memory processes

6377
04:15:26,760 --> 04:15:29,040
will spend more time page faulting or

6378
04:15:29,040 --> 04:15:32,220
swapping than they will spend executing

6379
04:15:32,220 --> 04:15:33,840
the goal with a local replacement

6380
04:15:33,840 --> 04:15:36,239
algorithm is to find an optimal working

6381
04:15:36,239 --> 04:15:38,460
set for each process

6382
04:15:38,460 --> 04:15:40,680
this working set is the minimum number

6383
04:15:40,680 --> 04:15:42,660
of frames that a process actually

6384
04:15:42,660 --> 04:15:45,300
requires in order to execute to some

6385
04:15:45,300 --> 04:15:48,620
desired level of efficiency

6386
04:15:48,779 --> 04:15:50,939
regardless of whether Global or local

6387
04:15:50,939 --> 04:15:53,160
replacement policies are chosen the

6388
04:15:53,160 --> 04:15:55,140
operating system needs a few pieces of

6389
04:15:55,140 --> 04:15:57,239
information to implement page swapping

6390
04:15:57,239 --> 04:15:58,800
correctly

6391
04:15:58,800 --> 04:16:01,319
first the operating system needs to know

6392
04:16:01,319 --> 04:16:03,479
whether or not a page that is currently

6393
04:16:03,479 --> 04:16:05,340
in memory has been referenced by a

6394
04:16:05,340 --> 04:16:06,779
process

6395
04:16:06,779 --> 04:16:09,479
pages that are loaded but unused might

6396
04:16:09,479 --> 04:16:11,580
be more ideal candidates to be swapped

6397
04:16:11,580 --> 04:16:14,040
out to the backing store

6398
04:16:14,040 --> 04:16:15,960
the second piece of information that

6399
04:16:15,960 --> 04:16:17,760
needs to be stored in the page table is

6400
04:16:17,760 --> 04:16:19,260
the Dirty Bit

6401
04:16:19,260 --> 04:16:21,840
this bit is set to one whenever a

6402
04:16:21,840 --> 04:16:24,540
process writes to a page which lets the

6403
04:16:24,540 --> 04:16:26,580
operating system know that the copy of

6404
04:16:26,580 --> 04:16:28,859
the memory frame contents on the backing

6405
04:16:28,859 --> 04:16:31,380
store needs to be updated whenever the

6406
04:16:31,380 --> 04:16:33,359
page is swapped out

6407
04:16:33,359 --> 04:16:35,399
keep in mind that on systems with

6408
04:16:35,399 --> 04:16:38,100
Hardware managed page tables such as the

6409
04:16:38,100 --> 04:16:42,420
x86 and x8664 platforms the mmu updates

6410
04:16:42,420 --> 04:16:44,880
these bits automatically

6411
04:16:44,880 --> 04:16:47,340
whenever a page fault occurs the

6412
04:16:47,340 --> 04:16:49,739
operating system must locate the desired

6413
04:16:49,739 --> 04:16:52,199
page on the backing store then it must

6414
04:16:52,199 --> 04:16:54,479
find a free frame and RAM into which the

6415
04:16:54,479 --> 04:16:55,979
page can be loaded

6416
04:16:55,979 --> 04:16:58,260
if no memory frames are free the

6417
04:16:58,260 --> 04:16:59,939
operating system must select a victim

6418
04:16:59,939 --> 04:17:01,859
frame to be swapped out to the backing

6419
04:17:01,859 --> 04:17:03,779
store

6420
04:17:03,779 --> 04:17:05,819
the algorithm that is run to determine

6421
04:17:05,819 --> 04:17:07,680
which frame will be the victim is called

6422
04:17:07,680 --> 04:17:10,140
the page replacement algorithm

6423
04:17:10,140 --> 04:17:12,239
page replacement algorithms ideally

6424
04:17:12,239 --> 04:17:14,279
should minimize the total number of page

6425
04:17:14,279 --> 04:17:16,680
faults in the running system in order to

6426
04:17:16,680 --> 04:17:18,960
maximize system performance

6427
04:17:18,960 --> 04:17:20,939
let's take a look at several plastic

6428
04:17:20,939 --> 04:17:24,500
page replacement algorithms

6429
04:17:24,840 --> 04:17:26,699
the first classical page replacement

6430
04:17:26,699 --> 04:17:29,399
algorithm we will consider is the random

6431
04:17:29,399 --> 04:17:30,720
algorithm

6432
04:17:30,720 --> 04:17:33,239
whenever a page swap is required this

6433
04:17:33,239 --> 04:17:35,399
algorithm simply picks a victim frame at

6434
04:17:35,399 --> 04:17:36,540
random

6435
04:17:36,540 --> 04:17:39,239
in practice this random selection often

6436
04:17:39,239 --> 04:17:41,100
picks a page that will be needed in the

6437
04:17:41,100 --> 04:17:43,380
near future leading to another page

6438
04:17:43,380 --> 04:17:45,479
fault in a short time period

6439
04:17:45,479 --> 04:17:47,699
as such it is not effective for

6440
04:17:47,699 --> 04:17:50,160
minimizing page faults

6441
04:17:50,160 --> 04:17:52,500
another ineffective algorithm is to

6442
04:17:52,500 --> 04:17:55,080
select the oldest page or the page that

6443
04:17:55,080 --> 04:17:56,640
has been in memory for the longest

6444
04:17:56,640 --> 04:17:58,160
period of time

6445
04:17:58,160 --> 04:18:00,420
unfortunately this page could be

6446
04:18:00,420 --> 04:18:03,060
frequently accessed so if it is swapped

6447
04:18:03,060 --> 04:18:05,220
out another page fault could be

6448
04:18:05,220 --> 04:18:07,260
triggered in a short period of time to

6449
04:18:07,260 --> 04:18:09,840
bring it back into memory

6450
04:18:09,840 --> 04:18:12,180
somewhat counter-intuitively selecting

6451
04:18:12,180 --> 04:18:13,800
the frame that has been accessed the

6452
04:18:13,800 --> 04:18:16,680
least frequently is also ineffective

6453
04:18:16,680 --> 04:18:18,540
a page that is used relatively

6454
04:18:18,540 --> 04:18:20,520
infrequently might still be used

6455
04:18:20,520 --> 04:18:22,979
regularly which would lead to another

6456
04:18:22,979 --> 04:18:25,199
page fault to bring this frame back into

6457
04:18:25,199 --> 04:18:27,500
RAM

6458
04:18:27,720 --> 04:18:30,540
the most frequently used algorithm picks

6459
04:18:30,540 --> 04:18:32,460
whichever frame is being used the most

6460
04:18:32,460 --> 04:18:34,979
and selects that frame to be swapped out

6461
04:18:34,979 --> 04:18:36,600
to the backing store

6462
04:18:36,600 --> 04:18:39,359
this is a completely stupid idea since

6463
04:18:39,359 --> 04:18:41,640
this page is likely to be accessed again

6464
04:18:41,640 --> 04:18:44,760
shortly after it is swapped out

6465
04:18:44,760 --> 04:18:46,800
a good algorithm for choosing victim

6466
04:18:46,800 --> 04:18:49,800
frames is the least recently used or lru

6467
04:18:49,800 --> 04:18:52,800
algorithm this algorithm selects the

6468
04:18:52,800 --> 04:18:55,140
victim frame that has not been accessed

6469
04:18:55,140 --> 04:18:57,739
for the longest period of time

6470
04:18:57,739 --> 04:18:59,880
unfortunately with current Hardware

6471
04:18:59,880 --> 04:19:02,399
there is no good way to track the last

6472
04:19:02,399 --> 04:19:04,199
memory access time

6473
04:19:04,199 --> 04:19:06,600
tracking every access and software would

6474
04:19:06,600 --> 04:19:09,239
be a terrible idea since such a scheme

6475
04:19:09,239 --> 04:19:11,100
would require an interrupt on every

6476
04:19:11,100 --> 04:19:12,899
memory access

6477
04:19:12,899 --> 04:19:16,140
thus it is Impractical to implement lru

6478
04:19:16,140 --> 04:19:17,220
directly

6479
04:19:17,220 --> 04:19:19,380
most implemented page placement

6480
04:19:19,380 --> 04:19:21,840
algorithms are approximations of lru

6481
04:19:21,840 --> 04:19:24,319
however

6482
04:19:24,660 --> 04:19:27,600
theoretically the optimal algorithm or

6483
04:19:27,600 --> 04:19:29,340
opt is the best Stage replacement

6484
04:19:29,340 --> 04:19:31,979
algorithm to use

6485
04:19:31,979 --> 04:19:34,380
with this algorithm the operating system

6486
04:19:34,380 --> 04:19:36,660
picks a frame that will not be accessed

6487
04:19:36,660 --> 04:19:38,819
for the longest period of time as the

6488
04:19:38,819 --> 04:19:41,580
victim delaying a future page fault

6489
04:19:41,580 --> 04:19:44,040
related to the corresponding page for as

6490
04:19:44,040 --> 04:19:45,779
long as possible

6491
04:19:45,779 --> 04:19:48,540
a mathematical proof exists showing that

6492
04:19:48,540 --> 04:19:50,279
opt is the best possible page

6493
04:19:50,279 --> 04:19:52,220
replacement algorithm

6494
04:19:52,220 --> 04:19:55,319
unfortunately opt is also impossible to

6495
04:19:55,319 --> 04:19:57,420
implement since it must be able to

6496
04:19:57,420 --> 04:19:59,640
predict all memory accesses ahead of

6497
04:19:59,640 --> 04:20:01,020
time

6498
04:20:01,020 --> 04:20:03,359
as such we are left with lru

6499
04:20:03,359 --> 04:20:06,120
approximation algorithms such as the not

6500
04:20:06,120 --> 04:20:09,120
used recently or in Ur algorithm

6501
04:20:09,120 --> 04:20:12,000
Nur tracks frame accesses using a

6502
04:20:12,000 --> 04:20:14,580
combination of the reference bit Dirty

6503
04:20:14,580 --> 04:20:17,580
Bit And or an age counter this algorithm

6504
04:20:17,580 --> 04:20:19,680
produces reasonable performance in

6505
04:20:19,680 --> 04:20:21,660
actual implementations

6506
04:20:21,660 --> 04:20:23,880
in this lecture which is presented in

6507
04:20:23,880 --> 04:20:25,920
two parts I will begin discussing

6508
04:20:25,920 --> 04:20:28,260
processes

6509
04:20:28,260 --> 04:20:30,439
I will introduce the process model

6510
04:20:30,439 --> 04:20:32,279
discuss the type of information

6511
04:20:32,279 --> 04:20:34,560
associated with the process

6512
04:20:34,560 --> 04:20:37,500
give an overview of process State and

6513
04:20:37,500 --> 04:20:40,560
introduce the concept of process forking

6514
04:20:40,560 --> 04:20:43,020
as is usually the case my presentation

6515
04:20:43,020 --> 04:20:47,359
is focused on unix-like systems

6516
04:20:47,939 --> 04:20:50,100
let's begin by defining what a process

6517
04:20:50,100 --> 04:20:51,479
is

6518
04:20:51,479 --> 04:20:53,640
a process is an instance of a computer

6519
04:20:53,640 --> 04:20:56,040
program in execution

6520
04:20:56,040 --> 04:20:58,560
when we ask computer system to run a

6521
04:20:58,560 --> 04:21:01,140
program the code for that program is

6522
04:21:01,140 --> 04:21:03,180
loaded from disk into memory and

6523
04:21:03,180 --> 04:21:06,180
executed as a process in the system

6524
04:21:06,180 --> 04:21:08,819
on some platforms processes might be

6525
04:21:08,819 --> 04:21:11,939
called jobs or tasks

6526
04:21:11,939 --> 04:21:14,640
on a modern system a process consists of

6527
04:21:14,640 --> 04:21:17,340
one or more threads of execution

6528
04:21:17,340 --> 04:21:19,859
in other words a process can execute one

6529
04:21:19,859 --> 04:21:22,500
instruction at a time or it can execute

6530
04:21:22,500 --> 04:21:25,260
several instructions at the same time on

6531
04:21:25,260 --> 04:21:27,239
the CPU

6532
04:21:27,239 --> 04:21:29,819
each process on the system receives its

6533
04:21:29,819 --> 04:21:32,220
own private allocation of resources

6534
04:21:32,220 --> 04:21:34,979
each process also has access to its own

6535
04:21:34,979 --> 04:21:37,439
data and the operating system maintains

6536
04:21:37,439 --> 04:21:39,660
statistics about each process in order

6537
04:21:39,660 --> 04:21:43,260
to make effective scheduling decisions

6538
04:21:43,260 --> 04:21:44,899
foreign

6539
04:21:44,899 --> 04:21:48,180
a process is divided into segments

6540
04:21:48,180 --> 04:21:50,939
program code and other read-only data

6541
04:21:50,939 --> 04:21:53,460
are placed into the text segment

6542
04:21:53,460 --> 04:21:55,560
Global variables in a program have their

6543
04:21:55,560 --> 04:21:57,180
own data segment that allows both

6544
04:21:57,180 --> 04:21:59,399
reading and writing

6545
04:21:59,399 --> 04:22:02,040
automatic variables or local variables

6546
04:22:02,040 --> 04:22:04,500
and functions are allocated at compile

6547
04:22:04,500 --> 04:22:06,779
time and placed on the stack

6548
04:22:06,779 --> 04:22:09,180
data structures explicitly allocated at

6549
04:22:09,180 --> 04:22:11,580
runtime are placed on the heat

6550
04:22:11,580 --> 04:22:14,399
as memory is used by a process the stack

6551
04:22:14,399 --> 04:22:16,439
and the Heap grow toward each other

6552
04:22:16,439 --> 04:22:18,300
if a process makes use of shared

6553
04:22:18,300 --> 04:22:20,640
libraries these libraries are mapped

6554
04:22:20,640 --> 04:22:22,500
into process memory between the stack

6555
04:22:22,500 --> 04:22:25,040
and the Heat

6556
04:22:25,560 --> 04:22:27,779
in order to track processes correctly

6557
04:22:27,779 --> 04:22:30,060
and allow multiple processes to share

6558
04:22:30,060 --> 04:22:32,399
the same system the operating system

6559
04:22:32,399 --> 04:22:34,199
must track some information that is

6560
04:22:34,199 --> 04:22:36,479
associated with each process

6561
04:22:36,479 --> 04:22:38,340
this information includes the memory

6562
04:22:38,340 --> 04:22:40,859
that the process is using as well as the

6563
04:22:40,859 --> 04:22:42,720
current location and the process code

6564
04:22:42,720 --> 04:22:44,880
that is executing known as the process

6565
04:22:44,880 --> 04:22:46,739
program counter

6566
04:22:46,739 --> 04:22:48,779
the operating system must also track

6567
04:22:48,779 --> 04:22:51,319
other resources in use by a process

6568
04:22:51,319 --> 04:22:53,760
including which files are currently open

6569
04:22:53,760 --> 04:22:56,100
in any network connections the process

6570
04:22:56,100 --> 04:22:58,760
is using

6571
04:22:59,340 --> 04:23:01,500
in addition to the information generated

6572
04:23:01,500 --> 04:23:03,779
by the process itself the operating

6573
04:23:03,779 --> 04:23:05,460
system must keep scheduling information

6574
04:23:05,460 --> 04:23:08,100
and statistics about each process

6575
04:23:08,100 --> 04:23:09,960
this information includes a unique

6576
04:23:09,960 --> 04:23:13,199
identifier or process ID it can be used

6577
04:23:13,199 --> 04:23:15,840
to distinguish processes from each other

6578
04:23:15,840 --> 04:23:18,060
in order to arbitrate access to system

6579
04:23:18,060 --> 04:23:20,939
resources the operating system must also

6580
04:23:20,939 --> 04:23:22,800
store information about the owner of a

6581
04:23:22,800 --> 04:23:24,899
process so that permissions can be

6582
04:23:24,899 --> 04:23:26,640
enforced correctly

6583
04:23:26,640 --> 04:23:29,160
to facilitate scheduling decisions the

6584
04:23:29,160 --> 04:23:30,899
operating system collects various

6585
04:23:30,899 --> 04:23:33,479
statistics about process execution such

6586
04:23:33,479 --> 04:23:35,760
as the amount of CPU time consumed and

6587
04:23:35,760 --> 04:23:38,720
the amount of memory used

6588
04:23:38,819 --> 04:23:41,100
during the lifetime of a process the

6589
04:23:41,100 --> 04:23:43,739
process moves between several States

6590
04:23:43,739 --> 04:23:45,960
when a process is first created it is

6591
04:23:45,960 --> 04:23:47,819
initially in the new state

6592
04:23:47,819 --> 04:23:49,800
once creation is complete and the

6593
04:23:49,800 --> 04:23:52,140
process is ready to run it transitions

6594
04:23:52,140 --> 04:23:54,000
to the ready state where it waits to be

6595
04:23:54,000 --> 04:23:56,399
assigned to a CPU or

6596
04:23:56,399 --> 04:23:58,319
when the scheduler selects a ready

6597
04:23:58,319 --> 04:24:00,779
process to run that process is moved to

6598
04:24:00,779 --> 04:24:02,640
the running State and is given CPU

6599
04:24:02,640 --> 04:24:03,960
resources

6600
04:24:03,960 --> 04:24:06,600
during execution a process might request

6601
04:24:06,600 --> 04:24:09,960
external resources such as Disgaea

6602
04:24:09,960 --> 04:24:12,060
since these resources take time to

6603
04:24:12,060 --> 04:24:14,279
provide the process is moved out of the

6604
04:24:14,279 --> 04:24:16,020
running State and into the waiting state

6605
04:24:16,020 --> 04:24:18,420
so that the CPU core can be given to

6606
04:24:18,420 --> 04:24:20,460
another process

6607
04:24:20,460 --> 04:24:23,040
finally when a process is finished it is

6608
04:24:23,040 --> 04:24:25,140
placed in the terminated state so that

6609
04:24:25,140 --> 04:24:27,060
the operating system can perform cleanup

6610
04:24:27,060 --> 04:24:28,920
tasks before destroying the process

6611
04:24:28,920 --> 04:24:32,000
instance completely

6612
04:24:32,760 --> 04:24:35,399
in this diagram we can see how processes

6613
04:24:35,399 --> 04:24:37,800
May transition between states

6614
04:24:37,800 --> 04:24:40,560
at creation time a process is placed

6615
04:24:40,560 --> 04:24:42,359
into the new state while the operating

6616
04:24:42,359 --> 04:24:44,279
system allocates initial memory and

6617
04:24:44,279 --> 04:24:46,080
other resources

6618
04:24:46,080 --> 04:24:48,840
once creation is complete the process is

6619
04:24:48,840 --> 04:24:50,520
submitted to the system and placed in

6620
04:24:50,520 --> 04:24:52,020
the ready state

6621
04:24:52,020 --> 04:24:54,359
whenever a CPU core is available to

6622
04:24:54,359 --> 04:24:56,520
execute a process it is dispatched to

6623
04:24:56,520 --> 04:24:59,580
the running state where it executes

6624
04:24:59,580 --> 04:25:01,620
execution of a process can be

6625
04:25:01,620 --> 04:25:04,199
interrupted for a variety of reasons

6626
04:25:04,199 --> 04:25:06,420
if a hardware interrupt occurs the

6627
04:25:06,420 --> 04:25:07,979
operating system might have to move the

6628
04:25:07,979 --> 04:25:10,560
process off the CPU core in order to

6629
04:25:10,560 --> 04:25:12,600
service the interrupt returning the

6630
04:25:12,600 --> 04:25:14,819
process to the ready state

6631
04:25:14,819 --> 04:25:17,819
or the process might make an i o request

6632
04:25:17,819 --> 04:25:20,160
in which case the process is moved to

6633
04:25:20,160 --> 04:25:22,020
the waiting State while the system Waits

6634
04:25:22,020 --> 04:25:24,420
on the relatively slow i o device to

6635
04:25:24,420 --> 04:25:26,699
provide the requested data

6636
04:25:26,699 --> 04:25:29,279
once I O is complete the process is

6637
04:25:29,279 --> 04:25:31,199
moved back to the ready state so that it

6638
04:25:31,199 --> 04:25:33,239
can be scheduled to run again whenever a

6639
04:25:33,239 --> 04:25:36,060
CPU core becomes free

6640
04:25:36,060 --> 04:25:38,880
upon exiting the process is moved to the

6641
04:25:38,880 --> 04:25:42,380
terminated state for cleanup

6642
04:25:42,899 --> 04:25:45,540
the mechanism for process creation is

6643
04:25:45,540 --> 04:25:47,399
platform dependent

6644
04:25:47,399 --> 04:25:49,620
I will be introducing process creation

6645
04:25:49,620 --> 04:25:52,380
on a unix-like platform such as Linux or

6646
04:25:52,380 --> 04:25:54,120
Mac OS 10.

6647
04:25:54,120 --> 04:25:57,120
on these platforms all processes descend

6648
04:25:57,120 --> 04:25:59,279
from a single parent process that is

6649
04:25:59,279 --> 04:26:02,640
created by the kernel at Bhutan

6650
04:26:02,640 --> 04:26:05,220
on Linux this first process is called

6651
04:26:05,220 --> 04:26:07,620
init which is the common Unix name for

6652
04:26:07,620 --> 04:26:09,659
the first created process

6653
04:26:09,659 --> 04:26:11,640
Apple decided to call this process

6654
04:26:11,640 --> 04:26:15,000
launch D on Mac OS 10.

6655
04:26:15,000 --> 04:26:17,580
by convention the initial process always

6656
04:26:17,580 --> 04:26:20,640
has a process ID of 1. the initial

6657
04:26:20,640 --> 04:26:23,100
process must also remain alive for the

6658
04:26:23,100 --> 04:26:25,040
entire time the system is up and running

6659
04:26:25,040 --> 04:26:27,359
otherwise the whole computer crashes

6660
04:26:27,359 --> 04:26:29,520
with the kernel panic

6661
04:26:29,520 --> 04:26:31,800
the init or launch date process is

6662
04:26:31,800 --> 04:26:34,620
started by the kernel at boot time every

6663
04:26:34,620 --> 04:26:36,720
other process on the system is a child

6664
04:26:36,720 --> 04:26:40,020
of this special process

6665
04:26:40,020 --> 04:26:42,960
child processes on Unix are created by

6666
04:26:42,960 --> 04:26:45,000
forking a parent process

6667
04:26:45,000 --> 04:26:47,399
the parent process makes a system call

6668
04:26:47,399 --> 04:26:49,739
named Fork which makes a copy of the

6669
04:26:49,739 --> 04:26:51,120
parent process

6670
04:26:51,120 --> 04:26:53,760
this copy which is initially a clone of

6671
04:26:53,760 --> 04:26:57,000
the parent is called the child process

6672
04:26:57,000 --> 04:26:59,279
it is up to the parent process to

6673
04:26:59,279 --> 04:27:02,040
determine what if any resources it will

6674
04:27:02,040 --> 04:27:04,080
share with the child process

6675
04:27:04,080 --> 04:27:06,779
by default the parent process shares any

6676
04:27:06,779 --> 04:27:08,699
open file descriptors network

6677
04:27:08,699 --> 04:27:10,979
connections and other resources apart

6678
04:27:10,979 --> 04:27:14,159
from the CPU and memory with the child

6679
04:27:14,159 --> 04:27:17,100
however the program code can close or

6680
04:27:17,100 --> 04:27:19,620
reassign resources in the child making

6681
04:27:19,620 --> 04:27:21,540
the child completely independent of the

6682
04:27:21,540 --> 04:27:23,720
parent

6683
04:27:23,880 --> 04:27:26,340
once a child process is forked the child

6684
04:27:26,340 --> 04:27:28,380
becomes an independent instance of the

6685
04:27:28,380 --> 04:27:30,479
program which can be scheduled to run in

6686
04:27:30,479 --> 04:27:32,460
parallel with the parent

6687
04:27:32,460 --> 04:27:35,100
however the parent process can be coded

6688
04:27:35,100 --> 04:27:37,080
to wait on the child process to finish

6689
04:27:37,080 --> 04:27:40,080
executing before the parent proceeds

6690
04:27:40,080 --> 04:27:42,180
furthermore the parent process is able

6691
04:27:42,180 --> 04:27:44,220
to terminate the child process at any

6692
04:27:44,220 --> 04:27:45,720
time

6693
04:27:45,720 --> 04:27:47,939
on some systems termination of the

6694
04:27:47,939 --> 04:27:49,979
parent process will terminate all child

6695
04:27:49,979 --> 04:27:52,140
processes automatically

6696
04:27:52,140 --> 04:27:54,899
on other systems child processes become

6697
04:27:54,899 --> 04:27:57,000
orphan processes whenever the parent

6698
04:27:57,000 --> 04:27:58,439
terminates

6699
04:27:58,439 --> 04:28:01,260
unix-like systems including Linux have

6700
04:28:01,260 --> 04:28:04,380
the ability to support both models

6701
04:28:04,380 --> 04:28:07,080
any process including a child process

6702
04:28:07,080 --> 04:28:09,000
has the ability to load a different

6703
04:28:09,000 --> 04:28:11,580
program into its memory space

6704
04:28:11,580 --> 04:28:13,739
this loading is accomplished via the

6705
04:28:13,739 --> 04:28:16,380
exact system call which replaces the

6706
04:28:16,380 --> 04:28:18,840
entire program code of the process with

6707
04:28:18,840 --> 04:28:20,220
the program code from a different

6708
04:28:20,220 --> 04:28:21,600
program

6709
04:28:21,600 --> 04:28:24,120
new programs on unix-like systems are

6710
04:28:24,120 --> 04:28:25,979
started by forking an existing program

6711
04:28:25,979 --> 04:28:28,620
then executing the new program in the

6712
04:28:28,620 --> 04:28:31,279
child process

6713
04:28:32,220 --> 04:28:34,620
when multiple processes are executing on

6714
04:28:34,620 --> 04:28:36,659
the same system they have the ability to

6715
04:28:36,659 --> 04:28:38,340
execute independently or share

6716
04:28:38,340 --> 04:28:40,500
information between themselves

6717
04:28:40,500 --> 04:28:42,659
an independent process is completely

6718
04:28:42,659 --> 04:28:44,520
separate from other processes in the

6719
04:28:44,520 --> 04:28:47,279
system its execution is not affected by

6720
04:28:47,279 --> 04:28:49,739
other processes and it cannot affect

6721
04:28:49,739 --> 04:28:52,140
other processes as long as the operating

6722
04:28:52,140 --> 04:28:53,699
system is designed and implemented

6723
04:28:53,699 --> 04:28:55,460
correctly

6724
04:28:55,460 --> 04:28:57,899
alternatively processes could share

6725
04:28:57,899 --> 04:28:59,819
information between themselves and

6726
04:28:59,819 --> 04:29:01,380
thereby affect each other

6727
04:29:01,380 --> 04:29:03,239
when this occurs we say that the

6728
04:29:03,239 --> 04:29:05,340
processes are cooperating

6729
04:29:05,340 --> 04:29:07,859
cooperating processes may be used for a

6730
04:29:07,859 --> 04:29:10,020
variety of reasons including information

6731
04:29:10,020 --> 04:29:12,600
sharing implementing high performance

6732
04:29:12,600 --> 04:29:14,340
parallel computation

6733
04:29:14,340 --> 04:29:16,439
increasing the modularity of a program

6734
04:29:16,439 --> 04:29:19,080
implementation or simply for convenience

6735
04:29:19,080 --> 04:29:22,199
when implementing certain designs

6736
04:29:22,199 --> 04:29:24,120
in part two of this lecture I will

6737
04:29:24,120 --> 04:29:26,220
provide additional detail about process

6738
04:29:26,220 --> 04:29:29,100
forking and executing new programs

6739
04:29:29,100 --> 04:29:31,380
in this lecture I will discuss Process

6740
04:29:31,380 --> 04:29:32,819
Management

6741
04:29:32,819 --> 04:29:35,880
I will discuss process contexts context

6742
04:29:35,880 --> 04:29:40,279
switches and process scheduling

6743
04:29:40,680 --> 04:29:43,020
each process running on a system has a

6744
04:29:43,020 --> 04:29:44,880
certain amount of information associated

6745
04:29:44,880 --> 04:29:46,199
with it

6746
04:29:46,199 --> 04:29:48,479
a minimal set of State information that

6747
04:29:48,479 --> 04:29:50,580
allows a process to be stopped and later

6748
04:29:50,580 --> 04:29:54,540
restarted is called process contexts

6749
04:29:54,540 --> 04:29:56,760
process context includes the correct

6750
04:29:56,760 --> 04:29:59,760
contents of CPU registers the current

6751
04:29:59,760 --> 04:30:01,760
program counter value for the process

6752
04:30:01,760 --> 04:30:04,800
and the contents of ram the process is

6753
04:30:04,800 --> 04:30:07,220
using

6754
04:30:08,340 --> 04:30:10,680
switching between processes on a system

6755
04:30:10,680 --> 04:30:12,800
is often called a context switch

6756
04:30:12,800 --> 04:30:15,359
although process switch is a more

6757
04:30:15,359 --> 04:30:17,520
precise term

6758
04:30:17,520 --> 04:30:19,800
the operating system can perform a

6759
04:30:19,800 --> 04:30:22,979
context switch from a process into a

6760
04:30:22,979 --> 04:30:25,260
section of the kernel and then back to

6761
04:30:25,260 --> 04:30:27,779
the same process without actually

6762
04:30:27,779 --> 04:30:30,540
performing a process switch

6763
04:30:30,540 --> 04:30:33,060
context switches require at least one

6764
04:30:33,060 --> 04:30:36,120
mode switch to perform since the CPU

6765
04:30:36,120 --> 04:30:38,340
must enter supervisor mode to enter the

6766
04:30:38,340 --> 04:30:39,840
kernel

6767
04:30:39,840 --> 04:30:43,199
relatively speaking context switches are

6768
04:30:43,199 --> 04:30:45,720
a fairly expensive operation and

6769
04:30:45,720 --> 04:30:47,939
frequent context switching will reduce

6770
04:30:47,939 --> 04:30:51,120
system performance

6771
04:30:51,120 --> 04:30:53,340
whenever the operating system needs to

6772
04:30:53,340 --> 04:30:55,800
switch from one process to another it

6773
04:30:55,800 --> 04:30:57,960
must first make a context switch into

6774
04:30:57,960 --> 04:30:59,460
the kernel

6775
04:30:59,460 --> 04:31:01,859
the kernel then saves the state of the

6776
04:31:01,859 --> 04:31:04,500
previously running process and restores

6777
04:31:04,500 --> 04:31:06,180
the state of the process to which it is

6778
04:31:06,180 --> 04:31:07,500
switching

6779
04:31:07,500 --> 04:31:10,140
a second context switch is then required

6780
04:31:10,140 --> 04:31:14,120
to start the newly restored process

6781
04:31:14,819 --> 04:31:17,699
on Unix systems processes are created

6782
04:31:17,699 --> 04:31:20,399
via the fork system call

6783
04:31:20,399 --> 04:31:23,279
following creation the CPU scheduler

6784
04:31:23,279 --> 04:31:25,380
determines when and where the process

6785
04:31:25,380 --> 04:31:27,120
will be run

6786
04:31:27,120 --> 04:31:29,880
once the CPU core is selected the

6787
04:31:29,880 --> 04:31:33,500
dispatcher starts the process

6788
04:31:34,080 --> 04:31:36,899
whenever a process makes an i o request

6789
04:31:36,899 --> 04:31:39,479
a system call into the kernel is made

6790
04:31:39,479 --> 04:31:42,120
which removes the process from execution

6791
04:31:42,120 --> 04:31:45,180
while waiting for the i o to complete

6792
04:31:45,180 --> 04:31:48,060
the process yields any CPU cores it is

6793
04:31:48,060 --> 04:31:49,439
currently using

6794
04:31:49,439 --> 04:31:51,779
so that another process can use those

6795
04:31:51,779 --> 04:31:54,420
resources while the first process Waits

6796
04:31:54,420 --> 04:31:58,080
on the relatively slow i o device

6797
04:31:58,080 --> 04:32:00,479
operations that cause the process to

6798
04:32:00,479 --> 04:32:02,760
yield the CPU cores and wait for some

6799
04:32:02,760 --> 04:32:05,220
external event to occur are called

6800
04:32:05,220 --> 04:32:07,620
blocking operations

6801
04:32:07,620 --> 04:32:10,260
reading data from a file is an example

6802
04:32:10,260 --> 04:32:11,939
of such an operation

6803
04:32:11,939 --> 04:32:14,760
the process calls the read function and

6804
04:32:14,760 --> 04:32:16,560
the read function does not return until

6805
04:32:16,560 --> 04:32:18,779
it is read some data

6806
04:32:18,779 --> 04:32:20,819
the process may have been moved off the

6807
04:32:20,819 --> 04:32:23,699
CPU and then restored and returned to

6808
04:32:23,699 --> 04:32:26,159
the CPU while waiting for the read

6809
04:32:26,159 --> 04:32:29,060
function to return

6810
04:32:30,899 --> 04:32:34,439
some processes are CPU bound which means

6811
04:32:34,439 --> 04:32:37,020
they perform large computations with few

6812
04:32:37,020 --> 04:32:39,120
i o requests or other blocking

6813
04:32:39,120 --> 04:32:40,859
operations

6814
04:32:40,859 --> 04:32:43,140
in order to enable the system to service

6815
04:32:43,140 --> 04:32:45,720
other processes and effectively

6816
04:32:45,720 --> 04:32:47,699
implement multi-programming

6817
04:32:47,699 --> 04:32:50,520
CPU scheduler must preempt these types

6818
04:32:50,520 --> 04:32:52,260
of processes

6819
04:32:52,260 --> 04:32:54,960
preemption involuntarily saves the

6820
04:32:54,960 --> 04:32:57,659
process State removes the process from

6821
04:32:57,659 --> 04:33:00,359
execution and allows another process to

6822
04:33:00,359 --> 04:33:01,979
run

6823
04:33:01,979 --> 04:33:04,199
interrupts from Hardware devices may

6824
04:33:04,199 --> 04:33:06,719
also preempt running processes in favor

6825
04:33:06,719 --> 04:33:09,240
of Kernel interrupt handlers

6826
04:33:09,240 --> 04:33:11,580
without this type of preemption the

6827
04:33:11,580 --> 04:33:13,500
system would appear to be unresponsive

6828
04:33:13,500 --> 04:33:16,580
to user input

6829
04:33:16,980 --> 04:33:19,680
now in order to store process State

6830
04:33:19,680 --> 04:33:22,080
information the operating system must

6831
04:33:22,080 --> 04:33:24,061
maintain data structures about each

6832
04:33:24,061 --> 04:33:25,438
process

6833
04:33:25,438 --> 04:33:27,299
these structures are called process

6834
04:33:27,299 --> 04:33:30,599
control blocks or pcbs

6835
04:33:30,599 --> 04:33:33,000
pcbs contain Fields where information

6836
04:33:33,000 --> 04:33:35,879
about a process can be saved whenever a

6837
04:33:35,879 --> 04:33:38,520
process is moved off the CPU

6838
04:33:38,520 --> 04:33:41,278
once again this information includes the

6839
04:33:41,278 --> 04:33:43,859
contents of CPU registers and current

6840
04:33:43,859 --> 04:33:46,980
program counter value

6841
04:33:46,980 --> 04:33:49,199
the operating system stores process

6842
04:33:49,199 --> 04:33:51,660
control blocks in linked list structures

6843
04:33:51,660 --> 04:33:55,580
within kernel memory space

6844
04:33:57,118 --> 04:33:59,278
here is a process control Block in

6845
04:33:59,278 --> 04:34:00,958
Greater detail

6846
04:34:00,958 --> 04:34:03,359
some of the information Fields include

6847
04:34:03,359 --> 04:34:06,118
process State the unique ID for the

6848
04:34:06,118 --> 04:34:07,320
process

6849
04:34:07,320 --> 04:34:10,980
the process program counter CPU register

6850
04:34:10,980 --> 04:34:12,539
contents

6851
04:34:12,539 --> 04:34:14,879
memory limits for regions of memory used

6852
04:34:14,879 --> 04:34:16,680
by the process

6853
04:34:16,680 --> 04:34:21,061
open file descriptors and other data

6854
04:34:21,061 --> 04:34:23,580
when performing a process switch it is

6855
04:34:23,580 --> 04:34:25,680
critical that the operating system saves

6856
04:34:25,680 --> 04:34:28,500
the processes CPU state

6857
04:34:28,500 --> 04:34:31,080
at a theoretical minimum this state

6858
04:34:31,080 --> 04:34:33,359
information includes the program counter

6859
04:34:33,359 --> 04:34:36,539
and CPU register contents

6860
04:34:36,539 --> 04:34:39,299
in practice more information will be

6861
04:34:39,299 --> 04:34:43,160
saved during each process switch

6862
04:34:43,859 --> 04:34:46,799
this diagram presents a simplified view

6863
04:34:46,799 --> 04:34:49,379
of process switching where only the

6864
04:34:49,379 --> 04:34:51,778
program counter and register contents

6865
04:34:51,778 --> 04:34:54,180
are saved and restored

6866
04:34:54,180 --> 04:34:56,278
here are the operating system switches

6867
04:34:56,278 --> 04:34:58,919
from the process with iodine 1 to the

6868
04:34:58,919 --> 04:35:01,438
process with id2

6869
04:35:01,438 --> 04:35:03,958
the first step in the process switch is

6870
04:35:03,958 --> 04:35:05,938
to perform a mode switch into kernel

6871
04:35:05,938 --> 04:35:08,580
mode along with the context switch to

6872
04:35:08,580 --> 04:35:10,259
the section of the kernel that handles

6873
04:35:10,259 --> 04:35:11,879
process switching

6874
04:35:11,879 --> 04:35:14,580
that component of the kernel saves the

6875
04:35:14,580 --> 04:35:16,980
program counter and CPU registers into

6876
04:35:16,980 --> 04:35:19,020
the process control block for process

6877
04:35:19,020 --> 04:35:20,580
one

6878
04:35:20,580 --> 04:35:23,879
also the process state for process 1 is

6879
04:35:23,879 --> 04:35:25,080
set to ready

6880
04:35:25,080 --> 04:35:27,539
indicating that the process is ready to

6881
04:35:27,539 --> 04:35:29,938
run again once the CPU core becomes

6882
04:35:29,938 --> 04:35:31,919
available

6883
04:35:31,919 --> 04:35:34,561
the process switching code then restores

6884
04:35:34,561 --> 04:35:37,320
the CPE register contents and program

6885
04:35:37,320 --> 04:35:39,419
counter value from the process control

6886
04:35:39,419 --> 04:35:42,660
block for process 2.

6887
04:35:42,660 --> 04:35:45,180
the state of process 2 is changed from

6888
04:35:45,180 --> 04:35:46,618
ready to running

6889
04:35:46,618 --> 04:35:49,080
the CPU privilege level is returned to

6890
04:35:49,080 --> 04:35:51,840
user mode and context to switch to

6891
04:35:51,840 --> 04:35:53,580
process 2.

6892
04:35:53,580 --> 04:35:58,100
process 2 now begins executing

6893
04:35:58,500 --> 04:36:01,020
during the lifetime of a process the

6894
04:36:01,020 --> 04:36:03,419
corresponding process control block is

6895
04:36:03,419 --> 04:36:05,580
moved between various queues in the

6896
04:36:05,580 --> 04:36:07,320
operating system

6897
04:36:07,320 --> 04:36:09,539
each queue is a linked list of process

6898
04:36:09,539 --> 04:36:12,061
control blocks and multiple linked lists

6899
04:36:12,061 --> 04:36:13,799
overlap

6900
04:36:13,799 --> 04:36:17,759
all pcbs are at all times in the job

6901
04:36:17,759 --> 04:36:20,278
queue which is a linked list of all

6902
04:36:20,278 --> 04:36:23,039
process control blocks in the system

6903
04:36:23,039 --> 04:36:25,680
process control blocks corresponding to

6904
04:36:25,680 --> 04:36:28,141
processes in the ready state are linked

6905
04:36:28,141 --> 04:36:30,118
into the ready list

6906
04:36:30,118 --> 04:36:32,699
processes waiting for device i o have

6907
04:36:32,699 --> 04:36:34,980
their pcbs linked into various different

6908
04:36:34,980 --> 04:36:38,000
device queues

6909
04:36:39,240 --> 04:36:42,180
in this diagram we can see the pcbs for

6910
04:36:42,180 --> 04:36:44,520
five different processes

6911
04:36:44,520 --> 04:36:47,299
all pcbs are members of the job list

6912
04:36:47,299 --> 04:36:50,458
with list links depicted by the green

6913
04:36:50,458 --> 04:36:52,438
arrows

6914
04:36:52,438 --> 04:36:55,740
three jobs are in the ready list and two

6915
04:36:55,740 --> 04:36:58,141
jobs are in a device queue waiting on i

6916
04:36:58,141 --> 04:36:59,278
o

6917
04:36:59,278 --> 04:37:01,680
linked lists within each queue are

6918
04:37:01,680 --> 04:37:05,160
represented by the dark blue arrows

6919
04:37:05,160 --> 04:37:07,740
notice that the two linked lists for the

6920
04:37:07,740 --> 04:37:10,259
queues overlap the linked list for the

6921
04:37:10,259 --> 04:37:11,820
job list

6922
04:37:11,820 --> 04:37:14,759
careful management of linked lists is a

6923
04:37:14,759 --> 04:37:16,680
major requirement of operating system

6924
04:37:16,680 --> 04:37:19,580
kernel code

6925
04:37:20,340 --> 04:37:22,680
now I'd like to shift Focus for a moment

6926
04:37:22,680 --> 04:37:24,660
to mention scheduling since it is

6927
04:37:24,660 --> 04:37:26,400
closely related to the linked list

6928
04:37:26,400 --> 04:37:27,900
management

6929
04:37:27,900 --> 04:37:30,660
in operating systems theory we typically

6930
04:37:30,660 --> 04:37:33,840
divide scheduling into three types job

6931
04:37:33,840 --> 04:37:37,199
scheduling midterm scheduling and CPU

6932
04:37:37,199 --> 04:37:38,820
scheduling

6933
04:37:38,820 --> 04:37:42,480
job or long-term scheduling refers to

6934
04:37:42,480 --> 04:37:44,641
the selection of processes to place into

6935
04:37:44,641 --> 04:37:46,618
the ready state

6936
04:37:46,618 --> 04:37:48,539
this type of scheduler has a long

6937
04:37:48,539 --> 04:37:50,458
interval typically on the order of

6938
04:37:50,458 --> 04:37:52,500
seconds to minutes

6939
04:37:52,500 --> 04:37:54,599
one of the clearest examples of job

6940
04:37:54,599 --> 04:37:57,118
scheduling on Modern systems occurs on

6941
04:37:57,118 --> 04:37:59,879
high performance computational clusters

6942
04:37:59,879 --> 04:38:02,580
on which users submit jobs that may

6943
04:38:02,580 --> 04:38:04,561
require hours to be scheduled and

6944
04:38:04,561 --> 04:38:06,919
execute

6945
04:38:06,919 --> 04:38:09,240
midterm scheduling refers to the

6946
04:38:09,240 --> 04:38:11,699
swapping of inactive processes out to

6947
04:38:11,699 --> 04:38:14,400
disk and restoring swapped processes

6948
04:38:14,400 --> 04:38:16,141
from disk

6949
04:38:16,141 --> 04:38:18,660
many of these tasks are now part of the

6950
04:38:18,660 --> 04:38:21,561
virtual memory subsystem

6951
04:38:21,561 --> 04:38:24,778
CPU scheduling or short-term scheduling

6952
04:38:24,778 --> 04:38:27,240
refers to the selection of processes

6953
04:38:27,240 --> 04:38:30,778
from the ready list to run on CPU cores

6954
04:38:30,778 --> 04:38:32,879
this type of scheduling will be the

6955
04:38:32,879 --> 04:38:36,199
subject to Future lectures

6956
04:38:37,740 --> 04:38:40,379
one important operating system component

6957
04:38:40,379 --> 04:38:42,539
related to short-term scheduling is the

6958
04:38:42,539 --> 04:38:45,000
dispatcher which receives a process

6959
04:38:45,000 --> 04:38:46,740
control block from the short-term

6960
04:38:46,740 --> 04:38:49,020
scheduler and restores the context of

6961
04:38:49,020 --> 04:38:50,458
the process

6962
04:38:50,458 --> 04:38:52,799
the dispatcher also completes the

6963
04:38:52,799 --> 04:38:55,500
context switch to the process by

6964
04:38:55,500 --> 04:38:57,660
performing a mode switch into user mode

6965
04:38:57,660 --> 04:38:59,699
and jumping to the instruction address

6966
04:38:59,699 --> 04:39:02,278
specified by the newly restored program

6967
04:39:02,278 --> 04:39:03,599
counter

6968
04:39:03,599 --> 04:39:06,180
thanks for watching please subscribe and

6969
04:39:06,180 --> 04:39:07,859
don't miss out on new videos and

6970
04:39:07,859 --> 04:39:10,279
lectures

